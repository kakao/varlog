// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/snpb/log_stream_reporter.proto

package snpb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	github_com_kakao_varlog_pkg_types "github.com/kakao/varlog/pkg/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// LogStreamUncommitReport is manifest that log stream reports to metadata
// repository about log entries those are waiting to commit.
type LogStreamUncommitReport struct {
	LogStreamID           github_com_kakao_varlog_pkg_types.LogStreamID `protobuf:"varint,1,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	UncommittedLLSNOffset github_com_kakao_varlog_pkg_types.LLSN        `protobuf:"varint,2,opt,name=uncommitted_llsn_offset,json=uncommittedLlsnOffset,proto3,casttype=github.com/kakao/varlog/pkg/types.LLSN" json:"uncommitted_llsn_offset,omitempty"`
	UncommittedLLSNLength uint64                                        `protobuf:"varint,3,opt,name=uncommitted_llsn_length,json=uncommittedLlsnLength,proto3" json:"uncommitted_llsn_length,omitempty"`
	Version               github_com_kakao_varlog_pkg_types.Version     `protobuf:"varint,4,opt,name=version,proto3,casttype=github.com/kakao/varlog/pkg/types.Version" json:"version,omitempty"`
	HighWatermark         github_com_kakao_varlog_pkg_types.GLSN        `protobuf:"varint,5,opt,name=high_watermark,json=highWatermark,proto3,casttype=github.com/kakao/varlog/pkg/types.GLSN" json:"high_watermark,omitempty"`
}

func (m *LogStreamUncommitReport) Reset()         { *m = LogStreamUncommitReport{} }
func (m *LogStreamUncommitReport) String() string { return proto.CompactTextString(m) }
func (*LogStreamUncommitReport) ProtoMessage()    {}
func (*LogStreamUncommitReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6a839cf0bdc32d5, []int{0}
}
func (m *LogStreamUncommitReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamUncommitReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamUncommitReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamUncommitReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamUncommitReport.Merge(m, src)
}
func (m *LogStreamUncommitReport) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamUncommitReport) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamUncommitReport.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamUncommitReport proto.InternalMessageInfo

func (m *LogStreamUncommitReport) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogStreamUncommitReport) GetUncommittedLLSNOffset() github_com_kakao_varlog_pkg_types.LLSN {
	if m != nil {
		return m.UncommittedLLSNOffset
	}
	return 0
}

func (m *LogStreamUncommitReport) GetUncommittedLLSNLength() uint64 {
	if m != nil {
		return m.UncommittedLLSNLength
	}
	return 0
}

func (m *LogStreamUncommitReport) GetVersion() github_com_kakao_varlog_pkg_types.Version {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *LogStreamUncommitReport) GetHighWatermark() github_com_kakao_varlog_pkg_types.GLSN {
	if m != nil {
		return m.HighWatermark
	}
	return 0
}

type GetReportRequest struct {
}

func (m *GetReportRequest) Reset()         { *m = GetReportRequest{} }
func (m *GetReportRequest) String() string { return proto.CompactTextString(m) }
func (*GetReportRequest) ProtoMessage()    {}
func (*GetReportRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6a839cf0bdc32d5, []int{1}
}
func (m *GetReportRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetReportRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetReportRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetReportRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetReportRequest.Merge(m, src)
}
func (m *GetReportRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetReportRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetReportRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetReportRequest proto.InternalMessageInfo

type GetReportResponse struct {
	StorageNodeID   github_com_kakao_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	UncommitReports []LogStreamUncommitReport                       `protobuf:"bytes,2,rep,name=uncommit_reports,json=uncommitReports,proto3" json:"uncommit_reports"`
}

func (m *GetReportResponse) Reset()         { *m = GetReportResponse{} }
func (m *GetReportResponse) String() string { return proto.CompactTextString(m) }
func (*GetReportResponse) ProtoMessage()    {}
func (*GetReportResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6a839cf0bdc32d5, []int{2}
}
func (m *GetReportResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetReportResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetReportResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetReportResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetReportResponse.Merge(m, src)
}
func (m *GetReportResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetReportResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetReportResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetReportResponse proto.InternalMessageInfo

func (m *GetReportResponse) GetStorageNodeID() github_com_kakao_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *GetReportResponse) GetUncommitReports() []LogStreamUncommitReport {
	if m != nil {
		return m.UncommitReports
	}
	return nil
}

// LogStreamCommitResult has information about commit for a log stream, and it
// tells the log stream how many log entries can be committed. Even if the log
// stream can't commit anything, CommittedLLSNOffset and CommittedGLSNOffset
// should be valid.
//
// Here are examples for clarity. Assume that there are two log streams in a
// topic.
//
//	// LogStream 1 has not committed any log entries, and LogStream 2 has
//	// committed ten.
//	LogStreamCommitResult{
//	    TopicID: 1,
//	    LogStreamID: 1,
//	    Version: 1,
//	    HighWatermark: 10,
//	    CommittedLLSNOffset: 1,
//	    CommittedGLSNOffset: 1,
//	    CommittedGLSNLength: 0,
//	}
//	LogStreamCommitResult{
//	    TopicID: 1,
//	    LogStreamID: 2,
//	    Version: 1,
//	    HighWatermark: 10,
//	    CommittedLLSNOffset: 1,
//	    CommittedGLSNOffset: 1,
//	    CommittedGLSNLength: 10,
//	}
//
//	// LogStream 1 has not committed any log entries again, and LogStream 2 has
//	// committed ten.
//	// Note that the CommittedGLSNOffset of LogStream 1 is one even though the
//	// GLSN 1 has already been issued to other log entries in LogStream 2.
//	LogStreamCommitResult{
//	    TopicID: 1,
//	    LogStreamID: 1,
//	    Version 2,
//	    HighWatermark: 20,
//	    CommittedLLSNOffset: 1,
//	    CommittedGLSNOffset: 1,
//	    CommittedGLSNLength: 0,
//	}
//	LogStreamCommitResult{
//	    TopicID: 1,
//	    LogStreamID: 2,
//	    Version 2,
//	    HighWatermark: 20,
//	    CommittedLLSNOffset: 11,
//	    CommittedGLSNOffset: 11,
//	    CommittedGLSNLength: 10,
//	}
//
//	// LogStream 1 has committed ten log entries, and LogStream 2 has committed
//	// ten.
//	LogStreamCommitResult{
//	    TopicID: 1,
//	    LogStreamID: 1,
//	    Version 3,
//	    HighWatermark: 40,
//	    CommittedLLSNOffset: 1,
//	    CommittedGLSNOffset: 21,
//	    CommittedGLSNLength: 10,
//	}
//	LogStreamCommitResult{
//	    TopicID: 1,
//	    LogStreamID: 2,
//	    Version 3,
//	    HighWatermark: 40,
//	    CommittedLLSNOffset: 21,
//	    CommittedGLSNOffset: 31,
//	    CommittedGLSNLength: 10,
//	}
//
//	// LogStream 1 has committed ten log entries, and LogStream 2 has not.
//	// Note that the CommittedGLSNOffset of LogStream 2 is next to the last
//	// committed GLSN of itself, regardless of LogStream 1.
//	LogStreamCommitResult{
//	    TopicID: 1,
//	    LogStreamID: 1,
//	    Version 4,
//	    HighWatermark: 50,
//	    CommittedLLSNOffset: 11,
//	    CommittedGLSNOffset: 41,
//	    CommittedGLSNLength: 10,
//	}
//	LogStreamCommitResult{
//	    TopicID: 1,
//	    LogStreamID: 2,
//	    Version 4,
//	    HighWatermark: 50,
//	    CommittedLLSNOffset: 31,
//	    CommittedGLSNOffset: 41,
//	    CommittedGLSNLength: 0,
//	}
type LogStreamCommitResult struct {
	// LogStreamID is the identifier for the log stream.
	LogStreamID github_com_kakao_varlog_pkg_types.LogStreamID `protobuf:"varint,1,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	// TopicID is the identifier for the topic to which the log stream belongs.
	TopicID github_com_kakao_varlog_pkg_types.TopicID `protobuf:"varint,2,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	// CommittedLLSNOffset is the starting LLSN of the commit range.
	CommittedLLSNOffset github_com_kakao_varlog_pkg_types.LLSN `protobuf:"varint,3,opt,name=committed_llsn_offset,json=committedLlsnOffset,proto3,casttype=github.com/kakao/varlog/pkg/types.LLSN" json:"committed_llsn_offset,omitempty"`
	// CommittedGLSNOffset is the starting GLSN of the commit range.
	// If there is no log entry to be committed, the CommittedGLSNOffset should be
	// next to the last committed GLSN.
	CommittedGLSNOffset github_com_kakao_varlog_pkg_types.GLSN `protobuf:"varint,4,opt,name=committed_glsn_offset,json=committedGlsnOffset,proto3,casttype=github.com/kakao/varlog/pkg/types.GLSN" json:"committed_glsn_offset,omitempty"`
	// CommittedGLSNLength is the length of the commit range.
	CommittedGLSNLength uint64 `protobuf:"varint,5,opt,name=committed_glsn_length,json=committedGlsnLength,proto3" json:"committed_glsn_length,omitempty"`
	// Version is a unique number for the commit issued by the metadata
	// repository.
	Version github_com_kakao_varlog_pkg_types.Version `protobuf:"varint,6,opt,name=version,proto3,casttype=github.com/kakao/varlog/pkg/types.Version" json:"version,omitempty"`
	// HighWatermark is the maximum GLSN across all log streams of the topic in a
	// specific commit version.
	HighWatermark github_com_kakao_varlog_pkg_types.GLSN `protobuf:"varint,7,opt,name=high_watermark,json=highWatermark,proto3,casttype=github.com/kakao/varlog/pkg/types.GLSN" json:"high_watermark,omitempty"`
}

func (m *LogStreamCommitResult) Reset()         { *m = LogStreamCommitResult{} }
func (m *LogStreamCommitResult) String() string { return proto.CompactTextString(m) }
func (*LogStreamCommitResult) ProtoMessage()    {}
func (*LogStreamCommitResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6a839cf0bdc32d5, []int{3}
}
func (m *LogStreamCommitResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamCommitResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamCommitResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamCommitResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamCommitResult.Merge(m, src)
}
func (m *LogStreamCommitResult) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamCommitResult) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamCommitResult.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamCommitResult proto.InternalMessageInfo

func (m *LogStreamCommitResult) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogStreamCommitResult) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *LogStreamCommitResult) GetCommittedLLSNOffset() github_com_kakao_varlog_pkg_types.LLSN {
	if m != nil {
		return m.CommittedLLSNOffset
	}
	return 0
}

func (m *LogStreamCommitResult) GetCommittedGLSNOffset() github_com_kakao_varlog_pkg_types.GLSN {
	if m != nil {
		return m.CommittedGLSNOffset
	}
	return 0
}

func (m *LogStreamCommitResult) GetCommittedGLSNLength() uint64 {
	if m != nil {
		return m.CommittedGLSNLength
	}
	return 0
}

func (m *LogStreamCommitResult) GetVersion() github_com_kakao_varlog_pkg_types.Version {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *LogStreamCommitResult) GetHighWatermark() github_com_kakao_varlog_pkg_types.GLSN {
	if m != nil {
		return m.HighWatermark
	}
	return 0
}

type CommitBatchRequest struct {
	StorageNodeID github_com_kakao_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	CommitResults []LogStreamCommitResult                         `protobuf:"bytes,2,rep,name=commit_results,json=commitResults,proto3" json:"commit_results"`
}

func (m *CommitBatchRequest) Reset()         { *m = CommitBatchRequest{} }
func (m *CommitBatchRequest) String() string { return proto.CompactTextString(m) }
func (*CommitBatchRequest) ProtoMessage()    {}
func (*CommitBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6a839cf0bdc32d5, []int{4}
}
func (m *CommitBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitBatchRequest.Merge(m, src)
}
func (m *CommitBatchRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CommitBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CommitBatchRequest proto.InternalMessageInfo

func (m *CommitBatchRequest) GetStorageNodeID() github_com_kakao_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *CommitBatchRequest) GetCommitResults() []LogStreamCommitResult {
	if m != nil {
		return m.CommitResults
	}
	return nil
}

type CommitBatchResponse struct {
}

func (m *CommitBatchResponse) Reset()         { *m = CommitBatchResponse{} }
func (m *CommitBatchResponse) String() string { return proto.CompactTextString(m) }
func (*CommitBatchResponse) ProtoMessage()    {}
func (*CommitBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6a839cf0bdc32d5, []int{5}
}
func (m *CommitBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitBatchResponse.Merge(m, src)
}
func (m *CommitBatchResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CommitBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommitBatchResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*LogStreamUncommitReport)(nil), "varlog.snpb.LogStreamUncommitReport")
	proto.RegisterType((*GetReportRequest)(nil), "varlog.snpb.GetReportRequest")
	proto.RegisterType((*GetReportResponse)(nil), "varlog.snpb.GetReportResponse")
	proto.RegisterType((*LogStreamCommitResult)(nil), "varlog.snpb.LogStreamCommitResult")
	proto.RegisterType((*CommitBatchRequest)(nil), "varlog.snpb.CommitBatchRequest")
	proto.RegisterType((*CommitBatchResponse)(nil), "varlog.snpb.CommitBatchResponse")
}

func init() {
	proto.RegisterFile("proto/snpb/log_stream_reporter.proto", fileDescriptor_b6a839cf0bdc32d5)
}

var fileDescriptor_b6a839cf0bdc32d5 = []byte{
	// 696 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x95, 0x4f, 0x6f, 0xd3, 0x30,
	0x18, 0xc6, 0x9b, 0xad, 0x5b, 0xc1, 0x55, 0xf7, 0xc7, 0x53, 0xb5, 0x32, 0x89, 0xa4, 0x8a, 0x26,
	0x54, 0x90, 0xd6, 0xa0, 0x71, 0x41, 0xc0, 0x01, 0xba, 0x49, 0x65, 0xa2, 0xda, 0x58, 0xba, 0x81,
	0xc4, 0xa5, 0x4a, 0x1b, 0x2f, 0xad, 0x9a, 0xc6, 0x21, 0x76, 0x86, 0x10, 0x5f, 0x82, 0x8f, 0xb0,
	0xef, 0xc1, 0x85, 0xe3, 0x8e, 0x93, 0xb8, 0xec, 0x94, 0x43, 0x7a, 0xe1, 0xca, 0x75, 0x27, 0x14,
	0x3b, 0x4d, 0x1d, 0xda, 0x6a, 0x43, 0x93, 0x76, 0x8b, 0x5f, 0xbf, 0xef, 0xf3, 0xb3, 0x9d, 0xf7,
	0xb1, 0xc1, 0xa6, 0xeb, 0x61, 0x8a, 0x35, 0xe2, 0xb8, 0x6d, 0xcd, 0xc6, 0x56, 0x8b, 0x50, 0x0f,
	0x19, 0x83, 0x96, 0x87, 0x5c, 0xec, 0x51, 0xe4, 0x55, 0xd9, 0x34, 0xcc, 0x9f, 0x1a, 0x9e, 0x8d,
	0xad, 0x6a, 0x94, 0xb6, 0xb1, 0x65, 0xf5, 0x68, 0xd7, 0x6f, 0x57, 0x3b, 0x78, 0xa0, 0x59, 0xd8,
	0xc2, 0x1a, 0xcb, 0x69, 0xfb, 0x27, 0x6c, 0xc4, 0xf5, 0xa2, 0x2f, 0x5e, 0xab, 0xfe, 0x99, 0x07,
	0xeb, 0x0d, 0x6c, 0x35, 0x99, 0xf0, 0xb1, 0xd3, 0xc1, 0x83, 0x41, 0x8f, 0xea, 0x4c, 0x1f, 0x9a,
	0xa0, 0x20, 0x40, 0x7b, 0x66, 0x49, 0x2a, 0x4b, 0x95, 0x85, 0xda, 0xeb, 0x30, 0x50, 0xf2, 0x49,
	0xcd, 0xde, 0xee, 0x55, 0xa0, 0x88, 0xd0, 0xbe, 0xd1, 0x37, 0xb0, 0xc6, 0x97, 0xa4, 0xb9, 0x7d,
	0x4b, 0xa3, 0x5f, 0x5d, 0x44, 0xaa, 0x42, 0x81, 0x9e, 0xb7, 0x93, 0x81, 0x09, 0xbf, 0x81, 0x75,
	0x3f, 0xe6, 0x52, 0x64, 0xb6, 0x6c, 0x9b, 0x38, 0x2d, 0x7c, 0x72, 0x42, 0x10, 0x2d, 0xcd, 0x95,
	0xa5, 0x4a, 0xb6, 0xb6, 0x13, 0x06, 0x4a, 0xf1, 0x78, 0x9c, 0xd2, 0x68, 0x34, 0xf7, 0x0f, 0x58,
	0xc2, 0x55, 0xa0, 0x3c, 0xba, 0x01, 0xb9, 0xd1, 0xdc, 0xd7, 0x8b, 0x02, 0xa3, 0x61, 0x13, 0x87,
	0x0b, 0xc0, 0xc3, 0x29, 0x70, 0x1b, 0x39, 0x16, 0xed, 0x96, 0xe6, 0x19, 0xfc, 0xc1, 0x14, 0x78,
	0x83, 0x25, 0x4c, 0x48, 0xf2, 0x30, 0xac, 0x83, 0xdc, 0x29, 0xf2, 0x48, 0x0f, 0x3b, 0xa5, 0x2c,
	0x93, 0xd8, 0xba, 0x0a, 0x94, 0xc7, 0xd7, 0x2f, 0xf3, 0x03, 0x2f, 0xd2, 0x47, 0xd5, 0xf0, 0x10,
	0x2c, 0x75, 0x7b, 0x56, 0xb7, 0xf5, 0xc5, 0xa0, 0xc8, 0x1b, 0x18, 0x5e, 0xbf, 0xb4, 0xc0, 0xf4,
	0x9e, 0xdc, 0x6c, 0xdb, 0xf5, 0x68, 0xdb, 0x85, 0x48, 0xe1, 0xe3, 0x48, 0xe0, 0x45, 0xf6, 0xf7,
	0x99, 0x22, 0xa9, 0x10, 0xac, 0xd4, 0x51, 0xfc, 0x93, 0x75, 0xf4, 0xd9, 0x47, 0x84, 0xaa, 0x97,
	0x12, 0x58, 0x15, 0x82, 0xc4, 0xc5, 0x0e, 0x41, 0xd0, 0x06, 0xcb, 0x84, 0x62, 0xcf, 0xb0, 0x50,
	0xcb, 0xc1, 0x26, 0x1a, 0xf7, 0xc0, 0x6e, 0x18, 0x28, 0x85, 0x26, 0x9f, 0xda, 0xc7, 0x26, 0x62,
	0x5d, 0xa0, 0x5d, 0xbf, 0xa8, 0x54, 0x89, 0x5e, 0x20, 0xc2, 0xd0, 0x84, 0xc7, 0x60, 0x65, 0x74,
	0xa4, 0x71, 0x8b, 0x93, 0xd2, 0x5c, 0x79, 0xbe, 0x92, 0xdf, 0xde, 0xac, 0x0a, 0x2d, 0x5e, 0x9d,
	0xd1, 0xaf, 0xb5, 0xec, 0x79, 0xa0, 0x64, 0xf4, 0x65, 0x3f, 0x15, 0x25, 0xea, 0xcf, 0x05, 0x50,
	0x4c, 0x4a, 0x76, 0xe2, 0x29, 0xe2, 0xdb, 0x77, 0xd5, 0xe0, 0x4d, 0x70, 0x8f, 0x62, 0xb7, 0xd7,
	0x89, 0x00, 0x73, 0x0c, 0xf0, 0x3c, 0x0c, 0x94, 0xdc, 0x51, 0x14, 0x63, 0xe2, 0x37, 0x68, 0x8e,
	0x38, 0x59, 0xcf, 0x31, 0xa5, 0x3d, 0x13, 0xfa, 0xa0, 0x38, 0xdd, 0x33, 0xbc, 0x6d, 0xdf, 0x84,
	0x81, 0xb2, 0xb6, 0x73, 0x2b, 0xc7, 0xac, 0x4d, 0xf3, 0x4b, 0x0a, 0x6b, 0x09, 0xd8, 0xec, 0x14,
	0x6c, 0xfd, 0x3f, 0xb1, 0xf5, 0x34, 0xb6, 0x3e, 0xc6, 0xbe, 0x9b, 0xc0, 0xc6, 0x26, 0xe5, 0x8e,
	0x58, 0x9f, 0xc0, 0xc6, 0x16, 0x4d, 0x8b, 0x4d, 0x1a, 0x74, 0xf1, 0x56, 0x06, 0x6d, 0x4f, 0x18,
	0x34, 0xc7, 0xf4, 0x5e, 0x46, 0xe6, 0x78, 0x2b, 0x1a, 0xef, 0xb6, 0x8e, 0xfd, 0x25, 0x01, 0xc8,
	0xf7, 0x57, 0x33, 0x68, 0xa7, 0x1b, 0x9b, 0xf6, 0x8e, 0xed, 0x79, 0x00, 0x96, 0x12, 0x73, 0x46,
	0xf6, 0x19, 0x99, 0x53, 0x9d, 0x6e, 0x4e, 0xd1, 0x69, 0xb1, 0x35, 0x0b, 0x1d, 0x21, 0x46, 0xd4,
	0x22, 0x58, 0x4b, 0x6d, 0x8a, 0x5f, 0x3a, 0xdb, 0x3f, 0x24, 0xb0, 0x9a, 0xa8, 0xe8, 0xf1, 0x53,
	0x07, 0xdf, 0x83, 0xfb, 0xc9, 0xfd, 0x04, 0x1f, 0xa6, 0x90, 0xff, 0x5e, 0x66, 0x1b, 0xf2, 0xac,
	0x69, 0x4e, 0x50, 0x33, 0x15, 0xe9, 0xa9, 0x04, 0x8f, 0x40, 0x5e, 0xc0, 0x43, 0x25, 0x55, 0x34,
	0x79, 0xda, 0x1b, 0xe5, 0xd9, 0x09, 0x63, 0xdd, 0xda, 0xab, 0xf3, 0x50, 0x96, 0x2e, 0x42, 0x59,
	0xfa, 0x3e, 0x94, 0x33, 0x67, 0x43, 0x59, 0xba, 0x18, 0xca, 0x99, 0xcb, 0xa1, 0x9c, 0xf9, 0xa4,
	0xce, 0x3c, 0xff, 0xe4, 0x91, 0x6f, 0x2f, 0xb2, 0xef, 0x67, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff,
	0x9c, 0x0b, 0x4b, 0x09, 0xf9, 0x07, 0x00, 0x00,
}

func (this *LogStreamUncommitReport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogStreamUncommitReport)
	if !ok {
		that2, ok := that.(LogStreamUncommitReport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LogStreamID != that1.LogStreamID {
		return false
	}
	if this.UncommittedLLSNOffset != that1.UncommittedLLSNOffset {
		return false
	}
	if this.UncommittedLLSNLength != that1.UncommittedLLSNLength {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.HighWatermark != that1.HighWatermark {
		return false
	}
	return true
}
func (this *LogStreamCommitResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogStreamCommitResult)
	if !ok {
		that2, ok := that.(LogStreamCommitResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LogStreamID != that1.LogStreamID {
		return false
	}
	if this.TopicID != that1.TopicID {
		return false
	}
	if this.CommittedLLSNOffset != that1.CommittedLLSNOffset {
		return false
	}
	if this.CommittedGLSNOffset != that1.CommittedGLSNOffset {
		return false
	}
	if this.CommittedGLSNLength != that1.CommittedGLSNLength {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.HighWatermark != that1.HighWatermark {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// LogStreamReporterClient is the client API for LogStreamReporter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LogStreamReporterClient interface {
	GetReport(ctx context.Context, opts ...grpc.CallOption) (LogStreamReporter_GetReportClient, error)
	CommitBatch(ctx context.Context, opts ...grpc.CallOption) (LogStreamReporter_CommitBatchClient, error)
}

type logStreamReporterClient struct {
	cc *grpc.ClientConn
}

func NewLogStreamReporterClient(cc *grpc.ClientConn) LogStreamReporterClient {
	return &logStreamReporterClient{cc}
}

func (c *logStreamReporterClient) GetReport(ctx context.Context, opts ...grpc.CallOption) (LogStreamReporter_GetReportClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LogStreamReporter_serviceDesc.Streams[0], "/varlog.snpb.LogStreamReporter/GetReport", opts...)
	if err != nil {
		return nil, err
	}
	x := &logStreamReporterGetReportClient{stream}
	return x, nil
}

type LogStreamReporter_GetReportClient interface {
	Send(*GetReportRequest) error
	Recv() (*GetReportResponse, error)
	grpc.ClientStream
}

type logStreamReporterGetReportClient struct {
	grpc.ClientStream
}

func (x *logStreamReporterGetReportClient) Send(m *GetReportRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *logStreamReporterGetReportClient) Recv() (*GetReportResponse, error) {
	m := new(GetReportResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logStreamReporterClient) CommitBatch(ctx context.Context, opts ...grpc.CallOption) (LogStreamReporter_CommitBatchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LogStreamReporter_serviceDesc.Streams[1], "/varlog.snpb.LogStreamReporter/CommitBatch", opts...)
	if err != nil {
		return nil, err
	}
	x := &logStreamReporterCommitBatchClient{stream}
	return x, nil
}

type LogStreamReporter_CommitBatchClient interface {
	Send(*CommitBatchRequest) error
	CloseAndRecv() (*CommitBatchResponse, error)
	grpc.ClientStream
}

type logStreamReporterCommitBatchClient struct {
	grpc.ClientStream
}

func (x *logStreamReporterCommitBatchClient) Send(m *CommitBatchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *logStreamReporterCommitBatchClient) CloseAndRecv() (*CommitBatchResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CommitBatchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LogStreamReporterServer is the server API for LogStreamReporter service.
type LogStreamReporterServer interface {
	GetReport(LogStreamReporter_GetReportServer) error
	CommitBatch(LogStreamReporter_CommitBatchServer) error
}

// UnimplementedLogStreamReporterServer can be embedded to have forward compatible implementations.
type UnimplementedLogStreamReporterServer struct {
}

func (*UnimplementedLogStreamReporterServer) GetReport(srv LogStreamReporter_GetReportServer) error {
	return status.Errorf(codes.Unimplemented, "method GetReport not implemented")
}
func (*UnimplementedLogStreamReporterServer) CommitBatch(srv LogStreamReporter_CommitBatchServer) error {
	return status.Errorf(codes.Unimplemented, "method CommitBatch not implemented")
}

func RegisterLogStreamReporterServer(s *grpc.Server, srv LogStreamReporterServer) {
	s.RegisterService(&_LogStreamReporter_serviceDesc, srv)
}

func _LogStreamReporter_GetReport_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LogStreamReporterServer).GetReport(&logStreamReporterGetReportServer{stream})
}

type LogStreamReporter_GetReportServer interface {
	Send(*GetReportResponse) error
	Recv() (*GetReportRequest, error)
	grpc.ServerStream
}

type logStreamReporterGetReportServer struct {
	grpc.ServerStream
}

func (x *logStreamReporterGetReportServer) Send(m *GetReportResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *logStreamReporterGetReportServer) Recv() (*GetReportRequest, error) {
	m := new(GetReportRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _LogStreamReporter_CommitBatch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LogStreamReporterServer).CommitBatch(&logStreamReporterCommitBatchServer{stream})
}

type LogStreamReporter_CommitBatchServer interface {
	SendAndClose(*CommitBatchResponse) error
	Recv() (*CommitBatchRequest, error)
	grpc.ServerStream
}

type logStreamReporterCommitBatchServer struct {
	grpc.ServerStream
}

func (x *logStreamReporterCommitBatchServer) SendAndClose(m *CommitBatchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *logStreamReporterCommitBatchServer) Recv() (*CommitBatchRequest, error) {
	m := new(CommitBatchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _LogStreamReporter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "varlog.snpb.LogStreamReporter",
	HandlerType: (*LogStreamReporterServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetReport",
			Handler:       _LogStreamReporter_GetReport_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "CommitBatch",
			Handler:       _LogStreamReporter_CommitBatch_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "proto/snpb/log_stream_reporter.proto",
}

func (m *LogStreamUncommitReport) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamUncommitReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamUncommitReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighWatermark != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.HighWatermark))
		i--
		dAtA[i] = 0x28
	}
	if m.Version != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x20
	}
	if m.UncommittedLLSNLength != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.UncommittedLLSNLength))
		i--
		dAtA[i] = 0x18
	}
	if m.UncommittedLLSNOffset != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.UncommittedLLSNOffset))
		i--
		dAtA[i] = 0x10
	}
	if m.LogStreamID != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetReportRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetReportRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetReportRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetReportResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetReportResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetReportResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UncommitReports) > 0 {
		for iNdEx := len(m.UncommitReports) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UncommitReports[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLogStreamReporter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogStreamCommitResult) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamCommitResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamCommitResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighWatermark != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.HighWatermark))
		i--
		dAtA[i] = 0x38
	}
	if m.Version != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x30
	}
	if m.CommittedGLSNLength != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.CommittedGLSNLength))
		i--
		dAtA[i] = 0x28
	}
	if m.CommittedGLSNOffset != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.CommittedGLSNOffset))
		i--
		dAtA[i] = 0x20
	}
	if m.CommittedLLSNOffset != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.CommittedLLSNOffset))
		i--
		dAtA[i] = 0x18
	}
	if m.TopicID != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x10
	}
	if m.LogStreamID != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommitBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitBatchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CommitResults) > 0 {
		for iNdEx := len(m.CommitResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CommitResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintLogStreamReporter(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintLogStreamReporter(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommitBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitBatchResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintLogStreamReporter(dAtA []byte, offset int, v uint64) int {
	offset -= sovLogStreamReporter(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LogStreamUncommitReport) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStreamID != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.LogStreamID))
	}
	if m.UncommittedLLSNOffset != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.UncommittedLLSNOffset))
	}
	if m.UncommittedLLSNLength != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.UncommittedLLSNLength))
	}
	if m.Version != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.Version))
	}
	if m.HighWatermark != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.HighWatermark))
	}
	return n
}

func (m *GetReportRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetReportResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.StorageNodeID))
	}
	if len(m.UncommitReports) > 0 {
		for _, e := range m.UncommitReports {
			l = e.ProtoSize()
			n += 1 + l + sovLogStreamReporter(uint64(l))
		}
	}
	return n
}

func (m *LogStreamCommitResult) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStreamID != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.LogStreamID))
	}
	if m.TopicID != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.TopicID))
	}
	if m.CommittedLLSNOffset != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.CommittedLLSNOffset))
	}
	if m.CommittedGLSNOffset != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.CommittedGLSNOffset))
	}
	if m.CommittedGLSNLength != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.CommittedGLSNLength))
	}
	if m.Version != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.Version))
	}
	if m.HighWatermark != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.HighWatermark))
	}
	return n
}

func (m *CommitBatchRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovLogStreamReporter(uint64(m.StorageNodeID))
	}
	if len(m.CommitResults) > 0 {
		for _, e := range m.CommitResults {
			l = e.ProtoSize()
			n += 1 + l + sovLogStreamReporter(uint64(l))
		}
	}
	return n
}

func (m *CommitBatchResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovLogStreamReporter(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozLogStreamReporter(x uint64) (n int) {
	return sovLogStreamReporter(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LogStreamUncommitReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogStreamReporter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamUncommitReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamUncommitReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncommittedLLSNOffset", wireType)
			}
			m.UncommittedLLSNOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncommittedLLSNOffset |= github_com_kakao_varlog_pkg_types.LLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncommittedLLSNLength", wireType)
			}
			m.UncommittedLLSNLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UncommittedLLSNLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= github_com_kakao_varlog_pkg_types.Version(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWatermark", wireType)
			}
			m.HighWatermark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighWatermark |= github_com_kakao_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogStreamReporter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetReportRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogStreamReporter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetReportRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetReportRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLogStreamReporter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetReportResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogStreamReporter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetReportResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetReportResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_com_kakao_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncommitReports", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UncommitReports = append(m.UncommitReports, LogStreamUncommitReport{})
			if err := m.UncommitReports[len(m.UncommitReports)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogStreamReporter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogStreamCommitResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogStreamReporter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamCommitResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamCommitResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedLLSNOffset", wireType)
			}
			m.CommittedLLSNOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedLLSNOffset |= github_com_kakao_varlog_pkg_types.LLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedGLSNOffset", wireType)
			}
			m.CommittedGLSNOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedGLSNOffset |= github_com_kakao_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedGLSNLength", wireType)
			}
			m.CommittedGLSNLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedGLSNLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= github_com_kakao_varlog_pkg_types.Version(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWatermark", wireType)
			}
			m.HighWatermark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighWatermark |= github_com_kakao_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipLogStreamReporter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogStreamReporter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_com_kakao_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitResults = append(m.CommitResults, LogStreamCommitResult{})
			if err := m.CommitResults[len(m.CommitResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipLogStreamReporter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowLogStreamReporter
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipLogStreamReporter(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthLogStreamReporter
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipLogStreamReporter(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowLogStreamReporter
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowLogStreamReporter
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthLogStreamReporter
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupLogStreamReporter
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthLogStreamReporter
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthLogStreamReporter        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowLogStreamReporter          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupLogStreamReporter = fmt.Errorf("proto: unexpected end of group")
)
