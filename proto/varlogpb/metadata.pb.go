// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/varlogpb/metadata.proto

package varlogpb

import (
	bytes "bytes"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"

	github_daumkakao_com_varlog_varlog_pkg_types "github.daumkakao.com/varlog/varlog/pkg/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StorageNodeStatus int32

const (
	StorageNodeStatusRunning StorageNodeStatus = 0
	StorageNodeStatusDeleted StorageNodeStatus = 1
)

var StorageNodeStatus_name = map[int32]string{
	0: "SN_STATUS_RUNNING",
	1: "SN_STATUS_DELETED",
}

var StorageNodeStatus_value = map[string]int32{
	"SN_STATUS_RUNNING": 0,
	"SN_STATUS_DELETED": 1,
}

func (x StorageNodeStatus) String() string {
	return proto.EnumName(StorageNodeStatus_name, int32(x))
}

func (StorageNodeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{0}
}

type LogStreamStatus int32

const (
	LogStreamStatusRunning   LogStreamStatus = 0
	LogStreamStatusSealing   LogStreamStatus = 1
	LogStreamStatusSealed    LogStreamStatus = 2
	LogStreamStatusDeleted   LogStreamStatus = 3
	LogStreamStatusUnsealing LogStreamStatus = 4
)

var LogStreamStatus_name = map[int32]string{
	0: "LS_STATUS_RUNNING",
	1: "LS_STATUS_SEALING",
	2: "LS_STATUS_SEALED",
	3: "LS_STATUS_DELETED",
	4: "LS_STATUS_UNSEALING",
}

var LogStreamStatus_value = map[string]int32{
	"LS_STATUS_RUNNING":   0,
	"LS_STATUS_SEALING":   1,
	"LS_STATUS_SEALED":    2,
	"LS_STATUS_DELETED":   3,
	"LS_STATUS_UNSEALING": 4,
}

func (x LogStreamStatus) String() string {
	return proto.EnumName(LogStreamStatus_name, int32(x))
}

func (LogStreamStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{1}
}

type TopicStatus int32

const (
	TopicStatusRunning TopicStatus = 0
	TopicStatusDeleted TopicStatus = 1
)

var TopicStatus_name = map[int32]string{
	0: "TOPIC_STATUS_RUNNING",
	1: "TOPIC_STATUS_DELETED",
}

var TopicStatus_value = map[string]int32{
	"TOPIC_STATUS_RUNNING": 0,
	"TOPIC_STATUS_DELETED": 1,
}

func (x TopicStatus) String() string {
	return proto.EnumName(TopicStatus_name, int32(x))
}

func (TopicStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{2}
}

// StorageNode is a structure to represent identifier and address of storage
// node.
type StorageNode struct {
	StorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	Address       string                                                     `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *StorageNode) Reset()         { *m = StorageNode{} }
func (m *StorageNode) String() string { return proto.CompactTextString(m) }
func (*StorageNode) ProtoMessage()    {}
func (*StorageNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{0}
}
func (m *StorageNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageNode.Merge(m, src)
}
func (m *StorageNode) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageNode) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageNode.DiscardUnknown(m)
}

var xxx_messageInfo_StorageNode proto.InternalMessageInfo

func (m *StorageNode) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *StorageNode) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type Replica struct {
	StorageNode `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3,embedded=storage_node" json:"storage_node"`
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,2,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,3,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *Replica) Reset()         { *m = Replica{} }
func (m *Replica) String() string { return proto.CompactTextString(m) }
func (*Replica) ProtoMessage()    {}
func (*Replica) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{1}
}
func (m *Replica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replica.Merge(m, src)
}
func (m *Replica) XXX_Size() int {
	return m.ProtoSize()
}
func (m *Replica) XXX_DiscardUnknown() {
	xxx_messageInfo_Replica.DiscardUnknown(m)
}

var xxx_messageInfo_Replica proto.InternalMessageInfo

func (m *Replica) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *Replica) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type StorageDescriptor struct {
	Path  string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Used  uint64 `protobuf:"varint,2,opt,name=used,proto3" json:"used,omitempty"`
	Total uint64 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *StorageDescriptor) Reset()         { *m = StorageDescriptor{} }
func (m *StorageDescriptor) String() string { return proto.CompactTextString(m) }
func (*StorageDescriptor) ProtoMessage()    {}
func (*StorageDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{2}
}
func (m *StorageDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDescriptor.Merge(m, src)
}
func (m *StorageDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDescriptor proto.InternalMessageInfo

func (m *StorageDescriptor) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *StorageDescriptor) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *StorageDescriptor) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type StorageNodeDescriptor struct {
	StorageNode `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3,embedded=storage_node" json:"storage_node"`
	Status      StorageNodeStatus    `protobuf:"varint,2,opt,name=status,proto3,enum=varlog.varlogpb.StorageNodeStatus" json:"status,omitempty"`
	Storages    []*StorageDescriptor `protobuf:"bytes,3,rep,name=storages,proto3" json:"storages,omitempty"`
}

func (m *StorageNodeDescriptor) Reset()         { *m = StorageNodeDescriptor{} }
func (m *StorageNodeDescriptor) String() string { return proto.CompactTextString(m) }
func (*StorageNodeDescriptor) ProtoMessage()    {}
func (*StorageNodeDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{3}
}
func (m *StorageNodeDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageNodeDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageNodeDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageNodeDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageNodeDescriptor.Merge(m, src)
}
func (m *StorageNodeDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageNodeDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageNodeDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StorageNodeDescriptor proto.InternalMessageInfo

func (m *StorageNodeDescriptor) GetStatus() StorageNodeStatus {
	if m != nil {
		return m.Status
	}
	return StorageNodeStatusRunning
}

func (m *StorageNodeDescriptor) GetStorages() []*StorageDescriptor {
	if m != nil {
		return m.Storages
	}
	return nil
}

type ReplicaDescriptor struct {
	StorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	Path          string                                                     `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *ReplicaDescriptor) Reset()         { *m = ReplicaDescriptor{} }
func (m *ReplicaDescriptor) String() string { return proto.CompactTextString(m) }
func (*ReplicaDescriptor) ProtoMessage()    {}
func (*ReplicaDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{4}
}
func (m *ReplicaDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicaDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaDescriptor.Merge(m, src)
}
func (m *ReplicaDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReplicaDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaDescriptor proto.InternalMessageInfo

func (m *ReplicaDescriptor) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *ReplicaDescriptor) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// FIXME (jun): LogStreamDescriptor
// - Similar types
// - Ambiguous naming
//
// Information for log stream, not replica
type LogStreamDescriptor struct {
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	Status      LogStreamStatus                                          `protobuf:"varint,3,opt,name=status,proto3,enum=varlog.varlogpb.LogStreamStatus" json:"status,omitempty"`
	Replicas    []*ReplicaDescriptor                                     `protobuf:"bytes,4,rep,name=replicas,proto3" json:"replicas,omitempty"`
	Head        LogEntryMeta                                             `protobuf:"bytes,5,opt,name=head,proto3" json:"head"`
	Tail        LogEntryMeta                                             `protobuf:"bytes,6,opt,name=tail,proto3" json:"tail"`
}

func (m *LogStreamDescriptor) Reset()         { *m = LogStreamDescriptor{} }
func (m *LogStreamDescriptor) String() string { return proto.CompactTextString(m) }
func (*LogStreamDescriptor) ProtoMessage()    {}
func (*LogStreamDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{5}
}
func (m *LogStreamDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamDescriptor.Merge(m, src)
}
func (m *LogStreamDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamDescriptor proto.InternalMessageInfo

func (m *LogStreamDescriptor) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *LogStreamDescriptor) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogStreamDescriptor) GetStatus() LogStreamStatus {
	if m != nil {
		return m.Status
	}
	return LogStreamStatusRunning
}

func (m *LogStreamDescriptor) GetReplicas() []*ReplicaDescriptor {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *LogStreamDescriptor) GetHead() LogEntryMeta {
	if m != nil {
		return m.Head
	}
	return LogEntryMeta{}
}

func (m *LogStreamDescriptor) GetTail() LogEntryMeta {
	if m != nil {
		return m.Tail
	}
	return LogEntryMeta{}
}

type TopicDescriptor struct {
	TopicID    github_daumkakao_com_varlog_varlog_pkg_types.TopicID       `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	Status     TopicStatus                                                `protobuf:"varint,2,opt,name=status,proto3,enum=varlog.varlogpb.TopicStatus" json:"status,omitempty"`
	LogStreams []github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,3,rep,packed,name=log_streams,json=logStreams,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_streams,omitempty"`
}

func (m *TopicDescriptor) Reset()         { *m = TopicDescriptor{} }
func (m *TopicDescriptor) String() string { return proto.CompactTextString(m) }
func (*TopicDescriptor) ProtoMessage()    {}
func (*TopicDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{6}
}
func (m *TopicDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicDescriptor.Merge(m, src)
}
func (m *TopicDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TopicDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_TopicDescriptor proto.InternalMessageInfo

func (m *TopicDescriptor) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *TopicDescriptor) GetStatus() TopicStatus {
	if m != nil {
		return m.Status
	}
	return TopicStatusRunning
}

func (m *TopicDescriptor) GetLogStreams() []github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

type MetadataDescriptor struct {
	AppliedIndex uint64                   `protobuf:"varint,1,opt,name=applied_index,json=appliedIndex,proto3" json:"applied_index,omitempty"`
	StorageNodes []*StorageNodeDescriptor `protobuf:"bytes,2,rep,name=storage_nodes,json=storageNodes,proto3" json:"storage_nodes,omitempty"`
	LogStreams   []*LogStreamDescriptor   `protobuf:"bytes,3,rep,name=log_streams,json=logStreams,proto3" json:"log_streams,omitempty"`
	Topics       []*TopicDescriptor       `protobuf:"bytes,4,rep,name=topics,proto3" json:"topics,omitempty"`
}

func (m *MetadataDescriptor) Reset()         { *m = MetadataDescriptor{} }
func (m *MetadataDescriptor) String() string { return proto.CompactTextString(m) }
func (*MetadataDescriptor) ProtoMessage()    {}
func (*MetadataDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{7}
}
func (m *MetadataDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataDescriptor.Merge(m, src)
}
func (m *MetadataDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MetadataDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataDescriptor proto.InternalMessageInfo

func (m *MetadataDescriptor) GetAppliedIndex() uint64 {
	if m != nil {
		return m.AppliedIndex
	}
	return 0
}

func (m *MetadataDescriptor) GetStorageNodes() []*StorageNodeDescriptor {
	if m != nil {
		return m.StorageNodes
	}
	return nil
}

func (m *MetadataDescriptor) GetLogStreams() []*LogStreamDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

func (m *MetadataDescriptor) GetTopics() []*TopicDescriptor {
	if m != nil {
		return m.Topics
	}
	return nil
}

// StorageNodeMetadataDescriptor represents metadata of stroage node.
type StorageNodeMetadataDescriptor struct {
	// ClusterID is the identifier of the cluster that the storage node belongs
	// to.
	ClusterID github_daumkakao_com_varlog_varlog_pkg_types.ClusterID `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.ClusterID" json:"cluster_id,omitempty"`
	// StorageNode is detailed information about the storage node.
	StorageNode *StorageNodeDescriptor        `protobuf:"bytes,2,opt,name=storage_node,json=storageNode,proto3" json:"storage_node,omitempty"`
	LogStreams  []LogStreamMetadataDescriptor `protobuf:"bytes,3,rep,name=log_streams,json=logStreams,proto3" json:"log_streams"`
	CreatedTime time.Time                     `protobuf:"bytes,4,opt,name=created_time,json=createdTime,proto3,stdtime" json:"created_time"`
	UpdatedTime time.Time                     `protobuf:"bytes,5,opt,name=updated_time,json=updatedTime,proto3,stdtime" json:"updated_time"`
}

func (m *StorageNodeMetadataDescriptor) Reset()         { *m = StorageNodeMetadataDescriptor{} }
func (m *StorageNodeMetadataDescriptor) String() string { return proto.CompactTextString(m) }
func (*StorageNodeMetadataDescriptor) ProtoMessage()    {}
func (*StorageNodeMetadataDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{8}
}
func (m *StorageNodeMetadataDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageNodeMetadataDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageNodeMetadataDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageNodeMetadataDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageNodeMetadataDescriptor.Merge(m, src)
}
func (m *StorageNodeMetadataDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageNodeMetadataDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageNodeMetadataDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StorageNodeMetadataDescriptor proto.InternalMessageInfo

func (m *StorageNodeMetadataDescriptor) GetClusterID() github_daumkakao_com_varlog_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *StorageNodeMetadataDescriptor) GetStorageNode() *StorageNodeDescriptor {
	if m != nil {
		return m.StorageNode
	}
	return nil
}

func (m *StorageNodeMetadataDescriptor) GetLogStreams() []LogStreamMetadataDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

func (m *StorageNodeMetadataDescriptor) GetCreatedTime() time.Time {
	if m != nil {
		return m.CreatedTime
	}
	return time.Time{}
}

func (m *StorageNodeMetadataDescriptor) GetUpdatedTime() time.Time {
	if m != nil {
		return m.UpdatedTime
	}
	return time.Time{}
}

// FIXME (jun): LogStreamMetadataDescriptor
// - Similar types
// - Ambiguous naming
//
// maybe LogStreamReplica's information
type LogStreamMetadataDescriptor struct {
	StorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	LogStreamID   github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID   `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	TopicID       github_daumkakao_com_varlog_varlog_pkg_types.TopicID       `protobuf:"varint,3,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	Status        LogStreamStatus                                            `protobuf:"varint,4,opt,name=status,proto3,enum=varlog.varlogpb.LogStreamStatus" json:"status,omitempty"`
	Version       github_daumkakao_com_varlog_varlog_pkg_types.Version       `protobuf:"varint,5,opt,name=version,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.Version" json:"version,omitempty"`
	HighWatermark github_daumkakao_com_varlog_varlog_pkg_types.GLSN          `protobuf:"varint,6,opt,name=high_watermark,json=highWatermark,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"high_watermark,omitempty"`
	Path          string                                                     `protobuf:"bytes,7,opt,name=path,proto3" json:"path,omitempty"`
	CreatedTime   time.Time                                                  `protobuf:"bytes,8,opt,name=created_time,json=createdTime,proto3,stdtime" json:"created_time"`
	UpdatedTime   time.Time                                                  `protobuf:"bytes,9,opt,name=updated_time,json=updatedTime,proto3,stdtime" json:"updated_time"`
}

func (m *LogStreamMetadataDescriptor) Reset()         { *m = LogStreamMetadataDescriptor{} }
func (m *LogStreamMetadataDescriptor) String() string { return proto.CompactTextString(m) }
func (*LogStreamMetadataDescriptor) ProtoMessage()    {}
func (*LogStreamMetadataDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{9}
}
func (m *LogStreamMetadataDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamMetadataDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamMetadataDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamMetadataDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamMetadataDescriptor.Merge(m, src)
}
func (m *LogStreamMetadataDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamMetadataDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamMetadataDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamMetadataDescriptor proto.InternalMessageInfo

func (m *LogStreamMetadataDescriptor) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *LogStreamMetadataDescriptor) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogStreamMetadataDescriptor) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *LogStreamMetadataDescriptor) GetStatus() LogStreamStatus {
	if m != nil {
		return m.Status
	}
	return LogStreamStatusRunning
}

func (m *LogStreamMetadataDescriptor) GetVersion() github_daumkakao_com_varlog_varlog_pkg_types.Version {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *LogStreamMetadataDescriptor) GetHighWatermark() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.HighWatermark
	}
	return 0
}

func (m *LogStreamMetadataDescriptor) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *LogStreamMetadataDescriptor) GetCreatedTime() time.Time {
	if m != nil {
		return m.CreatedTime
	}
	return time.Time{}
}

func (m *LogStreamMetadataDescriptor) GetUpdatedTime() time.Time {
	if m != nil {
		return m.UpdatedTime
	}
	return time.Time{}
}

// FIXME (jun): LogStreamReplicaDescriptor
// - Similar types
// - Ambiguous naming
//
// maybe LogStreamReplica's information
// TODO: LogStreamMetadataDescriptor + LogStreamReplicaDescriptor
type LogStreamReplicaDescriptor struct {
	StorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	LogStreamID   github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID   `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	TopicID       github_daumkakao_com_varlog_varlog_pkg_types.TopicID       `protobuf:"varint,3,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	Address       string                                                     `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *LogStreamReplicaDescriptor) Reset()         { *m = LogStreamReplicaDescriptor{} }
func (m *LogStreamReplicaDescriptor) String() string { return proto.CompactTextString(m) }
func (*LogStreamReplicaDescriptor) ProtoMessage()    {}
func (*LogStreamReplicaDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{10}
}
func (m *LogStreamReplicaDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamReplicaDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamReplicaDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamReplicaDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamReplicaDescriptor.Merge(m, src)
}
func (m *LogStreamReplicaDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamReplicaDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamReplicaDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamReplicaDescriptor proto.InternalMessageInfo

func (m *LogStreamReplicaDescriptor) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *LogStreamReplicaDescriptor) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogStreamReplicaDescriptor) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *LogStreamReplicaDescriptor) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type LogEntryMeta struct {
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	GLSN        github_daumkakao_com_varlog_varlog_pkg_types.GLSN        `protobuf:"varint,3,opt,name=glsn,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"glsn,omitempty"`
	LLSN        github_daumkakao_com_varlog_varlog_pkg_types.LLSN        `protobuf:"varint,4,opt,name=llsn,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LLSN" json:"llsn,omitempty"`
}

func (m *LogEntryMeta) Reset()         { *m = LogEntryMeta{} }
func (m *LogEntryMeta) String() string { return proto.CompactTextString(m) }
func (*LogEntryMeta) ProtoMessage()    {}
func (*LogEntryMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{11}
}
func (m *LogEntryMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogEntryMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogEntryMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogEntryMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEntryMeta.Merge(m, src)
}
func (m *LogEntryMeta) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogEntryMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEntryMeta.DiscardUnknown(m)
}

var xxx_messageInfo_LogEntryMeta proto.InternalMessageInfo

func (m *LogEntryMeta) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *LogEntryMeta) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogEntryMeta) GetGLSN() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.GLSN
	}
	return 0
}

func (m *LogEntryMeta) GetLLSN() github_daumkakao_com_varlog_varlog_pkg_types.LLSN {
	if m != nil {
		return m.LLSN
	}
	return 0
}

type LogEntry struct {
	LogEntryMeta `protobuf:"bytes,1,opt,name=meta,proto3,embedded=meta" json:"meta"`
	Data         []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LogEntry) Reset()         { *m = LogEntry{} }
func (m *LogEntry) String() string { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()    {}
func (*LogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{12}
}
func (m *LogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEntry.Merge(m, src)
}
func (m *LogEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LogEntry proto.InternalMessageInfo

func (m *LogEntry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type CommitContext struct {
	Version            github_daumkakao_com_varlog_varlog_pkg_types.Version `protobuf:"varint,1,opt,name=version,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.Version" json:"version,omitempty"`
	HighWatermark      github_daumkakao_com_varlog_varlog_pkg_types.GLSN    `protobuf:"varint,2,opt,name=high_watermark,json=highWatermark,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"high_watermark,omitempty"`
	CommittedGLSNBegin github_daumkakao_com_varlog_varlog_pkg_types.GLSN    `protobuf:"varint,3,opt,name=committed_glsn_begin,json=committedGlsnBegin,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"committed_glsn_begin,omitempty"`
	CommittedGLSNEnd   github_daumkakao_com_varlog_varlog_pkg_types.GLSN    `protobuf:"varint,4,opt,name=committed_glsn_end,json=committedGlsnEnd,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"committed_glsn_end,omitempty"`
	CommittedLLSNBegin github_daumkakao_com_varlog_varlog_pkg_types.LLSN    `protobuf:"varint,5,opt,name=committed_llsn_begin,json=committedLlsnBegin,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LLSN" json:"committed_llsn_begin,omitempty"`
}

func (m *CommitContext) Reset()         { *m = CommitContext{} }
func (m *CommitContext) String() string { return proto.CompactTextString(m) }
func (*CommitContext) ProtoMessage()    {}
func (*CommitContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{13}
}
func (m *CommitContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitContext.Merge(m, src)
}
func (m *CommitContext) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CommitContext) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitContext.DiscardUnknown(m)
}

var xxx_messageInfo_CommitContext proto.InternalMessageInfo

func (m *CommitContext) GetVersion() github_daumkakao_com_varlog_varlog_pkg_types.Version {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CommitContext) GetHighWatermark() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.HighWatermark
	}
	return 0
}

func (m *CommitContext) GetCommittedGLSNBegin() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.CommittedGLSNBegin
	}
	return 0
}

func (m *CommitContext) GetCommittedGLSNEnd() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.CommittedGLSNEnd
	}
	return 0
}

func (m *CommitContext) GetCommittedLLSNBegin() github_daumkakao_com_varlog_varlog_pkg_types.LLSN {
	if m != nil {
		return m.CommittedLLSNBegin
	}
	return 0
}

func init() {
	proto.RegisterEnum("varlog.varlogpb.StorageNodeStatus", StorageNodeStatus_name, StorageNodeStatus_value)
	proto.RegisterEnum("varlog.varlogpb.LogStreamStatus", LogStreamStatus_name, LogStreamStatus_value)
	proto.RegisterEnum("varlog.varlogpb.TopicStatus", TopicStatus_name, TopicStatus_value)
	proto.RegisterType((*StorageNode)(nil), "varlog.varlogpb.StorageNode")
	proto.RegisterType((*Replica)(nil), "varlog.varlogpb.Replica")
	proto.RegisterType((*StorageDescriptor)(nil), "varlog.varlogpb.StorageDescriptor")
	proto.RegisterType((*StorageNodeDescriptor)(nil), "varlog.varlogpb.StorageNodeDescriptor")
	proto.RegisterType((*ReplicaDescriptor)(nil), "varlog.varlogpb.ReplicaDescriptor")
	proto.RegisterType((*LogStreamDescriptor)(nil), "varlog.varlogpb.LogStreamDescriptor")
	proto.RegisterType((*TopicDescriptor)(nil), "varlog.varlogpb.TopicDescriptor")
	proto.RegisterType((*MetadataDescriptor)(nil), "varlog.varlogpb.MetadataDescriptor")
	proto.RegisterType((*StorageNodeMetadataDescriptor)(nil), "varlog.varlogpb.StorageNodeMetadataDescriptor")
	proto.RegisterType((*LogStreamMetadataDescriptor)(nil), "varlog.varlogpb.LogStreamMetadataDescriptor")
	proto.RegisterType((*LogStreamReplicaDescriptor)(nil), "varlog.varlogpb.LogStreamReplicaDescriptor")
	proto.RegisterType((*LogEntryMeta)(nil), "varlog.varlogpb.LogEntryMeta")
	proto.RegisterType((*LogEntry)(nil), "varlog.varlogpb.LogEntry")
	proto.RegisterType((*CommitContext)(nil), "varlog.varlogpb.CommitContext")
}

func init() { proto.RegisterFile("proto/varlogpb/metadata.proto", fileDescriptor_eb4411772ca3492a) }

var fileDescriptor_eb4411772ca3492a = []byte{
	// 1362 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4d, 0x8f, 0xdb, 0xc4,
	0x1b, 0x8f, 0x13, 0x67, 0x5f, 0x26, 0x9b, 0xee, 0xee, 0xf4, 0x45, 0xf9, 0xe7, 0xdf, 0xc6, 0xd1,
	0x82, 0x50, 0x55, 0x41, 0x42, 0xdf, 0xa0, 0x2a, 0x02, 0xd1, 0x6c, 0xc2, 0x12, 0x35, 0x4d, 0xa9,
	0x93, 0xa5, 0x12, 0x42, 0x44, 0xb3, 0xf1, 0xd4, 0x6b, 0xad, 0x63, 0x5b, 0xf6, 0xa4, 0xdb, 0x1e,
	0x90, 0x90, 0xb8, 0xa0, 0xe5, 0xd2, 0x23, 0x97, 0x15, 0x95, 0x90, 0x7a, 0xe1, 0x13, 0xf0, 0x0d,
	0xca, 0xad, 0x47, 0x4e, 0x41, 0xca, 0x5e, 0x10, 0xdf, 0x80, 0x9e, 0xd0, 0x8c, 0xc7, 0xf1, 0x38,
	0xce, 0x96, 0x26, 0x6c, 0x5b, 0xd4, 0x53, 0x3c, 0x2f, 0xbf, 0xe7, 0xf5, 0xf7, 0xcc, 0x33, 0x13,
	0x70, 0xc6, 0x71, 0x6d, 0x62, 0x97, 0xef, 0x22, 0xd7, 0xb4, 0x75, 0x67, 0xab, 0xdc, 0xc3, 0x04,
	0x69, 0x88, 0xa0, 0x12, 0x9b, 0x87, 0xcb, 0xfe, 0x42, 0x29, 0x58, 0xcf, 0x2b, 0xba, 0x6d, 0xeb,
	0x26, 0x2e, 0xb3, 0xe5, 0xad, 0xfe, 0x9d, 0x32, 0x31, 0x7a, 0xd8, 0x23, 0xa8, 0xe7, 0xf8, 0x88,
	0xfc, 0x3b, 0xba, 0x41, 0xb6, 0xfb, 0x5b, 0xa5, 0xae, 0xdd, 0x2b, 0xeb, 0xb6, 0x6e, 0x87, 0x3b,
	0xe9, 0xc8, 0xd7, 0x46, 0xbf, 0xfc, 0xed, 0x6b, 0x8f, 0x24, 0x90, 0x69, 0x11, 0xdb, 0x45, 0x3a,
	0x6e, 0xda, 0x1a, 0x86, 0xbb, 0x60, 0xd9, 0xf3, 0x87, 0x1d, 0xcb, 0xd6, 0x70, 0xc7, 0xd0, 0x72,
	0x52, 0x51, 0x3a, 0x9b, 0xae, 0xdc, 0x1c, 0x0e, 0x94, 0xac, 0xb0, 0xb3, 0x5e, 0x7d, 0x3a, 0x50,
	0xae, 0x72, 0x65, 0x1a, 0xea, 0xf7, 0x76, 0xd0, 0x0e, 0xb2, 0x99, 0x5a, 0xdf, 0xd8, 0xe0, 0xc7,
	0xd9, 0xd1, 0xcb, 0xe4, 0xbe, 0x83, 0xbd, 0x52, 0x04, 0xad, 0x66, 0x3d, 0x61, 0xa8, 0xc1, 0x1c,
	0x98, 0x47, 0x9a, 0xe6, 0x62, 0xcf, 0xcb, 0x25, 0x8b, 0xd2, 0xd9, 0x45, 0x35, 0x18, 0x5e, 0x95,
	0xff, 0x78, 0xa8, 0x48, 0x6b, 0x3f, 0x27, 0xc1, 0xbc, 0x8a, 0x1d, 0xd3, 0xe8, 0x22, 0x58, 0x07,
	0x4b, 0xa2, 0x91, 0xcc, 0xc2, 0xcc, 0x85, 0xd3, 0xa5, 0xb1, 0x60, 0x89, 0x0a, 0x2b, 0x0b, 0x8f,
	0x07, 0x4a, 0xe2, 0xc9, 0x40, 0x91, 0xd4, 0x8c, 0xa0, 0x18, 0x7e, 0x05, 0x16, 0x88, 0xed, 0x18,
	0x5d, 0xea, 0x68, 0x92, 0x39, 0xba, 0x3e, 0x1c, 0x28, 0xf3, 0x6d, 0x3a, 0xc7, 0x5c, 0xbc, 0x34,
	0x95, 0x8b, 0x1c, 0xa7, 0xce, 0x33, 0xa1, 0x75, 0x0d, 0xda, 0x20, 0x6b, 0xda, 0x7a, 0xc7, 0x23,
	0x2e, 0x46, 0x3d, 0xaa, 0x24, 0xc5, 0x94, 0x5c, 0x1f, 0x0e, 0x94, 0x4c, 0xc3, 0xd6, 0x5b, 0x6c,
	0x9e, 0x29, 0xba, 0x32, 0x95, 0x22, 0x01, 0xab, 0x66, 0xcc, 0xd1, 0x40, 0xe3, 0xd1, 0xba, 0x0d,
	0x56, 0xb9, 0xf3, 0x55, 0xec, 0x75, 0x5d, 0xc3, 0x21, 0xb6, 0x0b, 0x21, 0x90, 0x1d, 0x44, 0xb6,
	0x59, 0xb8, 0x16, 0x55, 0xf6, 0x4d, 0xe7, 0xfa, 0x1e, 0xf6, 0x7d, 0x97, 0x55, 0xf6, 0x0d, 0x4f,
	0x80, 0x34, 0xb1, 0x09, 0x32, 0x99, 0xad, 0xb2, 0xea, 0x0f, 0xb8, 0xe0, 0x3f, 0x25, 0x70, 0x52,
	0x08, 0xab, 0x20, 0xfd, 0x08, 0x93, 0x72, 0x15, 0xcc, 0x79, 0x04, 0x91, 0xbe, 0x4f, 0x85, 0x63,
	0x17, 0xd6, 0x9e, 0x25, 0xa4, 0xc5, 0x76, 0xaa, 0x1c, 0x01, 0xab, 0x60, 0x81, 0x8b, 0xf2, 0x72,
	0xa9, 0x62, 0xea, 0x6c, 0xe6, 0x70, 0x74, 0x68, 0x7c, 0x45, 0x7e, 0x4c, 0x8d, 0x18, 0x21, 0xb9,
	0xb3, 0x8f, 0x24, 0xb0, 0xca, 0x39, 0x27, 0x38, 0xfa, 0xca, 0x4a, 0x24, 0xc8, 0x5f, 0x32, 0xcc,
	0x1f, 0x37, 0x74, 0x90, 0x02, 0xc7, 0x47, 0x8c, 0x10, 0x4c, 0x15, 0xd9, 0x2d, 0xbd, 0x0c, 0x76,
	0x27, 0x5f, 0x2c, 0xbb, 0xe1, 0x95, 0x11, 0x33, 0x52, 0x8c, 0x19, 0xc5, 0x58, 0x6e, 0x47, 0xd0,
	0x38, 0x2f, 0x5c, 0x3f, 0x95, 0x5e, 0x4e, 0x3e, 0x84, 0x17, 0xb1, 0x5c, 0x07, 0xbc, 0x08, 0x90,
	0xf0, 0x7d, 0x20, 0x6f, 0x63, 0xa4, 0xe5, 0xd2, 0x8c, 0xdc, 0x67, 0x26, 0x69, 0xaf, 0x59, 0xc4,
	0xbd, 0x7f, 0x03, 0x13, 0xc4, 0xc0, 0x09, 0x95, 0x01, 0x28, 0x90, 0x20, 0xc3, 0xcc, 0xcd, 0x4d,
	0x01, 0xa4, 0x00, 0x9e, 0xe0, 0x07, 0x49, 0xb0, 0xcc, 0xa2, 0xff, 0x12, 0x93, 0x7b, 0x69, 0xac,
	0x0a, 0xe3, 0xa5, 0xcc, 0x20, 0x63, 0x71, 0x46, 0x20, 0x13, 0x52, 0xc2, 0x2f, 0xc1, 0x74, 0xe5,
	0x63, 0x1a, 0xc6, 0x7f, 0xc5, 0x02, 0x30, 0x62, 0x41, 0x50, 0x9c, 0x3f, 0x26, 0x01, 0xbc, 0xc1,
	0xbb, 0xa5, 0x10, 0x95, 0x37, 0x40, 0x16, 0x39, 0x8e, 0x69, 0x60, 0xad, 0x63, 0x58, 0x1a, 0xbe,
	0xc7, 0x42, 0x23, 0xab, 0x4b, 0x7c, 0xb2, 0x4e, 0xe7, 0xe0, 0x2d, 0x90, 0x15, 0x4b, 0x98, 0x7a,
	0x48, 0x19, 0xf1, 0xd6, 0xb3, 0xce, 0x99, 0x18, 0x2b, 0x96, 0x84, 0xea, 0xf4, 0xe0, 0xf5, 0xb8,
	0xdf, 0x99, 0x0b, 0x6f, 0x1e, 0x4e, 0xcf, 0x98, 0x38, 0xc1, 0x43, 0xf8, 0x11, 0x98, 0x63, 0x59,
	0x08, 0xa8, 0x5a, 0x9c, 0x1c, 0xfa, 0x98, 0x0c, 0x8e, 0xe2, 0x11, 0xfa, 0x25, 0x05, 0xce, 0x08,
	0x0e, 0x4c, 0x08, 0xd6, 0x1d, 0x00, 0xba, 0x66, 0xdf, 0x23, 0xd8, 0x0d, 0x48, 0x94, 0xad, 0x6c,
	0x0c, 0x07, 0xca, 0xe2, 0xba, 0x3f, 0xcb, 0x68, 0xf4, 0xde, 0x54, 0x49, 0x1b, 0x21, 0xd5, 0x45,
	0x2e, 0xba, 0xae, 0xc5, 0x7a, 0x43, 0x92, 0x55, 0xc1, 0x73, 0x86, 0x3b, 0xda, 0x1b, 0x5a, 0x93,
	0xe2, 0xfc, 0xf6, 0xe1, 0x71, 0x8e, 0x7b, 0xcd, 0xcb, 0x4b, 0x8c, 0xf7, 0x06, 0x58, 0xea, 0xba,
	0x18, 0x11, 0xac, 0x75, 0xe8, 0x7d, 0x2a, 0x27, 0x33, 0xfb, 0xf2, 0x25, 0xff, 0xb2, 0x55, 0x0a,
	0xae, 0x50, 0xa5, 0x76, 0x70, 0xd9, 0xf2, 0x3b, 0xd7, 0x83, 0xdf, 0x69, 0xe7, 0xe2, 0x48, 0xba,
	0x46, 0x05, 0xf5, 0x1d, 0x2d, 0x14, 0x94, 0x9e, 0x46, 0x10, 0x47, 0xd2, 0xb5, 0xb5, 0xbf, 0xd2,
	0xe0, 0xff, 0xcf, 0xf0, 0xe1, 0xd5, 0x35, 0xa1, 0x97, 0x7e, 0xe4, 0x8b, 0xc7, 0x5c, 0xea, 0x05,
	0x1c, 0x73, 0x61, 0x4b, 0x91, 0xa7, 0x6c, 0x29, 0x2a, 0x98, 0xbf, 0x8b, 0x5d, 0xcf, 0xb0, 0x2d,
	0x96, 0x67, 0xb9, 0x72, 0x65, 0x6a, 0x6b, 0x3e, 0xf7, 0xf1, 0x6a, 0x20, 0x08, 0x7e, 0x09, 0x8e,
	0x6d, 0x1b, 0xfa, 0x76, 0x67, 0x17, 0x11, 0xec, 0xf6, 0x90, 0xbb, 0xc3, 0x3a, 0x86, 0x5c, 0xb9,
	0xfc, 0x74, 0xa0, 0x9c, 0x9f, 0x4a, 0xf4, 0x46, 0xa3, 0xd5, 0x54, 0xb3, 0x54, 0xd8, 0xed, 0x40,
	0xd6, 0xe8, 0x06, 0x31, 0x2f, 0xdc, 0x00, 0xc7, 0xb9, 0xbf, 0x70, 0x54, 0xdc, 0x5f, 0x9c, 0x95,
	0xfb, 0xdf, 0xa4, 0x40, 0x7e, 0x14, 0xf3, 0xff, 0xd0, 0xfd, 0xeb, 0xb5, 0xa3, 0xbe, 0xf0, 0xe6,
	0x92, 0x23, 0x6f, 0xae, 0xb5, 0xef, 0x53, 0x60, 0x49, 0xbc, 0x92, 0xbc, 0x7e, 0x37, 0xc9, 0x5b,
	0x40, 0xd6, 0x4d, 0xcf, 0xf2, 0xdf, 0x38, 0x95, 0x0f, 0x87, 0x03, 0x45, 0xa6, 0x15, 0x33, 0x5b,
	0x99, 0x31, 0x51, 0x54, 0xa4, 0x49, 0x45, 0xca, 0xa1, 0xc8, 0xc6, 0x2c, 0x22, 0x1b, 0x4c, 0x24,
	0x15, 0xc5, 0x1b, 0x39, 0x02, 0x0b, 0x41, 0x32, 0xe0, 0x07, 0x40, 0xee, 0x61, 0x82, 0xf8, 0xf3,
	0xea, 0x1f, 0x2e, 0x92, 0xe1, 0xfb, 0x8a, 0x81, 0x68, 0xfd, 0xd3, 0x3e, 0xc2, 0x82, 0xbb, 0xa4,
	0xb2, 0x6f, 0xae, 0xe2, 0x57, 0x19, 0x64, 0xd7, 0xed, 0x5e, 0xcf, 0x20, 0xeb, 0xb6, 0x45, 0xf0,
	0x3d, 0x22, 0x9e, 0x6e, 0xd2, 0x51, 0x9d, 0x6e, 0xbd, 0xd8, 0xe9, 0xc6, 0xde, 0x9d, 0x95, 0x4f,
	0x68, 0xe5, 0x7e, 0x2a, 0x1e, 0x55, 0x47, 0x72, 0xdc, 0x7d, 0x0d, 0x4e, 0x74, 0x99, 0x4f, 0xf4,
	0x4c, 0xa2, 0x29, 0xea, 0x6c, 0x61, 0xdd, 0x08, 0x72, 0x4e, 0xb9, 0x05, 0xd7, 0x83, 0x75, 0x8a,
	0xaf, 0xd0, 0xd5, 0xd9, 0x34, 0xc3, 0x91, 0xa2, 0x0d, 0xd3, 0xb3, 0x98, 0x20, 0xb8, 0x0b, 0xe0,
	0x98, 0x7a, 0x6c, 0x69, 0x9c, 0x1d, 0xf5, 0xe1, 0x40, 0x59, 0x89, 0x28, 0xaf, 0x59, 0xda, 0x6c,
	0xaa, 0x57, 0x22, 0xaa, 0x6b, 0x96, 0x16, 0xf5, 0xdb, 0x0c, 0xfd, 0x4e, 0x4f, 0xf0, 0xbb, 0x31,
	0xb3, 0xdf, 0x8d, 0xa8, 0xdf, 0x8d, 0xc0, 0xef, 0x73, 0xdf, 0x4a, 0xa3, 0x7f, 0x1f, 0xc2, 0x07,
	0x3a, 0xbc, 0x08, 0x56, 0x5b, 0xcd, 0x4e, 0xab, 0x7d, 0xad, 0xbd, 0xd9, 0xea, 0xa8, 0x9b, 0xcd,
	0x66, 0xbd, 0xb9, 0xb1, 0x92, 0xc8, 0x9f, 0xde, 0xdb, 0x2f, 0xe6, 0xe2, 0xcf, 0xf9, 0xbe, 0x65,
	0x19, 0x96, 0x1e, 0x05, 0x55, 0x6b, 0x8d, 0x5a, 0xbb, 0x56, 0x5d, 0x91, 0x0e, 0x01, 0x55, 0xb1,
	0x89, 0x09, 0xd6, 0xf2, 0xf2, 0x77, 0x3f, 0x15, 0x12, 0xe7, 0x7e, 0x48, 0x82, 0xe5, 0xb1, 0xce,
	0x0d, 0xcf, 0x83, 0xd5, 0x46, 0x2b, 0x6e, 0x43, 0x7e, 0x6f, 0xbf, 0x78, 0x6a, 0xbc, 0xcb, 0x73,
	0x0b, 0x22, 0x90, 0x56, 0xed, 0x5a, 0x83, 0x42, 0xa4, 0x89, 0x90, 0x16, 0x46, 0x26, 0x85, 0x94,
	0xc1, 0x4a, 0x14, 0x52, 0xab, 0xae, 0x24, 0xf3, 0xff, 0xdb, 0xdb, 0x2f, 0x9e, 0x9c, 0x80, 0xc0,
	0x5a, 0x54, 0x47, 0xe0, 0x65, 0x6a, 0xa2, 0x0e, 0xee, 0x23, 0xbc, 0x0c, 0x8e, 0x87, 0x90, 0xcd,
	0x66, 0x60, 0x98, 0xec, 0x87, 0x66, 0x0c, 0xb4, 0x69, 0x79, 0xbe, 0x69, 0x3c, 0x34, 0xbb, 0x20,
	0x23, 0x3c, 0xdd, 0xe0, 0xbb, 0xe0, 0x44, 0xfb, 0xe6, 0x67, 0xf5, 0xf5, 0x78, 0x60, 0x4e, 0xed,
	0xed, 0x17, 0xa1, 0xf8, 0xca, 0xe3, 0x41, 0x19, 0x47, 0x84, 0x99, 0x19, 0x47, 0x44, 0x72, 0x52,
	0xb9, 0xfe, 0x78, 0x58, 0x90, 0x9e, 0x0c, 0x0b, 0xd2, 0x83, 0x83, 0x42, 0xe2, 0xe1, 0x41, 0x41,
	0x7a, 0x72, 0x50, 0x48, 0xfc, 0x76, 0x50, 0x48, 0x7c, 0xf1, 0x5c, 0xd4, 0x8b, 0xfc, 0x55, 0xba,
	0x35, 0xc7, 0xc6, 0x17, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0xb4, 0xcf, 0x71, 0x72, 0x43, 0x15,
	0x00, 0x00,
}

func (this *StorageNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageNode)
	if !ok {
		that2, ok := that.(StorageNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageNodeID != that1.StorageNodeID {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	return true
}
func (this *Replica) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Replica)
	if !ok {
		that2, ok := that.(Replica)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageNode.Equal(&that1.StorageNode) {
		return false
	}
	if this.TopicID != that1.TopicID {
		return false
	}
	if this.LogStreamID != that1.LogStreamID {
		return false
	}
	return true
}
func (this *StorageDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDescriptor)
	if !ok {
		that2, ok := that.(StorageDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Used != that1.Used {
		return false
	}
	if this.Total != that1.Total {
		return false
	}
	return true
}
func (this *StorageNodeDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageNodeDescriptor)
	if !ok {
		that2, ok := that.(StorageNodeDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageNode.Equal(&that1.StorageNode) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Storages) != len(that1.Storages) {
		return false
	}
	for i := range this.Storages {
		if !this.Storages[i].Equal(that1.Storages[i]) {
			return false
		}
	}
	return true
}
func (this *ReplicaDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplicaDescriptor)
	if !ok {
		that2, ok := that.(ReplicaDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageNodeID != that1.StorageNodeID {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *LogStreamDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogStreamDescriptor)
	if !ok {
		that2, ok := that.(LogStreamDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TopicID != that1.TopicID {
		return false
	}
	if this.LogStreamID != that1.LogStreamID {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Replicas) != len(that1.Replicas) {
		return false
	}
	for i := range this.Replicas {
		if !this.Replicas[i].Equal(that1.Replicas[i]) {
			return false
		}
	}
	if !this.Head.Equal(&that1.Head) {
		return false
	}
	if !this.Tail.Equal(&that1.Tail) {
		return false
	}
	return true
}
func (this *TopicDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicDescriptor)
	if !ok {
		that2, ok := that.(TopicDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TopicID != that1.TopicID {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.LogStreams) != len(that1.LogStreams) {
		return false
	}
	for i := range this.LogStreams {
		if this.LogStreams[i] != that1.LogStreams[i] {
			return false
		}
	}
	return true
}
func (this *MetadataDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetadataDescriptor)
	if !ok {
		that2, ok := that.(MetadataDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppliedIndex != that1.AppliedIndex {
		return false
	}
	if len(this.StorageNodes) != len(that1.StorageNodes) {
		return false
	}
	for i := range this.StorageNodes {
		if !this.StorageNodes[i].Equal(that1.StorageNodes[i]) {
			return false
		}
	}
	if len(this.LogStreams) != len(that1.LogStreams) {
		return false
	}
	for i := range this.LogStreams {
		if !this.LogStreams[i].Equal(that1.LogStreams[i]) {
			return false
		}
	}
	if len(this.Topics) != len(that1.Topics) {
		return false
	}
	for i := range this.Topics {
		if !this.Topics[i].Equal(that1.Topics[i]) {
			return false
		}
	}
	return true
}
func (this *LogEntryMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogEntryMeta)
	if !ok {
		that2, ok := that.(LogEntryMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TopicID != that1.TopicID {
		return false
	}
	if this.LogStreamID != that1.LogStreamID {
		return false
	}
	if this.GLSN != that1.GLSN {
		return false
	}
	if this.LLSN != that1.LLSN {
		return false
	}
	return true
}
func (this *LogEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogEntry)
	if !ok {
		that2, ok := that.(LogEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogEntryMeta.Equal(&that1.LogEntryMeta) {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (m *StorageNode) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Replica) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replica) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Replica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x18
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StorageDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.Used != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageNodeDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageNodeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageNodeDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Storages) > 0 {
		for iNdEx := len(m.Storages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Storages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReplicaDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogStreamDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tail.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LogStreams) > 0 {
		dAtA6 := make([]byte, len(m.LogStreams)*10)
		var j5 int
		for _, num1 := range m.LogStreams {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintMetadata(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetadataDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Topics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.StorageNodes) > 0 {
		for iNdEx := len(m.StorageNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StorageNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AppliedIndex != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.AppliedIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StorageNodeMetadataDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageNodeMetadataDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageNodeMetadataDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdatedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedTime):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintMetadata(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x2a
	n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedTime):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintMetadata(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x22
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.StorageNode != nil {
		{
			size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ClusterID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogStreamMetadataDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamMetadataDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamMetadataDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n10, err10 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdatedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedTime):])
	if err10 != nil {
		return 0, err10
	}
	i -= n10
	i = encodeVarintMetadata(dAtA, i, uint64(n10))
	i--
	dAtA[i] = 0x4a
	n11, err11 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedTime):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintMetadata(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x42
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x3a
	}
	if m.HighWatermark != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.HighWatermark))
		i--
		dAtA[i] = 0x30
	}
	if m.Version != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x28
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x18
	}
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogStreamReplicaDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamReplicaDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamReplicaDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x22
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x18
	}
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogEntryMeta) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogEntryMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntryMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LLSN != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LLSN))
		i--
		dAtA[i] = 0x20
	}
	if m.GLSN != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.GLSN))
		i--
		dAtA[i] = 0x18
	}
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.LogEntryMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CommitContext) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommittedLLSNBegin != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.CommittedLLSNBegin))
		i--
		dAtA[i] = 0x28
	}
	if m.CommittedGLSNEnd != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.CommittedGLSNEnd))
		i--
		dAtA[i] = 0x20
	}
	if m.CommittedGLSNBegin != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.CommittedGLSNBegin))
		i--
		dAtA[i] = 0x18
	}
	if m.HighWatermark != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.HighWatermark))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetadata(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetadata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StorageNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *Replica) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StorageNode.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	return n
}

func (m *StorageDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Used != 0 {
		n += 1 + sovMetadata(uint64(m.Used))
	}
	if m.Total != 0 {
		n += 1 + sovMetadata(uint64(m.Total))
	}
	return n
}

func (m *StorageNodeDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StorageNode.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if len(m.Storages) > 0 {
		for _, e := range m.Storages {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	return n
}

func (m *ReplicaDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *LogStreamDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	l = m.Head.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	l = m.Tail.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	return n
}

func (m *TopicDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if len(m.LogStreams) > 0 {
		l = 0
		for _, e := range m.LogStreams {
			l += sovMetadata(uint64(e))
		}
		n += 1 + sovMetadata(uint64(l)) + l
	}
	return n
}

func (m *MetadataDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppliedIndex != 0 {
		n += 1 + sovMetadata(uint64(m.AppliedIndex))
	}
	if len(m.StorageNodes) > 0 {
		for _, e := range m.StorageNodes {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if len(m.Topics) > 0 {
		for _, e := range m.Topics {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	return n
}

func (m *StorageNodeMetadataDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovMetadata(uint64(m.ClusterID))
	}
	if m.StorageNode != nil {
		l = m.StorageNode.ProtoSize()
		n += 1 + l + sovMetadata(uint64(l))
	}
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedTime)
	n += 1 + l + sovMetadata(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedTime)
	n += 1 + l + sovMetadata(uint64(l))
	return n
}

func (m *LogStreamMetadataDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if m.Version != 0 {
		n += 1 + sovMetadata(uint64(m.Version))
	}
	if m.HighWatermark != 0 {
		n += 1 + sovMetadata(uint64(m.HighWatermark))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedTime)
	n += 1 + l + sovMetadata(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedTime)
	n += 1 + l + sovMetadata(uint64(l))
	return n
}

func (m *LogStreamReplicaDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *LogEntryMeta) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	if m.GLSN != 0 {
		n += 1 + sovMetadata(uint64(m.GLSN))
	}
	if m.LLSN != 0 {
		n += 1 + sovMetadata(uint64(m.LLSN))
	}
	return n
}

func (m *LogEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LogEntryMeta.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *CommitContext) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovMetadata(uint64(m.Version))
	}
	if m.HighWatermark != 0 {
		n += 1 + sovMetadata(uint64(m.HighWatermark))
	}
	if m.CommittedGLSNBegin != 0 {
		n += 1 + sovMetadata(uint64(m.CommittedGLSNBegin))
	}
	if m.CommittedGLSNEnd != 0 {
		n += 1 + sovMetadata(uint64(m.CommittedGLSNEnd))
	}
	if m.CommittedLLSNBegin != 0 {
		n += 1 + sovMetadata(uint64(m.CommittedLLSNBegin))
	}
	return n
}

func sovMetadata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetadata(x uint64) (n int) {
	return sovMetadata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StorageNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageNodeDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageNodeDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageNodeDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= StorageNodeStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storages = append(m.Storages, &StorageDescriptor{})
			if err := m.Storages[len(m.Storages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogStreamDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LogStreamStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &ReplicaDescriptor{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TopicStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LogStreams = append(m.LogStreams, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMetadata
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMetadata
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LogStreams) == 0 {
					m.LogStreams = make([]github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LogStreams = append(m.LogStreams, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedIndex", wireType)
			}
			m.AppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppliedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageNodes = append(m.StorageNodes, &StorageNodeDescriptor{})
			if err := m.StorageNodes[len(m.StorageNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, &LogStreamDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, &TopicDescriptor{})
			if err := m.Topics[len(m.Topics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageNodeMetadataDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageNodeMetadataDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageNodeMetadataDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_daumkakao_com_varlog_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageNode == nil {
				m.StorageNode = &StorageNodeDescriptor{}
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, LogStreamMetadataDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogStreamMetadataDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamMetadataDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamMetadataDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LogStreamStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= github_daumkakao_com_varlog_varlog_pkg_types.Version(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWatermark", wireType)
			}
			m.HighWatermark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighWatermark |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogStreamReplicaDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamReplicaDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamReplicaDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntryMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntryMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntryMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GLSN", wireType)
			}
			m.GLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GLSN |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLSN", wireType)
			}
			m.LLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LLSN |= github_daumkakao_com_varlog_varlog_pkg_types.LLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogEntryMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LogEntryMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= github_daumkakao_com_varlog_varlog_pkg_types.Version(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWatermark", wireType)
			}
			m.HighWatermark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighWatermark |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedGLSNBegin", wireType)
			}
			m.CommittedGLSNBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedGLSNBegin |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedGLSNEnd", wireType)
			}
			m.CommittedGLSNEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedGLSNEnd |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedLLSNBegin", wireType)
			}
			m.CommittedLLSNBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedLLSNBegin |= github_daumkakao_com_varlog_varlog_pkg_types.LLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetadata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetadata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetadata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetadata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetadata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetadata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetadata = fmt.Errorf("proto: unexpected end of group")
)
