// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: metadata.proto

package varlogpb

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	github_daumkakao_com_varlog_varlog_pkg_varlog_types "github.daumkakao.com/varlog/varlog/pkg/varlog/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StorageNodeStatus int32

const (
	StorageNodeStatusRunning StorageNodeStatus = 0
	StorageNodeStatusDeleted StorageNodeStatus = 1
)

var StorageNodeStatus_name = map[int32]string{
	0: "SN_STATUS_RUNNING",
	1: "SN_STATUS_DELETED",
}

var StorageNodeStatus_value = map[string]int32{
	"SN_STATUS_RUNNING": 0,
	"SN_STATUS_DELETED": 1,
}

func (x StorageNodeStatus) String() string {
	return proto.EnumName(StorageNodeStatus_name, int32(x))
}

func (StorageNodeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{0}
}

type LogStreamStatus int32

const (
	LogStreamStatusRunning   LogStreamStatus = 0
	LogStreamStatusSealing   LogStreamStatus = 1
	LogStreamStatusSealed    LogStreamStatus = 2
	LogStreamStatusDeleted   LogStreamStatus = 3
	LogStreamStatusUnsealing LogStreamStatus = 4
)

var LogStreamStatus_name = map[int32]string{
	0: "LS_STATUS_RUNNING",
	1: "LS_STATUS_SEALING",
	2: "LS_STATUS_SEALED",
	3: "LS_STATUS_DELETED",
	4: "LS_STATUS_UNSEALING",
}

var LogStreamStatus_value = map[string]int32{
	"LS_STATUS_RUNNING":   0,
	"LS_STATUS_SEALING":   1,
	"LS_STATUS_SEALED":    2,
	"LS_STATUS_DELETED":   3,
	"LS_STATUS_UNSEALING": 4,
}

func (x LogStreamStatus) String() string {
	return proto.EnumName(LogStreamStatus_name, int32(x))
}

func (LogStreamStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{1}
}

type StorageDescriptor struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Used                 uint64   `protobuf:"varint,2,opt,name=used,proto3" json:"used,omitempty"`
	Total                uint64   `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StorageDescriptor) Reset()         { *m = StorageDescriptor{} }
func (m *StorageDescriptor) String() string { return proto.CompactTextString(m) }
func (*StorageDescriptor) ProtoMessage()    {}
func (*StorageDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{0}
}
func (m *StorageDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDescriptor.Merge(m, src)
}
func (m *StorageDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDescriptor proto.InternalMessageInfo

func (m *StorageDescriptor) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *StorageDescriptor) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *StorageDescriptor) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

type StorageNodeDescriptor struct {
	StorageNodeID        github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/varlog/types.StorageNodeID" json:"storage_node_id,omitempty"`
	Address              string                                                            `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Status               StorageNodeStatus                                                 `protobuf:"varint,3,opt,name=status,proto3,enum=varlog.varlogpb.StorageNodeStatus" json:"status,omitempty"`
	Storages             []*StorageDescriptor                                              `protobuf:"bytes,4,rep,name=storages,proto3" json:"storages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                          `json:"-"`
	XXX_unrecognized     []byte                                                            `json:"-"`
	XXX_sizecache        int32                                                             `json:"-"`
}

func (m *StorageNodeDescriptor) Reset()         { *m = StorageNodeDescriptor{} }
func (m *StorageNodeDescriptor) String() string { return proto.CompactTextString(m) }
func (*StorageNodeDescriptor) ProtoMessage()    {}
func (*StorageNodeDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{1}
}
func (m *StorageNodeDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageNodeDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageNodeDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageNodeDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageNodeDescriptor.Merge(m, src)
}
func (m *StorageNodeDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageNodeDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageNodeDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StorageNodeDescriptor proto.InternalMessageInfo

func (m *StorageNodeDescriptor) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *StorageNodeDescriptor) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *StorageNodeDescriptor) GetStatus() StorageNodeStatus {
	if m != nil {
		return m.Status
	}
	return StorageNodeStatusRunning
}

func (m *StorageNodeDescriptor) GetStorages() []*StorageDescriptor {
	if m != nil {
		return m.Storages
	}
	return nil
}

type ReplicaDescriptor struct {
	StorageNodeID        github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/varlog/types.StorageNodeID" json:"storage_node_id,omitempty"`
	Path                 string                                                            `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                          `json:"-"`
	XXX_unrecognized     []byte                                                            `json:"-"`
	XXX_sizecache        int32                                                             `json:"-"`
}

func (m *ReplicaDescriptor) Reset()         { *m = ReplicaDescriptor{} }
func (m *ReplicaDescriptor) String() string { return proto.CompactTextString(m) }
func (*ReplicaDescriptor) ProtoMessage()    {}
func (*ReplicaDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{2}
}
func (m *ReplicaDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicaDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaDescriptor.Merge(m, src)
}
func (m *ReplicaDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReplicaDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaDescriptor proto.InternalMessageInfo

func (m *ReplicaDescriptor) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *ReplicaDescriptor) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type LogStreamDescriptor struct {
	LogStreamID          github_daumkakao_com_varlog_varlog_pkg_varlog_types.LogStreamID `protobuf:"varint,1,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/varlog/types.LogStreamID" json:"log_stream_id,omitempty"`
	Status               LogStreamStatus                                                 `protobuf:"varint,2,opt,name=status,proto3,enum=varlog.varlogpb.LogStreamStatus" json:"status,omitempty"`
	Replicas             []*ReplicaDescriptor                                            `protobuf:"bytes,3,rep,name=replicas,proto3" json:"replicas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                        `json:"-"`
	XXX_unrecognized     []byte                                                          `json:"-"`
	XXX_sizecache        int32                                                           `json:"-"`
}

func (m *LogStreamDescriptor) Reset()         { *m = LogStreamDescriptor{} }
func (m *LogStreamDescriptor) String() string { return proto.CompactTextString(m) }
func (*LogStreamDescriptor) ProtoMessage()    {}
func (*LogStreamDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{3}
}
func (m *LogStreamDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamDescriptor.Merge(m, src)
}
func (m *LogStreamDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamDescriptor proto.InternalMessageInfo

func (m *LogStreamDescriptor) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_varlog_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogStreamDescriptor) GetStatus() LogStreamStatus {
	if m != nil {
		return m.Status
	}
	return LogStreamStatusRunning
}

func (m *LogStreamDescriptor) GetReplicas() []*ReplicaDescriptor {
	if m != nil {
		return m.Replicas
	}
	return nil
}

type MetadataDescriptor struct {
	AppliedIndex         uint64                   `protobuf:"varint,1,opt,name=applied_index,json=appliedIndex,proto3" json:"applied_index,omitempty"`
	StorageNodes         []*StorageNodeDescriptor `protobuf:"bytes,2,rep,name=storage_nodes,json=storageNodes,proto3" json:"storage_nodes,omitempty"`
	LogStreams           []*LogStreamDescriptor   `protobuf:"bytes,3,rep,name=log_streams,json=logStreams,proto3" json:"log_streams,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *MetadataDescriptor) Reset()         { *m = MetadataDescriptor{} }
func (m *MetadataDescriptor) String() string { return proto.CompactTextString(m) }
func (*MetadataDescriptor) ProtoMessage()    {}
func (*MetadataDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{4}
}
func (m *MetadataDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataDescriptor.Merge(m, src)
}
func (m *MetadataDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MetadataDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataDescriptor proto.InternalMessageInfo

func (m *MetadataDescriptor) GetAppliedIndex() uint64 {
	if m != nil {
		return m.AppliedIndex
	}
	return 0
}

func (m *MetadataDescriptor) GetStorageNodes() []*StorageNodeDescriptor {
	if m != nil {
		return m.StorageNodes
	}
	return nil
}

func (m *MetadataDescriptor) GetLogStreams() []*LogStreamDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

// StorageNodeMetadataDescriptor represents metadata of stroage node.
type StorageNodeMetadataDescriptor struct {
	// ClusterID is the identifier of the cluster that the storage node belongs
	// to.
	ClusterID github_daumkakao_com_varlog_varlog_pkg_varlog_types.ClusterID `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/varlog/types.ClusterID" json:"cluster_id,omitempty"`
	// StorageNode is detailed information about the storage node.
	StorageNode          *StorageNodeDescriptor        `protobuf:"bytes,2,opt,name=storage_node,json=storageNode,proto3" json:"storage_node,omitempty"`
	LogStreams           []LogStreamMetadataDescriptor `protobuf:"bytes,3,rep,name=log_streams,json=logStreams,proto3" json:"log_streams"`
	CreatedTime          time.Time                     `protobuf:"bytes,4,opt,name=created_time,json=createdTime,proto3,stdtime" json:"created_time"`
	UpdatedTime          time.Time                     `protobuf:"bytes,5,opt,name=updated_time,json=updatedTime,proto3,stdtime" json:"updated_time"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *StorageNodeMetadataDescriptor) Reset()         { *m = StorageNodeMetadataDescriptor{} }
func (m *StorageNodeMetadataDescriptor) String() string { return proto.CompactTextString(m) }
func (*StorageNodeMetadataDescriptor) ProtoMessage()    {}
func (*StorageNodeMetadataDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{5}
}
func (m *StorageNodeMetadataDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageNodeMetadataDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageNodeMetadataDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageNodeMetadataDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageNodeMetadataDescriptor.Merge(m, src)
}
func (m *StorageNodeMetadataDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageNodeMetadataDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageNodeMetadataDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StorageNodeMetadataDescriptor proto.InternalMessageInfo

func (m *StorageNodeMetadataDescriptor) GetClusterID() github_daumkakao_com_varlog_varlog_pkg_varlog_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *StorageNodeMetadataDescriptor) GetStorageNode() *StorageNodeDescriptor {
	if m != nil {
		return m.StorageNode
	}
	return nil
}

func (m *StorageNodeMetadataDescriptor) GetLogStreams() []LogStreamMetadataDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

func (m *StorageNodeMetadataDescriptor) GetCreatedTime() time.Time {
	if m != nil {
		return m.CreatedTime
	}
	return time.Time{}
}

func (m *StorageNodeMetadataDescriptor) GetUpdatedTime() time.Time {
	if m != nil {
		return m.UpdatedTime
	}
	return time.Time{}
}

type LogStreamMetadataDescriptor struct {
	StorageNodeID        github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/varlog/types.StorageNodeID" json:"storage_node_id,omitempty"`
	LogStreamID          github_daumkakao_com_varlog_varlog_pkg_varlog_types.LogStreamID   `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/varlog/types.LogStreamID" json:"log_stream_id,omitempty"`
	Status               LogStreamStatus                                                   `protobuf:"varint,3,opt,name=status,proto3,enum=varlog.varlogpb.LogStreamStatus" json:"status,omitempty"`
	HighWatermark        github_daumkakao_com_varlog_varlog_pkg_varlog_types.GLSN          `protobuf:"varint,4,opt,name=high_watermark,json=highWatermark,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/varlog/types.GLSN" json:"high_watermark,omitempty"`
	Path                 string                                                            `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
	CreatedTime          time.Time                                                         `protobuf:"bytes,6,opt,name=created_time,json=createdTime,proto3,stdtime" json:"created_time"`
	UpdatedTime          time.Time                                                         `protobuf:"bytes,7,opt,name=updated_time,json=updatedTime,proto3,stdtime" json:"updated_time"`
	XXX_NoUnkeyedLiteral struct{}                                                          `json:"-"`
	XXX_unrecognized     []byte                                                            `json:"-"`
	XXX_sizecache        int32                                                             `json:"-"`
}

func (m *LogStreamMetadataDescriptor) Reset()         { *m = LogStreamMetadataDescriptor{} }
func (m *LogStreamMetadataDescriptor) String() string { return proto.CompactTextString(m) }
func (*LogStreamMetadataDescriptor) ProtoMessage()    {}
func (*LogStreamMetadataDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{6}
}
func (m *LogStreamMetadataDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamMetadataDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamMetadataDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamMetadataDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamMetadataDescriptor.Merge(m, src)
}
func (m *LogStreamMetadataDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamMetadataDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamMetadataDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamMetadataDescriptor proto.InternalMessageInfo

func (m *LogStreamMetadataDescriptor) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *LogStreamMetadataDescriptor) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_varlog_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogStreamMetadataDescriptor) GetStatus() LogStreamStatus {
	if m != nil {
		return m.Status
	}
	return LogStreamStatusRunning
}

func (m *LogStreamMetadataDescriptor) GetHighWatermark() github_daumkakao_com_varlog_varlog_pkg_varlog_types.GLSN {
	if m != nil {
		return m.HighWatermark
	}
	return 0
}

func (m *LogStreamMetadataDescriptor) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *LogStreamMetadataDescriptor) GetCreatedTime() time.Time {
	if m != nil {
		return m.CreatedTime
	}
	return time.Time{}
}

func (m *LogStreamMetadataDescriptor) GetUpdatedTime() time.Time {
	if m != nil {
		return m.UpdatedTime
	}
	return time.Time{}
}

type LogStreamReplicaDescriptor struct {
	StorageNodeID        github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/varlog/types.StorageNodeID" json:"storage_node_id,omitempty"`
	LogStreamID          github_daumkakao_com_varlog_varlog_pkg_varlog_types.LogStreamID   `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/varlog/types.LogStreamID" json:"log_stream_id,omitempty"`
	Address              string                                                            `protobuf:"bytes,3,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                          `json:"-"`
	XXX_unrecognized     []byte                                                            `json:"-"`
	XXX_sizecache        int32                                                             `json:"-"`
}

func (m *LogStreamReplicaDescriptor) Reset()         { *m = LogStreamReplicaDescriptor{} }
func (m *LogStreamReplicaDescriptor) String() string { return proto.CompactTextString(m) }
func (*LogStreamReplicaDescriptor) ProtoMessage()    {}
func (*LogStreamReplicaDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_56d9f74966f40d04, []int{7}
}
func (m *LogStreamReplicaDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamReplicaDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamReplicaDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamReplicaDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamReplicaDescriptor.Merge(m, src)
}
func (m *LogStreamReplicaDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamReplicaDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamReplicaDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamReplicaDescriptor proto.InternalMessageInfo

func (m *LogStreamReplicaDescriptor) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *LogStreamReplicaDescriptor) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_varlog_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogStreamReplicaDescriptor) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func init() {
	proto.RegisterEnum("varlog.varlogpb.StorageNodeStatus", StorageNodeStatus_name, StorageNodeStatus_value)
	proto.RegisterEnum("varlog.varlogpb.LogStreamStatus", LogStreamStatus_name, LogStreamStatus_value)
	proto.RegisterType((*StorageDescriptor)(nil), "varlog.varlogpb.StorageDescriptor")
	proto.RegisterType((*StorageNodeDescriptor)(nil), "varlog.varlogpb.StorageNodeDescriptor")
	proto.RegisterType((*ReplicaDescriptor)(nil), "varlog.varlogpb.ReplicaDescriptor")
	proto.RegisterType((*LogStreamDescriptor)(nil), "varlog.varlogpb.LogStreamDescriptor")
	proto.RegisterType((*MetadataDescriptor)(nil), "varlog.varlogpb.MetadataDescriptor")
	proto.RegisterType((*StorageNodeMetadataDescriptor)(nil), "varlog.varlogpb.StorageNodeMetadataDescriptor")
	proto.RegisterType((*LogStreamMetadataDescriptor)(nil), "varlog.varlogpb.LogStreamMetadataDescriptor")
	proto.RegisterType((*LogStreamReplicaDescriptor)(nil), "varlog.varlogpb.LogStreamReplicaDescriptor")
}

func init() { proto.RegisterFile("metadata.proto", fileDescriptor_56d9f74966f40d04) }

var fileDescriptor_56d9f74966f40d04 = []byte{
	// 913 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0x4d, 0x6f, 0xdc, 0x44,
	0x18, 0x8e, 0xbd, 0x4e, 0xda, 0xcc, 0xc6, 0xf9, 0x98, 0x52, 0xb4, 0x18, 0x88, 0x57, 0x01, 0xa1,
	0xa8, 0x02, 0x47, 0xa5, 0x42, 0xaa, 0x2a, 0xa1, 0x2a, 0xcb, 0xae, 0xc2, 0x8a, 0xad, 0x25, 0xec,
	0x84, 0x4a, 0x5c, 0xac, 0xc9, 0xce, 0xe0, 0xb5, 0x62, 0xef, 0x58, 0xf6, 0xb8, 0xc0, 0x85, 0x0b,
	0x17, 0x94, 0x13, 0x12, 0x17, 0x2e, 0x91, 0x2a, 0x71, 0x86, 0x3b, 0x37, 0x8e, 0x3d, 0xf2, 0x0b,
	0xb6, 0xd2, 0x72, 0x41, 0xe2, 0x1f, 0xf4, 0x84, 0x3c, 0xfe, 0x9a, 0x5d, 0x6f, 0xaa, 0x76, 0x85,
	0x68, 0x4e, 0x3b, 0x5f, 0xcf, 0x3b, 0xcf, 0xfb, 0x3c, 0xef, 0xbe, 0x1e, 0xb0, 0x19, 0x10, 0x86,
	0x30, 0x62, 0xc8, 0x08, 0x23, 0xca, 0x28, 0xdc, 0x7a, 0x84, 0x22, 0x9f, 0xba, 0x46, 0xf6, 0x13,
	0x9e, 0x6a, 0xba, 0x4b, 0xa9, 0xeb, 0x93, 0x03, 0xbe, 0x7d, 0x9a, 0x7c, 0x75, 0xc0, 0xbc, 0x80,
	0xc4, 0x0c, 0x05, 0x61, 0x86, 0xd0, 0x3e, 0x70, 0x3d, 0x36, 0x4a, 0x4e, 0x8d, 0x21, 0x0d, 0x0e,
	0x5c, 0xea, 0xd2, 0xea, 0x64, 0x3a, 0xe3, 0x13, 0x3e, 0xca, 0x8e, 0xef, 0x3d, 0x04, 0x3b, 0x36,
	0xa3, 0x11, 0x72, 0x49, 0x97, 0xc4, 0xc3, 0xc8, 0x0b, 0x19, 0x8d, 0x20, 0x04, 0x4a, 0x88, 0xd8,
	0xa8, 0x25, 0xb5, 0xa5, 0xfd, 0x75, 0x8b, 0x8f, 0xd3, 0xb5, 0x24, 0x26, 0xb8, 0x25, 0xb7, 0xa5,
	0x7d, 0xc5, 0xe2, 0x63, 0xf8, 0x1a, 0x58, 0x65, 0x94, 0x21, 0xbf, 0xd5, 0xe0, 0x8b, 0xd9, 0xe4,
	0x9e, 0xf2, 0xf7, 0x63, 0x5d, 0xda, 0xfb, 0x5d, 0x06, 0x37, 0xf3, 0xc8, 0x26, 0xc5, 0x62, 0xf4,
	0xef, 0xc0, 0x56, 0x9c, 0x6d, 0x38, 0x63, 0x8a, 0x89, 0xe3, 0x61, 0x7e, 0x91, 0xda, 0xf9, 0x62,
	0x3a, 0xd1, 0x55, 0x01, 0xd3, 0xef, 0x3e, 0x9b, 0xe8, 0x87, 0x79, 0x3e, 0x18, 0x25, 0xc1, 0x19,
	0x3a, 0x43, 0x94, 0x67, 0x96, 0xe9, 0x51, 0xfc, 0x84, 0x67, 0xe5, 0x90, 0x7d, 0x1b, 0x92, 0xd8,
	0x98, 0x09, 0x62, 0xa9, 0xb1, 0x30, 0xc5, 0xb0, 0x05, 0xae, 0x21, 0x8c, 0x23, 0x12, 0xc7, 0x3c,
	0x99, 0x75, 0xab, 0x98, 0xc2, 0x7b, 0x60, 0x2d, 0x66, 0x88, 0x25, 0x31, 0x4f, 0x68, 0xf3, 0xc3,
	0x3d, 0x63, 0x4e, 0x7e, 0x31, 0xb0, 0xcd, 0x4f, 0x5a, 0x39, 0x02, 0x76, 0xc1, 0xf5, 0xfc, 0x9a,
	0xb8, 0xa5, 0xb4, 0x1b, 0xfb, 0xcd, 0xcb, 0xd1, 0x95, 0x16, 0x1d, 0xe5, 0xc9, 0x44, 0x97, 0xac,
	0x12, 0x99, 0x6b, 0xf7, 0xab, 0x04, 0x76, 0x2c, 0x12, 0xfa, 0xde, 0x10, 0x5d, 0x21, 0xdd, 0x8a,
	0xaa, 0x90, 0xab, 0xaa, 0xc8, 0xf9, 0xfe, 0x24, 0x83, 0x1b, 0x03, 0xea, 0xda, 0x2c, 0x22, 0x28,
	0x10, 0x18, 0x3f, 0x02, 0xaa, 0x4f, 0x5d, 0x27, 0xe6, 0xeb, 0x15, 0x5f, 0x6b, 0x3a, 0xd1, 0x9b,
	0xe5, 0x79, 0xce, 0xf6, 0xfe, 0x32, 0x6c, 0x85, 0x10, 0x56, 0xd3, 0x2f, 0x27, 0x18, 0xde, 0x2d,
	0x7d, 0x94, 0xb9, 0x8f, 0xed, 0x9a, 0x13, 0x25, 0xb4, 0xee, 0x62, 0x94, 0x09, 0x9f, 0xd6, 0xc0,
	0x62, 0x17, 0x6b, 0xce, 0x14, 0x2e, 0x16, 0xc8, 0x5c, 0x95, 0xa7, 0x12, 0x80, 0x0f, 0xf2, 0xbf,
	0xb3, 0x20, 0xca, 0x3b, 0x40, 0x45, 0x61, 0xe8, 0x7b, 0x04, 0x3b, 0xde, 0x18, 0x93, 0x6f, 0xb8,
	0x28, 0x8a, 0xb5, 0x91, 0x2f, 0xf6, 0xd3, 0x35, 0xf8, 0x39, 0x50, 0x45, 0xaf, 0xd3, 0x44, 0x52,
	0x32, 0xef, 0x3d, 0xaf, 0x20, 0x6b, 0x84, 0x36, 0x04, 0xff, 0x62, 0xf8, 0x19, 0x68, 0x56, 0x66,
	0x14, 0xd9, 0xbd, 0x7b, 0xb9, 0x32, 0xb5, 0x70, 0xa0, 0x94, 0xb8, 0xc8, 0xf0, 0x8f, 0x06, 0x78,
	0x5b, 0x20, 0xb0, 0x20, 0xd9, 0x00, 0x80, 0xa1, 0x9f, 0xc4, 0x8c, 0x44, 0x95, 0xfd, 0xe6, 0x74,
	0xa2, 0xaf, 0x7f, 0x92, 0xad, 0x72, 0xf3, 0x3f, 0x5e, 0xc6, 0xfc, 0x32, 0x80, 0xb5, 0x9e, 0xdf,
	0xd0, 0xc7, 0xb0, 0x0f, 0x36, 0x44, 0xd9, 0xb8, 0xfd, 0x2f, 0xac, 0x9a, 0xd5, 0x14, 0xf4, 0x82,
	0xf6, 0x22, 0xb9, 0xde, 0xbf, 0x5c, 0xae, 0x7a, 0xf2, 0x5c, 0xb6, 0x15, 0x51, 0x36, 0x78, 0x04,
	0x36, 0x86, 0x11, 0x41, 0x8c, 0x60, 0x27, 0xed, 0xdb, 0x2d, 0x85, 0xf3, 0xd3, 0x8c, 0xac, 0xa9,
	0x1b, 0x45, 0xab, 0x36, 0x8e, 0x8b, 0xa6, 0xde, 0xb9, 0x9e, 0xc6, 0xf8, 0xf1, 0xa9, 0x2e, 0x59,
	0xcd, 0x1c, 0x99, 0xee, 0xa5, 0x81, 0x92, 0x10, 0x57, 0x81, 0x56, 0x5f, 0x26, 0x50, 0x8e, 0x4c,
	0xf7, 0xf6, 0xfe, 0x51, 0xc0, 0x9b, 0xcf, 0xc9, 0xe1, 0x95, 0x37, 0x9d, 0x5a, 0x0b, 0x91, 0xff,
	0xef, 0x16, 0xd2, 0x78, 0xc9, 0x16, 0xc2, 0xc0, 0xe6, 0xc8, 0x73, 0x47, 0xce, 0xd7, 0x88, 0x91,
	0x28, 0x40, 0xd1, 0x19, 0x77, 0x59, 0xed, 0x3c, 0x48, 0x05, 0xfb, 0xd4, 0x73, 0x47, 0x0f, 0x8b,
	0x8d, 0x67, 0x13, 0xfd, 0xee, 0x32, 0xa4, 0x8f, 0x06, 0xb6, 0x69, 0xa9, 0x23, 0x31, 0x54, 0xd9,
	0x9c, 0x57, 0x85, 0x4f, 0xf6, 0x7c, 0xb5, 0xad, 0xfd, 0x57, 0xd5, 0x76, 0x6d, 0xd9, 0x6a, 0xfb,
	0x4d, 0x06, 0x5a, 0xa9, 0xdb, 0xd5, 0xfb, 0xc2, 0xbd, 0xaa, 0x62, 0x13, 0x5e, 0x24, 0x8d, 0x99,
	0x17, 0xc9, 0xad, 0xef, 0xa5, 0xf2, 0x7d, 0x56, 0xbd, 0x39, 0xe0, 0x1d, 0xb0, 0x63, 0x9b, 0x8e,
	0x7d, 0x7c, 0x78, 0x7c, 0x62, 0x3b, 0xd6, 0x89, 0x69, 0xf6, 0xcd, 0xa3, 0xed, 0x15, 0xed, 0xad,
	0xf3, 0x8b, 0x76, 0xab, 0xfe, 0x42, 0x49, 0xc6, 0x63, 0x6f, 0xec, 0xce, 0x82, 0xba, 0xbd, 0x41,
	0xef, 0xb8, 0xd7, 0xdd, 0x96, 0x2e, 0x01, 0x75, 0x89, 0x4f, 0x18, 0xc1, 0x9a, 0xf2, 0xc3, 0x2f,
	0xbb, 0x2b, 0xb7, 0x7e, 0x96, 0xc1, 0xd6, 0x5c, 0xb9, 0xc3, 0xdb, 0x60, 0x67, 0x60, 0xd7, 0x39,
	0x68, 0xe7, 0x17, 0xed, 0xd7, 0xe7, 0xff, 0x1a, 0x39, 0x83, 0x19, 0x88, 0xdd, 0x3b, 0x1c, 0xa4,
	0x10, 0x69, 0x21, 0xc4, 0x26, 0xc8, 0x4f, 0x21, 0x07, 0x60, 0x7b, 0x16, 0xd2, 0xeb, 0x6e, 0xcb,
	0xda, 0x1b, 0xe7, 0x17, 0xed, 0x9b, 0x0b, 0x10, 0x04, 0xcf, 0xde, 0x51, 0x64, 0xd9, 0x58, 0x78,
	0x47, 0x9e, 0x23, 0xfc, 0x08, 0xdc, 0xa8, 0x20, 0x27, 0x66, 0x41, 0x4c, 0xc9, 0xa4, 0x99, 0x03,
	0x9d, 0x8c, 0xe3, 0x8c, 0x5a, 0x26, 0x4d, 0xe7, 0xfe, 0x93, 0xe9, 0xae, 0xf4, 0xe7, 0x74, 0x57,
	0x7a, 0xfc, 0xd7, 0xae, 0xf4, 0xe5, 0xed, 0x17, 0x29, 0x0b, 0xfe, 0x04, 0x2f, 0xda, 0xc8, 0xe9,
	0x1a, 0x9f, 0xdf, 0xf9, 0x37, 0x00, 0x00, 0xff, 0xff, 0xc9, 0x4a, 0xca, 0x5b, 0xfa, 0x0b, 0x00,
	0x00,
}

func (this *StorageDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDescriptor)
	if !ok {
		that2, ok := that.(StorageDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Used != that1.Used {
		return false
	}
	if this.Total != that1.Total {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *StorageNodeDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageNodeDescriptor)
	if !ok {
		that2, ok := that.(StorageNodeDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageNodeID != that1.StorageNodeID {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Storages) != len(that1.Storages) {
		return false
	}
	for i := range this.Storages {
		if !this.Storages[i].Equal(that1.Storages[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReplicaDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplicaDescriptor)
	if !ok {
		that2, ok := that.(ReplicaDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageNodeID != that1.StorageNodeID {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *LogStreamDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogStreamDescriptor)
	if !ok {
		that2, ok := that.(LogStreamDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LogStreamID != that1.LogStreamID {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Replicas) != len(that1.Replicas) {
		return false
	}
	for i := range this.Replicas {
		if !this.Replicas[i].Equal(that1.Replicas[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MetadataDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetadataDescriptor)
	if !ok {
		that2, ok := that.(MetadataDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppliedIndex != that1.AppliedIndex {
		return false
	}
	if len(this.StorageNodes) != len(that1.StorageNodes) {
		return false
	}
	for i := range this.StorageNodes {
		if !this.StorageNodes[i].Equal(that1.StorageNodes[i]) {
			return false
		}
	}
	if len(this.LogStreams) != len(that1.LogStreams) {
		return false
	}
	for i := range this.LogStreams {
		if !this.LogStreams[i].Equal(that1.LogStreams[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (m *StorageDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Total != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.Used != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StorageNodeDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageNodeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageNodeDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Storages) > 0 {
		for iNdEx := len(m.Storages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Storages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogStreamDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MetadataDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.StorageNodes) > 0 {
		for iNdEx := len(m.StorageNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StorageNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AppliedIndex != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.AppliedIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StorageNodeMetadataDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageNodeMetadataDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageNodeMetadataDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdatedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintMetadata(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x2a
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintMetadata(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x22
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.StorageNode != nil {
		{
			size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMetadata(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ClusterID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogStreamMetadataDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamMetadataDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamMetadataDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	n4, err4 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdatedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedTime):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintMetadata(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x3a
	n5, err5 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreatedTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedTime):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintMetadata(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x32
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x2a
	}
	if m.HighWatermark != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.HighWatermark))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogStreamReplicaDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamReplicaDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamReplicaDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x1a
	}
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetadata(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetadata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StorageDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Used != 0 {
		n += 1 + sovMetadata(uint64(m.Used))
	}
	if m.Total != 0 {
		n += 1 + sovMetadata(uint64(m.Total))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageNodeDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if len(m.Storages) > 0 {
		for _, e := range m.Storages {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplicaDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogStreamDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MetadataDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppliedIndex != 0 {
		n += 1 + sovMetadata(uint64(m.AppliedIndex))
	}
	if len(m.StorageNodes) > 0 {
		for _, e := range m.StorageNodes {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StorageNodeMetadataDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovMetadata(uint64(m.ClusterID))
	}
	if m.StorageNode != nil {
		l = m.StorageNode.ProtoSize()
		n += 1 + l + sovMetadata(uint64(l))
	}
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedTime)
	n += 1 + l + sovMetadata(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedTime)
	n += 1 + l + sovMetadata(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogStreamMetadataDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if m.HighWatermark != 0 {
		n += 1 + sovMetadata(uint64(m.HighWatermark))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreatedTime)
	n += 1 + l + sovMetadata(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdatedTime)
	n += 1 + l + sovMetadata(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogStreamReplicaDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetadata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetadata(x uint64) (n int) {
	return sovMetadata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StorageDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageNodeDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageNodeDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageNodeDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= StorageNodeStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Storages = append(m.Storages, &StorageDescriptor{})
			if err := m.Storages[len(m.Storages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogStreamDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_varlog_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LogStreamStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &ReplicaDescriptor{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MetadataDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedIndex", wireType)
			}
			m.AppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppliedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageNodes = append(m.StorageNodes, &StorageNodeDescriptor{})
			if err := m.StorageNodes[len(m.StorageNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, &LogStreamDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageNodeMetadataDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageNodeMetadataDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageNodeMetadataDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_daumkakao_com_varlog_varlog_pkg_varlog_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageNode == nil {
				m.StorageNode = &StorageNodeDescriptor{}
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, LogStreamMetadataDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogStreamMetadataDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamMetadataDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamMetadataDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_varlog_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LogStreamStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWatermark", wireType)
			}
			m.HighWatermark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighWatermark |= github_daumkakao_com_varlog_varlog_pkg_varlog_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdatedTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogStreamReplicaDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamReplicaDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamReplicaDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_varlog_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_varlog_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetadata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetadata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetadata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetadata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetadata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetadata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetadata = fmt.Errorf("proto: unexpected end of group")
)
