// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/varlogpb/metadata.proto

package varlogpb

import (
	bytes "bytes"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/protobuf/types/known/timestamppb"

	github_daumkakao_com_varlog_varlog_pkg_types "github.daumkakao.com/varlog/varlog/pkg/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StorageNodeStatus int32

const (
	StorageNodeStatusRunning     StorageNodeStatus = 0
	StorageNodeStatusDeleted     StorageNodeStatus = 1
	StorageNodeStatusUnavailable StorageNodeStatus = 2
)

var StorageNodeStatus_name = map[int32]string{
	0: "STORAGE_NODE_STATUS_RUNNING",
	1: "STORAGE_NODE_STATUS_DELETED",
	2: "STORAGE_NODE_STATUS_UNAVAILABLE",
}

var StorageNodeStatus_value = map[string]int32{
	"STORAGE_NODE_STATUS_RUNNING":     0,
	"STORAGE_NODE_STATUS_DELETED":     1,
	"STORAGE_NODE_STATUS_UNAVAILABLE": 2,
}

func (x StorageNodeStatus) String() string {
	return proto.EnumName(StorageNodeStatus_name, int32(x))
}

func (StorageNodeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{0}
}

type LogStreamStatus int32

const (
	LogStreamStatusRunning   LogStreamStatus = 0
	LogStreamStatusSealing   LogStreamStatus = 1
	LogStreamStatusSealed    LogStreamStatus = 2
	LogStreamStatusDeleted   LogStreamStatus = 3
	LogStreamStatusUnsealing LogStreamStatus = 4
)

var LogStreamStatus_name = map[int32]string{
	0: "LS_STATUS_RUNNING",
	1: "LS_STATUS_SEALING",
	2: "LS_STATUS_SEALED",
	3: "LS_STATUS_DELETED",
	4: "LS_STATUS_UNSEALING",
}

var LogStreamStatus_value = map[string]int32{
	"LS_STATUS_RUNNING":   0,
	"LS_STATUS_SEALING":   1,
	"LS_STATUS_SEALED":    2,
	"LS_STATUS_DELETED":   3,
	"LS_STATUS_UNSEALING": 4,
}

func (x LogStreamStatus) String() string {
	return proto.EnumName(LogStreamStatus_name, int32(x))
}

func (LogStreamStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{1}
}

type TopicStatus int32

const (
	TopicStatusRunning TopicStatus = 0
	TopicStatusDeleted TopicStatus = 1
)

var TopicStatus_name = map[int32]string{
	0: "TOPIC_STATUS_RUNNING",
	1: "TOPIC_STATUS_DELETED",
}

var TopicStatus_value = map[string]int32{
	"TOPIC_STATUS_RUNNING": 0,
	"TOPIC_STATUS_DELETED": 1,
}

func (x TopicStatus) String() string {
	return proto.EnumName(TopicStatus_name, int32(x))
}

func (TopicStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{2}
}

// MetadataDescriptor is metadata to persist the overall state of the cluster in
// the metadata repository.
type MetadataDescriptor struct {
	AppliedIndex uint64                   `protobuf:"varint,1,opt,name=applied_index,json=appliedIndex,proto3" json:"appliedIndex"`
	StorageNodes []*StorageNodeDescriptor `protobuf:"bytes,2,rep,name=storage_nodes,json=storageNodes,proto3" json:"storageNodes"`
	LogStreams   []*LogStreamDescriptor   `protobuf:"bytes,3,rep,name=log_streams,json=logStreams,proto3" json:"logStreams"`
	Topics       []*TopicDescriptor       `protobuf:"bytes,4,rep,name=topics,proto3" json:"topics"`
}

func (m *MetadataDescriptor) Reset()         { *m = MetadataDescriptor{} }
func (m *MetadataDescriptor) String() string { return proto.CompactTextString(m) }
func (*MetadataDescriptor) ProtoMessage()    {}
func (*MetadataDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{0}
}
func (m *MetadataDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MetadataDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MetadataDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MetadataDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MetadataDescriptor.Merge(m, src)
}
func (m *MetadataDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *MetadataDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_MetadataDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_MetadataDescriptor proto.InternalMessageInfo

func (m *MetadataDescriptor) GetAppliedIndex() uint64 {
	if m != nil {
		return m.AppliedIndex
	}
	return 0
}

func (m *MetadataDescriptor) GetStorageNodes() []*StorageNodeDescriptor {
	if m != nil {
		return m.StorageNodes
	}
	return nil
}

func (m *MetadataDescriptor) GetLogStreams() []*LogStreamDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

func (m *MetadataDescriptor) GetTopics() []*TopicDescriptor {
	if m != nil {
		return m.Topics
	}
	return nil
}

// StorageNodeDescriptor is immutable metadata to persist information of a
// storage node in the metadata repository.
// It is also used to compare two storage nodes to decide if they are the same.
//
// Note that only immutable fields should be added.
type StorageNodeDescriptor struct {
	StorageNode `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3,embedded=storage_node" json:""`
	Status      StorageNodeStatus `protobuf:"varint,2,opt,name=status,proto3,enum=varlog.varlogpb.StorageNodeStatus" json:"status,omitempty"`
	Paths       []string          `protobuf:"bytes,3,rep,name=paths,proto3" json:"paths,omitempty"`
}

func (m *StorageNodeDescriptor) Reset()         { *m = StorageNodeDescriptor{} }
func (m *StorageNodeDescriptor) String() string { return proto.CompactTextString(m) }
func (*StorageNodeDescriptor) ProtoMessage()    {}
func (*StorageNodeDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{1}
}
func (m *StorageNodeDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageNodeDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageNodeDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageNodeDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageNodeDescriptor.Merge(m, src)
}
func (m *StorageNodeDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageNodeDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageNodeDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StorageNodeDescriptor proto.InternalMessageInfo

func (m *StorageNodeDescriptor) GetStatus() StorageNodeStatus {
	if m != nil {
		return m.Status
	}
	return StorageNodeStatusRunning
}

func (m *StorageNodeDescriptor) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

type StorageDescriptor struct {
	Path  string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Used  uint64 `protobuf:"varint,2,opt,name=used,proto3" json:"used,omitempty"`
	Total uint64 `protobuf:"varint,3,opt,name=total,proto3" json:"total,omitempty"`
}

func (m *StorageDescriptor) Reset()         { *m = StorageDescriptor{} }
func (m *StorageDescriptor) String() string { return proto.CompactTextString(m) }
func (*StorageDescriptor) ProtoMessage()    {}
func (*StorageDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{2}
}
func (m *StorageDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageDescriptor.Merge(m, src)
}
func (m *StorageDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_StorageDescriptor proto.InternalMessageInfo

func (m *StorageDescriptor) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *StorageDescriptor) GetUsed() uint64 {
	if m != nil {
		return m.Used
	}
	return 0
}

func (m *StorageDescriptor) GetTotal() uint64 {
	if m != nil {
		return m.Total
	}
	return 0
}

// LogStreamDescriptor is metadata to persist information of a log stream in the
// metadata repository.
type LogStreamDescriptor struct {
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topicId"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"logStreamId"`
	Status      LogStreamStatus                                          `protobuf:"varint,3,opt,name=status,proto3,enum=varlog.varlogpb.LogStreamStatus" json:"status,omitempty"`
	Replicas    []*ReplicaDescriptor                                     `protobuf:"bytes,4,rep,name=replicas,proto3" json:"replicas,omitempty"`
	// Deprecated: The members - head and tail are not used by the metadata
	// repository. It exists here just since the LogStreamDescriptor is used
	// elsewhere other than the metadata repository. It leads to misusing the
	// LogStreamDescriptor.
	Head LogEntryMeta `protobuf:"bytes,5,opt,name=head,proto3" json:"head,omitempty"`
	Tail LogEntryMeta `protobuf:"bytes,6,opt,name=tail,proto3" json:"tail,omitempty"`
}

func (m *LogStreamDescriptor) Reset()         { *m = LogStreamDescriptor{} }
func (m *LogStreamDescriptor) String() string { return proto.CompactTextString(m) }
func (*LogStreamDescriptor) ProtoMessage()    {}
func (*LogStreamDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{3}
}
func (m *LogStreamDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamDescriptor.Merge(m, src)
}
func (m *LogStreamDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamDescriptor proto.InternalMessageInfo

func (m *LogStreamDescriptor) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *LogStreamDescriptor) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogStreamDescriptor) GetStatus() LogStreamStatus {
	if m != nil {
		return m.Status
	}
	return LogStreamStatusRunning
}

func (m *LogStreamDescriptor) GetReplicas() []*ReplicaDescriptor {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *LogStreamDescriptor) GetHead() LogEntryMeta {
	if m != nil {
		return m.Head
	}
	return LogEntryMeta{}
}

func (m *LogStreamDescriptor) GetTail() LogEntryMeta {
	if m != nil {
		return m.Tail
	}
	return LogEntryMeta{}
}

type ReplicaDescriptor struct {
	StorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storageNodeId"`
	Path          string                                                     `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *ReplicaDescriptor) Reset()         { *m = ReplicaDescriptor{} }
func (m *ReplicaDescriptor) String() string { return proto.CompactTextString(m) }
func (*ReplicaDescriptor) ProtoMessage()    {}
func (*ReplicaDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{4}
}
func (m *ReplicaDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicaDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaDescriptor.Merge(m, src)
}
func (m *ReplicaDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ReplicaDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaDescriptor proto.InternalMessageInfo

func (m *ReplicaDescriptor) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *ReplicaDescriptor) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// TopicDescriptor is metadata to persist information of a topic in the metadata
// repository.
type TopicDescriptor struct {
	TopicID    github_daumkakao_com_varlog_varlog_pkg_types.TopicID       `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topicId"`
	Status     TopicStatus                                                `protobuf:"varint,2,opt,name=status,proto3,enum=varlog.varlogpb.TopicStatus" json:"status"`
	LogStreams []github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,3,rep,packed,name=log_streams,json=logStreams,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"logStreams,omitempty"`
}

func (m *TopicDescriptor) Reset()         { *m = TopicDescriptor{} }
func (m *TopicDescriptor) String() string { return proto.CompactTextString(m) }
func (*TopicDescriptor) ProtoMessage()    {}
func (*TopicDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{5}
}
func (m *TopicDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicDescriptor.Merge(m, src)
}
func (m *TopicDescriptor) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TopicDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_TopicDescriptor proto.InternalMessageInfo

func (m *TopicDescriptor) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *TopicDescriptor) GetStatus() TopicStatus {
	if m != nil {
		return m.Status
	}
	return TopicStatusRunning
}

func (m *TopicDescriptor) GetLogStreams() []github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

// StorageNode is a structure to represent identifier and address of storage
// node.
type StorageNode struct {
	StorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storageNodeId"`
	Address       string                                                     `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *StorageNode) Reset()         { *m = StorageNode{} }
func (m *StorageNode) String() string { return proto.CompactTextString(m) }
func (*StorageNode) ProtoMessage()    {}
func (*StorageNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{6}
}
func (m *StorageNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageNode.Merge(m, src)
}
func (m *StorageNode) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageNode) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageNode.DiscardUnknown(m)
}

var xxx_messageInfo_StorageNode proto.InternalMessageInfo

func (m *StorageNode) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *StorageNode) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// TopicLogStream wraps TopicID and LogStreamID.
type TopicLogStream struct {
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topicId"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"logStreamId"`
}

func (m *TopicLogStream) Reset()         { *m = TopicLogStream{} }
func (m *TopicLogStream) String() string { return proto.CompactTextString(m) }
func (*TopicLogStream) ProtoMessage()    {}
func (*TopicLogStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{7}
}
func (m *TopicLogStream) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TopicLogStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TopicLogStream.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TopicLogStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TopicLogStream.Merge(m, src)
}
func (m *TopicLogStream) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TopicLogStream) XXX_DiscardUnknown() {
	xxx_messageInfo_TopicLogStream.DiscardUnknown(m)
}

var xxx_messageInfo_TopicLogStream proto.InternalMessageInfo

func (m *TopicLogStream) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *TopicLogStream) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

// LogStreamReplica represents replica of log stream.
type LogStreamReplica struct {
	StorageNode    `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3,embedded=storage_node" json:"storage_node"`
	TopicLogStream `protobuf:"bytes,2,opt,name=topic_log_stream,json=topicLogStream,proto3,embedded=topic_log_stream" json:"topic_log_stream"`
}

func (m *LogStreamReplica) Reset()         { *m = LogStreamReplica{} }
func (m *LogStreamReplica) String() string { return proto.CompactTextString(m) }
func (*LogStreamReplica) ProtoMessage()    {}
func (*LogStreamReplica) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{8}
}
func (m *LogStreamReplica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogStreamReplica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogStreamReplica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogStreamReplica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogStreamReplica.Merge(m, src)
}
func (m *LogStreamReplica) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogStreamReplica) XXX_DiscardUnknown() {
	xxx_messageInfo_LogStreamReplica.DiscardUnknown(m)
}

var xxx_messageInfo_LogStreamReplica proto.InternalMessageInfo

// LogSequenceNumber wraps LLSN and GLSN.
// LLSN is the sequence number of logs in a log stream.
// GLSN is the sequence number of logs in a topic.
type LogSequenceNumber struct {
	LLSN github_daumkakao_com_varlog_varlog_pkg_types.LLSN `protobuf:"varint,1,opt,name=llsn,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LLSN" json:"llsn,omitempty"`
	GLSN github_daumkakao_com_varlog_varlog_pkg_types.GLSN `protobuf:"varint,2,opt,name=glsn,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"glsn,omitempty"`
}

func (m *LogSequenceNumber) Reset()         { *m = LogSequenceNumber{} }
func (m *LogSequenceNumber) String() string { return proto.CompactTextString(m) }
func (*LogSequenceNumber) ProtoMessage()    {}
func (*LogSequenceNumber) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{9}
}
func (m *LogSequenceNumber) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogSequenceNumber) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogSequenceNumber.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogSequenceNumber) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogSequenceNumber.Merge(m, src)
}
func (m *LogSequenceNumber) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogSequenceNumber) XXX_DiscardUnknown() {
	xxx_messageInfo_LogSequenceNumber.DiscardUnknown(m)
}

var xxx_messageInfo_LogSequenceNumber proto.InternalMessageInfo

func (m *LogSequenceNumber) GetLLSN() github_daumkakao_com_varlog_varlog_pkg_types.LLSN {
	if m != nil {
		return m.LLSN
	}
	return 0
}

func (m *LogSequenceNumber) GetGLSN() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.GLSN
	}
	return 0
}

type LogEntryMeta struct {
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	GLSN        github_daumkakao_com_varlog_varlog_pkg_types.GLSN        `protobuf:"varint,3,opt,name=glsn,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"glsn,omitempty"`
	LLSN        github_daumkakao_com_varlog_varlog_pkg_types.LLSN        `protobuf:"varint,4,opt,name=llsn,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LLSN" json:"llsn,omitempty"`
}

func (m *LogEntryMeta) Reset()         { *m = LogEntryMeta{} }
func (m *LogEntryMeta) String() string { return proto.CompactTextString(m) }
func (*LogEntryMeta) ProtoMessage()    {}
func (*LogEntryMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{10}
}
func (m *LogEntryMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogEntryMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogEntryMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogEntryMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEntryMeta.Merge(m, src)
}
func (m *LogEntryMeta) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogEntryMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEntryMeta.DiscardUnknown(m)
}

var xxx_messageInfo_LogEntryMeta proto.InternalMessageInfo

func (m *LogEntryMeta) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *LogEntryMeta) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *LogEntryMeta) GetGLSN() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.GLSN
	}
	return 0
}

func (m *LogEntryMeta) GetLLSN() github_daumkakao_com_varlog_varlog_pkg_types.LLSN {
	if m != nil {
		return m.LLSN
	}
	return 0
}

type LogEntry struct {
	LogEntryMeta `protobuf:"bytes,1,opt,name=meta,proto3,embedded=meta" json:"meta"`
	Data         []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *LogEntry) Reset()         { *m = LogEntry{} }
func (m *LogEntry) String() string { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()    {}
func (*LogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{11}
}
func (m *LogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogEntry.Merge(m, src)
}
func (m *LogEntry) XXX_Size() int {
	return m.ProtoSize()
}
func (m *LogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_LogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_LogEntry proto.InternalMessageInfo

func (m *LogEntry) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type CommitContext struct {
	Version            github_daumkakao_com_varlog_varlog_pkg_types.Version `protobuf:"varint,1,opt,name=version,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.Version" json:"version,omitempty"`
	HighWatermark      github_daumkakao_com_varlog_varlog_pkg_types.GLSN    `protobuf:"varint,2,opt,name=high_watermark,json=highWatermark,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"high_watermark,omitempty"`
	CommittedGLSNBegin github_daumkakao_com_varlog_varlog_pkg_types.GLSN    `protobuf:"varint,3,opt,name=committed_glsn_begin,json=committedGlsnBegin,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"committed_glsn_begin,omitempty"`
	CommittedGLSNEnd   github_daumkakao_com_varlog_varlog_pkg_types.GLSN    `protobuf:"varint,4,opt,name=committed_glsn_end,json=committedGlsnEnd,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"committed_glsn_end,omitempty"`
	CommittedLLSNBegin github_daumkakao_com_varlog_varlog_pkg_types.LLSN    `protobuf:"varint,5,opt,name=committed_llsn_begin,json=committedLlsnBegin,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LLSN" json:"committed_llsn_begin,omitempty"`
}

func (m *CommitContext) Reset()         { *m = CommitContext{} }
func (m *CommitContext) String() string { return proto.CompactTextString(m) }
func (*CommitContext) ProtoMessage()    {}
func (*CommitContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb4411772ca3492a, []int{12}
}
func (m *CommitContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitContext.Merge(m, src)
}
func (m *CommitContext) XXX_Size() int {
	return m.ProtoSize()
}
func (m *CommitContext) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitContext.DiscardUnknown(m)
}

var xxx_messageInfo_CommitContext proto.InternalMessageInfo

func (m *CommitContext) GetVersion() github_daumkakao_com_varlog_varlog_pkg_types.Version {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CommitContext) GetHighWatermark() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.HighWatermark
	}
	return 0
}

func (m *CommitContext) GetCommittedGLSNBegin() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.CommittedGLSNBegin
	}
	return 0
}

func (m *CommitContext) GetCommittedGLSNEnd() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.CommittedGLSNEnd
	}
	return 0
}

func (m *CommitContext) GetCommittedLLSNBegin() github_daumkakao_com_varlog_varlog_pkg_types.LLSN {
	if m != nil {
		return m.CommittedLLSNBegin
	}
	return 0
}

func init() {
	proto.RegisterEnum("varlog.varlogpb.StorageNodeStatus", StorageNodeStatus_name, StorageNodeStatus_value)
	proto.RegisterEnum("varlog.varlogpb.LogStreamStatus", LogStreamStatus_name, LogStreamStatus_value)
	proto.RegisterEnum("varlog.varlogpb.TopicStatus", TopicStatus_name, TopicStatus_value)
	proto.RegisterType((*MetadataDescriptor)(nil), "varlog.varlogpb.MetadataDescriptor")
	proto.RegisterType((*StorageNodeDescriptor)(nil), "varlog.varlogpb.StorageNodeDescriptor")
	proto.RegisterType((*StorageDescriptor)(nil), "varlog.varlogpb.StorageDescriptor")
	proto.RegisterType((*LogStreamDescriptor)(nil), "varlog.varlogpb.LogStreamDescriptor")
	proto.RegisterType((*ReplicaDescriptor)(nil), "varlog.varlogpb.ReplicaDescriptor")
	proto.RegisterType((*TopicDescriptor)(nil), "varlog.varlogpb.TopicDescriptor")
	proto.RegisterType((*StorageNode)(nil), "varlog.varlogpb.StorageNode")
	proto.RegisterType((*TopicLogStream)(nil), "varlog.varlogpb.TopicLogStream")
	proto.RegisterType((*LogStreamReplica)(nil), "varlog.varlogpb.LogStreamReplica")
	proto.RegisterType((*LogSequenceNumber)(nil), "varlog.varlogpb.LogSequenceNumber")
	proto.RegisterType((*LogEntryMeta)(nil), "varlog.varlogpb.LogEntryMeta")
	proto.RegisterType((*LogEntry)(nil), "varlog.varlogpb.LogEntry")
	proto.RegisterType((*CommitContext)(nil), "varlog.varlogpb.CommitContext")
}

func init() { proto.RegisterFile("proto/varlogpb/metadata.proto", fileDescriptor_eb4411772ca3492a) }

var fileDescriptor_eb4411772ca3492a = []byte{
	// 1340 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x4f, 0x6f, 0x1b, 0xc5,
	0x1b, 0xf6, 0xda, 0x9b, 0x3f, 0x1d, 0xc7, 0x89, 0x33, 0x4d, 0x2b, 0xff, 0xfc, 0x4b, 0xbd, 0x56,
	0x85, 0x50, 0x55, 0x41, 0x4c, 0x03, 0x95, 0xaa, 0xa2, 0x4a, 0xc4, 0xf1, 0x92, 0x5a, 0xdd, 0xba,
	0xb0, 0x9b, 0xb4, 0xd0, 0x03, 0x66, 0x9c, 0x1d, 0xd6, 0xab, 0xec, 0x3f, 0x76, 0xc7, 0x6d, 0x73,
	0x00, 0x89, 0x5b, 0x15, 0x2e, 0x1c, 0x39, 0x10, 0xa9, 0x12, 0x5f, 0x82, 0x13, 0x5c, 0xcb, 0xad,
	0x47, 0xb8, 0xec, 0xc1, 0xb9, 0xa0, 0x7e, 0x84, 0x9e, 0xd0, 0xcc, 0xce, 0x7a, 0x77, 0x6d, 0xb7,
	0x90, 0x34, 0x42, 0x48, 0x9c, 0xb2, 0xb3, 0x33, 0xcf, 0xf3, 0xcc, 0xfb, 0xbe, 0xcf, 0xbc, 0x3b,
	0x0e, 0xb8, 0xe0, 0xf9, 0x2e, 0x71, 0x1b, 0x0f, 0x90, 0x6f, 0xb9, 0x86, 0xd7, 0x6b, 0xd8, 0x98,
	0x20, 0x1d, 0x11, 0xb4, 0xc6, 0xde, 0xc3, 0xa5, 0x68, 0x62, 0x2d, 0x9e, 0xaf, 0x4a, 0x86, 0xeb,
	0x1a, 0x16, 0x6e, 0xb0, 0xe9, 0xde, 0xe0, 0x8b, 0x06, 0x31, 0x6d, 0x1c, 0x10, 0x64, 0x7b, 0x11,
	0xa2, 0xfa, 0xb6, 0x61, 0x92, 0xfe, 0xa0, 0xb7, 0xb6, 0xeb, 0xda, 0x0d, 0xc3, 0x35, 0xdc, 0x64,
	0x25, 0x1d, 0x45, 0x6a, 0xf4, 0x29, 0x5a, 0x7e, 0xf1, 0xf7, 0x3c, 0x80, 0xb7, 0xb9, 0x66, 0x0b,
	0x07, 0xbb, 0xbe, 0xe9, 0x11, 0xd7, 0x87, 0x57, 0x41, 0x09, 0x79, 0x9e, 0x65, 0x62, 0xbd, 0x6b,
	0x3a, 0x3a, 0x7e, 0x54, 0x11, 0xea, 0xc2, 0x25, 0xb1, 0x59, 0x7e, 0x1e, 0x4a, 0x0b, 0x7c, 0xa2,
	0x4d, 0xdf, 0xab, 0x99, 0x11, 0x44, 0xa0, 0x14, 0x10, 0xd7, 0x47, 0x06, 0xee, 0x3a, 0xae, 0x8e,
	0x83, 0x4a, 0xbe, 0x5e, 0xb8, 0x54, 0x5c, 0x7f, 0x73, 0x6d, 0x2c, 0x8c, 0x35, 0x2d, 0x5a, 0xd5,
	0x71, 0x75, 0x9c, 0xa8, 0x36, 0x57, 0x9e, 0x86, 0x92, 0x40, 0x25, 0x82, 0x64, 0x3a, 0x50, 0x33,
	0x23, 0xf8, 0x29, 0x28, 0x5a, 0xae, 0xd1, 0x0d, 0x88, 0x8f, 0x91, 0x1d, 0x54, 0x0a, 0x4c, 0xe0,
	0x8d, 0x09, 0x01, 0xc5, 0x35, 0x34, 0xb6, 0x24, 0x45, 0x0f, 0x39, 0x3d, 0xb0, 0xe2, 0xc9, 0x40,
	0x4d, 0x3d, 0xc3, 0x9b, 0x60, 0x96, 0xb8, 0x9e, 0xb9, 0x1b, 0x54, 0x44, 0xc6, 0x5a, 0x9f, 0x60,
	0xdd, 0xa6, 0xd3, 0x29, 0xc6, 0x45, 0xce, 0xc8, 0x71, 0x2a, 0xff, 0x7b, 0x5d, 0xfc, 0xe3, 0x89,
	0x24, 0x5c, 0xfc, 0x59, 0x00, 0xe7, 0xa6, 0x06, 0x0a, 0x6f, 0x83, 0x85, 0x74, 0x9e, 0x58, 0x76,
	0x8b, 0xeb, 0xab, 0xaf, 0x4a, 0x53, 0x73, 0xe1, 0x69, 0x28, 0xe5, 0x9e, 0x45, 0x7a, 0x39, 0xb5,
	0x98, 0x4a, 0x0a, 0xbc, 0x0e, 0x66, 0x03, 0x82, 0xc8, 0x80, 0xe6, 0x5b, 0xb8, 0xb4, 0xb8, 0x7e,
	0xf1, 0x55, 0x44, 0x1a, 0x5b, 0xa9, 0x72, 0x04, 0x5c, 0x01, 0x33, 0x1e, 0x22, 0xfd, 0x28, 0x93,
	0x67, 0xd4, 0x68, 0xc0, 0x03, 0xb8, 0x07, 0x96, 0x39, 0x30, 0xb5, 0x77, 0x08, 0x44, 0xba, 0x86,
	0xed, 0xf9, 0x8c, 0xca, 0x9e, 0xe9, 0xbb, 0x41, 0x80, 0x75, 0x26, 0x2f, 0xaa, 0xec, 0x99, 0x12,
	0x13, 0x97, 0x20, 0xab, 0x52, 0x60, 0x2f, 0xa3, 0x01, 0x27, 0xfe, 0x41, 0x04, 0x67, 0xa7, 0x54,
	0x08, 0x9a, 0x60, 0x9e, 0x65, 0xb0, 0x6b, 0xea, 0x8c, 0x7f, 0xa6, 0xd9, 0x19, 0x86, 0xd2, 0x1c,
	0x4b, 0x7b, 0xbb, 0xf5, 0x3c, 0x94, 0xe6, 0xd8, 0x74, 0x5b, 0x7f, 0x11, 0x4a, 0xef, 0x71, 0xa3,
	0xeb, 0x68, 0x60, 0xef, 0xa1, 0x3d, 0xe4, 0x32, 0xcb, 0x47, 0x11, 0xc7, 0x7f, 0xbc, 0x3d, 0xa3,
	0x41, 0xf6, 0x3d, 0x1c, 0xac, 0x71, 0x0a, 0x35, 0x26, 0x80, 0x5f, 0x83, 0x52, 0xe2, 0x23, 0xaa,
	0x97, 0x67, 0x7a, 0xf7, 0x87, 0xa1, 0x54, 0x1c, 0x6d, 0x8d, 0x69, 0x16, 0x47, 0x16, 0x61, 0xba,
	0xd7, 0x8e, 0xa5, 0x9b, 0xa2, 0x52, 0xd3, 0x44, 0xf0, 0xda, 0xa8, 0x66, 0x05, 0x56, 0xb3, 0xfa,
	0xcb, 0x2d, 0x3c, 0x56, 0xb1, 0x16, 0x98, 0xf7, 0xb1, 0x67, 0x99, 0xbb, 0x28, 0x36, 0xea, 0x64,
	0xbd, 0xd5, 0x68, 0x41, 0xca, 0xaa, 0x22, 0xb5, 0xaa, 0x3a, 0x42, 0xc2, 0x36, 0x10, 0xfb, 0x18,
	0xe9, 0x95, 0x19, 0x66, 0xbd, 0x0b, 0xd3, 0xd4, 0x65, 0x87, 0xf8, 0xfb, 0xb4, 0x39, 0x34, 0xcf,
	0x53, 0xef, 0x3d, 0x0f, 0xa5, 0x45, 0x0a, 0x79, 0xcb, 0xb5, 0x4d, 0x82, 0x6d, 0x8f, 0xec, 0xab,
	0x8c, 0x82, 0x52, 0x11, 0x64, 0x5a, 0x95, 0xd9, 0x63, 0x51, 0x51, 0x48, 0x9a, 0x8a, 0x8e, 0xb9,
	0x3d, 0x7e, 0x12, 0xc0, 0xf2, 0x44, 0x04, 0xf0, 0xb1, 0x00, 0x96, 0xd2, 0xa7, 0x26, 0x31, 0xc9,
	0xe7, 0xc3, 0x50, 0x2a, 0xa5, 0x2c, 0xce, 0xca, 0x56, 0x4a, 0x9d, 0x10, 0x56, 0xb8, 0xeb, 0xc7,
	0x2a, 0x5c, 0x86, 0x4e, 0xcd, 0x92, 0x8d, 0xce, 0x40, 0x3e, 0x39, 0x03, 0x7c, 0xeb, 0xbf, 0xe4,
	0xc1, 0xd2, 0x58, 0x97, 0xf8, 0x27, 0x5d, 0xfd, 0xc1, 0x58, 0x27, 0x58, 0x9d, 0xde, 0xc2, 0x22,
	0x47, 0x35, 0x01, 0x6d, 0x5d, 0x41, 0xd6, 0x5d, 0xfb, 0x93, 0xfd, 0x75, 0xa6, 0xf9, 0x09, 0xef,
	0x73, 0x2b, 0x49, 0xb7, 0x4c, 0x4a, 0xf7, 0x5a, 0x67, 0x22, 0xd5, 0x7f, 0x93, 0xe2, 0x17, 0x53,
	0xc9, 0xff, 0x37, 0x95, 0xbd, 0x02, 0xe6, 0x90, 0xae, 0xfb, 0x38, 0x08, 0x78, 0xe5, 0xe3, 0x21,
	0xdf, 0xfa, 0x37, 0x79, 0xb0, 0xc8, 0xf2, 0x3b, 0x8a, 0xf0, 0x3f, 0xd4, 0xd1, 0x92, 0xf2, 0x95,
	0x47, 0x4b, 0xf8, 0x21, 0x86, 0xed, 0x13, 0x7c, 0xef, 0xe6, 0xe3, 0xef, 0x5d, 0xf6, 0x5b, 0xa7,
	0x81, 0x72, 0x94, 0xd0, 0x24, 0x56, 0x16, 0x68, 0x71, 0x5d, 0x9a, 0xee, 0xf5, 0xd1, 0x66, 0x52,
	0x8c, 0x8b, 0x24, 0x33, 0x13, 0x9f, 0x5d, 0x01, 0x2c, 0xd3, 0x77, 0xf8, 0xcb, 0x01, 0x76, 0x76,
	0x71, 0x67, 0x60, 0xf7, 0xb0, 0x0f, 0x3f, 0x06, 0xa2, 0x65, 0x05, 0x0e, 0xbf, 0x01, 0xdd, 0x18,
	0x86, 0x92, 0xa8, 0x28, 0x5a, 0xe7, 0x45, 0x28, 0x5d, 0x39, 0x5e, 0xde, 0x14, 0xad, 0xa3, 0x32,
	0x2a, 0x4a, 0x69, 0x50, 0xca, 0x7c, 0x42, 0xb9, 0x75, 0x12, 0xca, 0x2d, 0x46, 0x49, 0xa9, 0x78,
	0x04, 0xdf, 0x16, 0xc0, 0x42, 0xba, 0xdb, 0xc2, 0xcf, 0x26, 0xec, 0xb7, 0x99, 0xb2, 0xdf, 0xeb,
	0x7b, 0xce, 0x9d, 0xee, 0xb9, 0x5b, 0x63, 0x9e, 0x3b, 0xbd, 0xcf, 0x66, 0x9c, 0xba, 0xc2, 0xa9,
	0xa5, 0x6e, 0x54, 0x60, 0xf1, 0xd4, 0x0a, 0xcc, 0xab, 0x81, 0xc0, 0x7c, 0x5c, 0x0c, 0xf8, 0x3e,
	0x10, 0xe9, 0xd5, 0x9e, 0x3b, 0xff, 0x2f, 0xbe, 0x91, 0x89, 0x51, 0x19, 0x88, 0x7e, 0x6e, 0xe8,
	0xfd, 0x9c, 0x25, 0x77, 0x41, 0x65, 0xcf, 0x5c, 0xe2, 0x57, 0x11, 0x94, 0x36, 0x5d, 0xdb, 0x36,
	0xc9, 0xa6, 0xeb, 0x10, 0xfc, 0x88, 0x40, 0x15, 0xcc, 0x3d, 0xc0, 0x7e, 0x60, 0xba, 0xb1, 0x63,
	0xaf, 0x1d, 0xbb, 0xca, 0x77, 0x23, 0xbc, 0x1a, 0x13, 0x41, 0x1b, 0x2c, 0xf6, 0x4d, 0xa3, 0xdf,
	0x7d, 0x88, 0x08, 0xf6, 0x6d, 0xe4, 0xef, 0x71, 0xe7, 0x7e, 0x48, 0x1b, 0xf0, 0x4d, 0xd3, 0xe8,
	0xdf, 0x8b, 0x27, 0x4e, 0x56, 0x87, 0x52, 0x3f, 0xcd, 0x01, 0xbf, 0x02, 0x2b, 0xbb, 0x2c, 0x26,
	0x82, 0xf5, 0x2e, 0x2d, 0x51, 0xb7, 0x87, 0x0d, 0x33, 0xae, 0x39, 0xf5, 0x16, 0xdc, 0x8c, 0xe7,
	0x29, 0xbe, 0x49, 0x67, 0x4f, 0xa6, 0x0c, 0x47, 0x42, 0x5b, 0x56, 0xe0, 0x30, 0x22, 0xf8, 0x10,
	0xc0, 0x31, 0x79, 0xec, 0xe8, 0xdc, 0x1d, 0xed, 0x61, 0x28, 0x95, 0x33, 0xe2, 0xb2, 0xa3, 0x9f,
	0x4c, 0xba, 0x9c, 0x91, 0x96, 0x1d, 0x3d, 0x1b, 0xb7, 0x95, 0xc4, 0x3d, 0x33, 0x25, 0x6e, 0xe5,
	0xc4, 0x71, 0x2b, 0xd9, 0xb8, 0x95, 0x38, 0xee, 0xcb, 0xa1, 0x30, 0xba, 0xee, 0x27, 0xbf, 0x13,
	0xe0, 0x0d, 0xf0, 0x7f, 0x6d, 0xfb, 0x8e, 0xba, 0xb1, 0x25, 0x77, 0x3b, 0x77, 0x5a, 0x72, 0x57,
	0xdb, 0xde, 0xd8, 0xde, 0xd1, 0xba, 0xea, 0x4e, 0xa7, 0xd3, 0xee, 0x6c, 0x95, 0x73, 0xd5, 0xd5,
	0x83, 0xc3, 0x7a, 0x65, 0xf2, 0xf7, 0xc5, 0xc0, 0x71, 0x4c, 0xc7, 0x78, 0x19, 0xbc, 0x25, 0x2b,
	0xf2, 0xb6, 0xdc, 0x2a, 0x0b, 0x2f, 0x81, 0xb7, 0xb0, 0x85, 0x09, 0xd6, 0xa1, 0x0c, 0xa4, 0x69,
	0xf0, 0x9d, 0xce, 0xc6, 0xdd, 0x8d, 0xb6, 0xb2, 0xd1, 0x54, 0xe4, 0x72, 0xbe, 0x5a, 0x3f, 0x38,
	0xac, 0xaf, 0x4e, 0x50, 0xec, 0x38, 0xe8, 0x01, 0x32, 0x2d, 0xd4, 0xb3, 0x70, 0x55, 0x7c, 0xfc,
	0x63, 0x2d, 0x77, 0xf9, 0xfb, 0x3c, 0x58, 0x1a, 0xbb, 0x54, 0xc3, 0x2b, 0x60, 0x59, 0xd1, 0x26,
	0x83, 0xaa, 0x1e, 0x1c, 0xd6, 0xcf, 0x8f, 0x5f, 0xc0, 0x79, 0x48, 0x19, 0x88, 0x26, 0x6f, 0x28,
	0x14, 0x22, 0x4c, 0x85, 0x68, 0x18, 0x59, 0x14, 0xd2, 0x00, 0xe5, 0x2c, 0x44, 0x6e, 0x95, 0xf3,
	0xd5, 0xff, 0x1d, 0x1c, 0xd6, 0xcf, 0x4d, 0x41, 0x60, 0x3d, 0xab, 0x11, 0x27, 0xab, 0x30, 0x55,
	0x23, 0x4e, 0xd5, 0x55, 0x70, 0x36, 0x81, 0xec, 0x74, 0xe2, 0x8d, 0x89, 0x51, 0x86, 0xc7, 0x40,
	0x3b, 0x4e, 0x10, 0x6d, 0x8d, 0xa7, 0xe6, 0x21, 0x28, 0xa6, 0x2e, 0x86, 0xf0, 0x1d, 0xb0, 0xb2,
	0x7d, 0xe7, 0xa3, 0xf6, 0xe6, 0x64, 0x62, 0xce, 0x1f, 0x1c, 0xd6, 0x61, 0x6a, 0x69, 0x9c, 0x94,
	0x71, 0x44, 0x52, 0xe0, 0x71, 0x04, 0xdf, 0x6f, 0x24, 0xdc, 0xbc, 0xf5, 0x74, 0x58, 0x13, 0x9e,
	0x0d, 0x6b, 0xc2, 0x77, 0x47, 0xb5, 0xdc, 0x93, 0xa3, 0x9a, 0xf0, 0xec, 0xa8, 0x96, 0xfb, 0xed,
	0xa8, 0x96, 0xbb, 0xff, 0xb7, 0x5c, 0x9d, 0xf9, 0xe7, 0x49, 0x6f, 0x96, 0x8d, 0xdf, 0xfd, 0x33,
	0x00, 0x00, 0xff, 0xff, 0x9e, 0x57, 0x2e, 0x16, 0x55, 0x11, 0x00, 0x00,
}

func (this *MetadataDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MetadataDescriptor)
	if !ok {
		that2, ok := that.(MetadataDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppliedIndex != that1.AppliedIndex {
		return false
	}
	if len(this.StorageNodes) != len(that1.StorageNodes) {
		return false
	}
	for i := range this.StorageNodes {
		if !this.StorageNodes[i].Equal(that1.StorageNodes[i]) {
			return false
		}
	}
	if len(this.LogStreams) != len(that1.LogStreams) {
		return false
	}
	for i := range this.LogStreams {
		if !this.LogStreams[i].Equal(that1.LogStreams[i]) {
			return false
		}
	}
	if len(this.Topics) != len(that1.Topics) {
		return false
	}
	for i := range this.Topics {
		if !this.Topics[i].Equal(that1.Topics[i]) {
			return false
		}
	}
	return true
}
func (this *StorageNodeDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageNodeDescriptor)
	if !ok {
		that2, ok := that.(StorageNodeDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageNode.Equal(&that1.StorageNode) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Paths) != len(that1.Paths) {
		return false
	}
	for i := range this.Paths {
		if this.Paths[i] != that1.Paths[i] {
			return false
		}
	}
	return true
}
func (this *StorageDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageDescriptor)
	if !ok {
		that2, ok := that.(StorageDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	if this.Used != that1.Used {
		return false
	}
	if this.Total != that1.Total {
		return false
	}
	return true
}
func (this *LogStreamDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogStreamDescriptor)
	if !ok {
		that2, ok := that.(LogStreamDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TopicID != that1.TopicID {
		return false
	}
	if this.LogStreamID != that1.LogStreamID {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.Replicas) != len(that1.Replicas) {
		return false
	}
	for i := range this.Replicas {
		if !this.Replicas[i].Equal(that1.Replicas[i]) {
			return false
		}
	}
	if !this.Head.Equal(&that1.Head) {
		return false
	}
	if !this.Tail.Equal(&that1.Tail) {
		return false
	}
	return true
}
func (this *ReplicaDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ReplicaDescriptor)
	if !ok {
		that2, ok := that.(ReplicaDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageNodeID != that1.StorageNodeID {
		return false
	}
	if this.Path != that1.Path {
		return false
	}
	return true
}
func (this *TopicDescriptor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicDescriptor)
	if !ok {
		that2, ok := that.(TopicDescriptor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TopicID != that1.TopicID {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.LogStreams) != len(that1.LogStreams) {
		return false
	}
	for i := range this.LogStreams {
		if this.LogStreams[i] != that1.LogStreams[i] {
			return false
		}
	}
	return true
}
func (this *StorageNode) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageNode)
	if !ok {
		that2, ok := that.(StorageNode)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.StorageNodeID != that1.StorageNodeID {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	return true
}
func (this *TopicLogStream) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TopicLogStream)
	if !ok {
		that2, ok := that.(TopicLogStream)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TopicID != that1.TopicID {
		return false
	}
	if this.LogStreamID != that1.LogStreamID {
		return false
	}
	return true
}
func (this *LogStreamReplica) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogStreamReplica)
	if !ok {
		that2, ok := that.(LogStreamReplica)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageNode.Equal(&that1.StorageNode) {
		return false
	}
	if !this.TopicLogStream.Equal(&that1.TopicLogStream) {
		return false
	}
	return true
}
func (this *LogSequenceNumber) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogSequenceNumber)
	if !ok {
		that2, ok := that.(LogSequenceNumber)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LLSN != that1.LLSN {
		return false
	}
	if this.GLSN != that1.GLSN {
		return false
	}
	return true
}
func (this *LogEntryMeta) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogEntryMeta)
	if !ok {
		that2, ok := that.(LogEntryMeta)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TopicID != that1.TopicID {
		return false
	}
	if this.LogStreamID != that1.LogStreamID {
		return false
	}
	if this.GLSN != that1.GLSN {
		return false
	}
	if this.LLSN != that1.LLSN {
		return false
	}
	return true
}
func (this *LogEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LogEntry)
	if !ok {
		that2, ok := that.(LogEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.LogEntryMeta.Equal(&that1.LogEntryMeta) {
		return false
	}
	if !bytes.Equal(this.Data, that1.Data) {
		return false
	}
	return true
}
func (m *MetadataDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MetadataDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MetadataDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Topics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.StorageNodes) > 0 {
		for iNdEx := len(m.StorageNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StorageNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.AppliedIndex != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.AppliedIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StorageNodeDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageNodeDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageNodeDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Paths) > 0 {
		for iNdEx := len(m.Paths) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Paths[iNdEx])
			copy(dAtA[i:], m.Paths[iNdEx])
			i = encodeVarintMetadata(dAtA, i, uint64(len(m.Paths[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StorageDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Total != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Total))
		i--
		dAtA[i] = 0x18
	}
	if m.Used != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Used))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogStreamDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tail.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMetadata(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReplicaDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReplicaDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicDescriptor) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicDescriptor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LogStreams) > 0 {
		dAtA5 := make([]byte, len(m.LogStreams)*10)
		var j4 int
		for _, num1 := range m.LogStreams {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintMetadata(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0x1a
	}
	if m.Status != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StorageNode) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0x12
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TopicLogStream) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TopicLogStream) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TopicLogStream) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogStreamReplica) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogStreamReplica) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogStreamReplica) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.TopicLogStream.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *LogSequenceNumber) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogSequenceNumber) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogSequenceNumber) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GLSN != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.GLSN))
		i--
		dAtA[i] = 0x10
	}
	if m.LLSN != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LLSN))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogEntryMeta) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogEntryMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntryMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LLSN != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LLSN))
		i--
		dAtA[i] = 0x20
	}
	if m.GLSN != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.GLSN))
		i--
		dAtA[i] = 0x18
	}
	if m.LogStreamID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogEntry) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintMetadata(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.LogEntryMeta.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetadata(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CommitContext) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CommittedLLSNBegin != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.CommittedLLSNBegin))
		i--
		dAtA[i] = 0x28
	}
	if m.CommittedGLSNEnd != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.CommittedGLSNEnd))
		i--
		dAtA[i] = 0x20
	}
	if m.CommittedGLSNBegin != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.CommittedGLSNBegin))
		i--
		dAtA[i] = 0x18
	}
	if m.HighWatermark != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.HighWatermark))
		i--
		dAtA[i] = 0x10
	}
	if m.Version != 0 {
		i = encodeVarintMetadata(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetadata(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetadata(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MetadataDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppliedIndex != 0 {
		n += 1 + sovMetadata(uint64(m.AppliedIndex))
	}
	if len(m.StorageNodes) > 0 {
		for _, e := range m.StorageNodes {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	if len(m.Topics) > 0 {
		for _, e := range m.Topics {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	return n
}

func (m *StorageNodeDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StorageNode.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if len(m.Paths) > 0 {
		for _, s := range m.Paths {
			l = len(s)
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	return n
}

func (m *StorageDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	if m.Used != 0 {
		n += 1 + sovMetadata(uint64(m.Used))
	}
	if m.Total != 0 {
		n += 1 + sovMetadata(uint64(m.Total))
	}
	return n
}

func (m *LogStreamDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.ProtoSize()
			n += 1 + l + sovMetadata(uint64(l))
		}
	}
	l = m.Head.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	l = m.Tail.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	return n
}

func (m *ReplicaDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *TopicDescriptor) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	if m.Status != 0 {
		n += 1 + sovMetadata(uint64(m.Status))
	}
	if len(m.LogStreams) > 0 {
		l = 0
		for _, e := range m.LogStreams {
			l += sovMetadata(uint64(e))
		}
		n += 1 + sovMetadata(uint64(l)) + l
	}
	return n
}

func (m *StorageNode) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovMetadata(uint64(m.StorageNodeID))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *TopicLogStream) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	return n
}

func (m *LogStreamReplica) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StorageNode.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	l = m.TopicLogStream.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	return n
}

func (m *LogSequenceNumber) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LLSN != 0 {
		n += 1 + sovMetadata(uint64(m.LLSN))
	}
	if m.GLSN != 0 {
		n += 1 + sovMetadata(uint64(m.GLSN))
	}
	return n
}

func (m *LogEntryMeta) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovMetadata(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovMetadata(uint64(m.LogStreamID))
	}
	if m.GLSN != 0 {
		n += 1 + sovMetadata(uint64(m.GLSN))
	}
	if m.LLSN != 0 {
		n += 1 + sovMetadata(uint64(m.LLSN))
	}
	return n
}

func (m *LogEntry) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.LogEntryMeta.ProtoSize()
	n += 1 + l + sovMetadata(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMetadata(uint64(l))
	}
	return n
}

func (m *CommitContext) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovMetadata(uint64(m.Version))
	}
	if m.HighWatermark != 0 {
		n += 1 + sovMetadata(uint64(m.HighWatermark))
	}
	if m.CommittedGLSNBegin != 0 {
		n += 1 + sovMetadata(uint64(m.CommittedGLSNBegin))
	}
	if m.CommittedGLSNEnd != 0 {
		n += 1 + sovMetadata(uint64(m.CommittedGLSNEnd))
	}
	if m.CommittedLLSNBegin != 0 {
		n += 1 + sovMetadata(uint64(m.CommittedLLSNBegin))
	}
	return n
}

func sovMetadata(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetadata(x uint64) (n int) {
	return sovMetadata(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MetadataDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MetadataDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MetadataDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedIndex", wireType)
			}
			m.AppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppliedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageNodes = append(m.StorageNodes, &StorageNodeDescriptor{})
			if err := m.StorageNodes[len(m.StorageNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, &LogStreamDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, &TopicDescriptor{})
			if err := m.Topics[len(m.Topics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageNodeDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageNodeDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageNodeDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= StorageNodeStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Paths", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Paths = append(m.Paths, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Used", wireType)
			}
			m.Used = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Used |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Total |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogStreamDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= LogStreamStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &ReplicaDescriptor{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tail.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TopicStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LogStreams = append(m.LogStreams, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetadata
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMetadata
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMetadata
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LogStreams) == 0 {
					m.LogStreams = make([]github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetadata
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LogStreams = append(m.LogStreams, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StorageNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TopicLogStream) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TopicLogStream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TopicLogStream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogStreamReplica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogStreamReplica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogStreamReplica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicLogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TopicLogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogSequenceNumber) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogSequenceNumber: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogSequenceNumber: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLSN", wireType)
			}
			m.LLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LLSN |= github_daumkakao_com_varlog_varlog_pkg_types.LLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GLSN", wireType)
			}
			m.GLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GLSN |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntryMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntryMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntryMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GLSN", wireType)
			}
			m.GLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GLSN |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LLSN", wireType)
			}
			m.LLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LLSN |= github_daumkakao_com_varlog_varlog_pkg_types.LLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogEntryMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.LogEntryMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetadata
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetadata
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= github_daumkakao_com_varlog_varlog_pkg_types.Version(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighWatermark", wireType)
			}
			m.HighWatermark = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighWatermark |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedGLSNBegin", wireType)
			}
			m.CommittedGLSNBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedGLSNBegin |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedGLSNEnd", wireType)
			}
			m.CommittedGLSNEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedGLSNEnd |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedLLSNBegin", wireType)
			}
			m.CommittedLLSNBegin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedLLSNBegin |= github_daumkakao_com_varlog_varlog_pkg_types.LLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetadata(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetadata
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetadata(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetadata
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetadata
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetadata
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetadata
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetadata
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetadata        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetadata          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetadata = fmt.Errorf("proto: unexpected end of group")
)
