// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/mrpb/management.proto

package mrpb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	github_daumkakao_com_varlog_varlog_pkg_types "github.daumkakao.com/varlog/varlog/pkg/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AddPeerRequest struct {
	ClusterID            github_daumkakao_com_varlog_varlog_pkg_types.ClusterID `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.ClusterID" json:"cluster_id,omitempty"`
	NodeID               github_daumkakao_com_varlog_varlog_pkg_types.NodeID    `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"node_id,omitempty"`
	Url                  string                                                 `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                               `json:"-"`
	XXX_unrecognized     []byte                                                 `json:"-"`
	XXX_sizecache        int32                                                  `json:"-"`
}

func (m *AddPeerRequest) Reset()         { *m = AddPeerRequest{} }
func (m *AddPeerRequest) String() string { return proto.CompactTextString(m) }
func (*AddPeerRequest) ProtoMessage()    {}
func (*AddPeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{0}
}
func (m *AddPeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddPeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddPeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPeerRequest.Merge(m, src)
}
func (m *AddPeerRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddPeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddPeerRequest proto.InternalMessageInfo

func (m *AddPeerRequest) GetClusterID() github_daumkakao_com_varlog_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *AddPeerRequest) GetNodeID() github_daumkakao_com_varlog_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *AddPeerRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type RemovePeerRequest struct {
	ClusterID            github_daumkakao_com_varlog_varlog_pkg_types.ClusterID `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.ClusterID" json:"cluster_id,omitempty"`
	NodeID               github_daumkakao_com_varlog_varlog_pkg_types.NodeID    `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"node_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                               `json:"-"`
	XXX_unrecognized     []byte                                                 `json:"-"`
	XXX_sizecache        int32                                                  `json:"-"`
}

func (m *RemovePeerRequest) Reset()         { *m = RemovePeerRequest{} }
func (m *RemovePeerRequest) String() string { return proto.CompactTextString(m) }
func (*RemovePeerRequest) ProtoMessage()    {}
func (*RemovePeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{1}
}
func (m *RemovePeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemovePeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemovePeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemovePeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePeerRequest.Merge(m, src)
}
func (m *RemovePeerRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemovePeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePeerRequest proto.InternalMessageInfo

func (m *RemovePeerRequest) GetClusterID() github_daumkakao_com_varlog_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *RemovePeerRequest) GetNodeID() github_daumkakao_com_varlog_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

type GetClusterInfoRequest struct {
	ClusterID            github_daumkakao_com_varlog_varlog_pkg_types.ClusterID `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.ClusterID" json:"cluster_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                               `json:"-"`
	XXX_unrecognized     []byte                                                 `json:"-"`
	XXX_sizecache        int32                                                  `json:"-"`
}

func (m *GetClusterInfoRequest) Reset()         { *m = GetClusterInfoRequest{} }
func (m *GetClusterInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetClusterInfoRequest) ProtoMessage()    {}
func (*GetClusterInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{2}
}
func (m *GetClusterInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoRequest.Merge(m, src)
}
func (m *GetClusterInfoRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetClusterInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoRequest proto.InternalMessageInfo

func (m *GetClusterInfoRequest) GetClusterID() github_daumkakao_com_varlog_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

type ClusterInfo struct {
	ClusterID            github_daumkakao_com_varlog_varlog_pkg_types.ClusterID                      `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.ClusterID" json:"cluster_id,omitempty"`
	NodeID               github_daumkakao_com_varlog_varlog_pkg_types.NodeID                         `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"node_id,omitempty"`
	Leader               github_daumkakao_com_varlog_varlog_pkg_types.NodeID                         `protobuf:"varint,3,opt,name=leader,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"leader,omitempty"`
	ReplicationFactor    int32                                                                       `protobuf:"varint,4,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	Members              map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]*ClusterInfo_Member `protobuf:"bytes,5,rep,name=members,proto3,castkey=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"members,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                                    `json:"-"`
	XXX_unrecognized     []byte                                                                      `json:"-"`
	XXX_sizecache        int32                                                                       `json:"-"`
}

func (m *ClusterInfo) Reset()         { *m = ClusterInfo{} }
func (m *ClusterInfo) String() string { return proto.CompactTextString(m) }
func (*ClusterInfo) ProtoMessage()    {}
func (*ClusterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{3}
}
func (m *ClusterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInfo.Merge(m, src)
}
func (m *ClusterInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInfo proto.InternalMessageInfo

func (m *ClusterInfo) GetClusterID() github_daumkakao_com_varlog_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *ClusterInfo) GetNodeID() github_daumkakao_com_varlog_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *ClusterInfo) GetLeader() github_daumkakao_com_varlog_varlog_pkg_types.NodeID {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *ClusterInfo) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *ClusterInfo) GetMembers() map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]*ClusterInfo_Member {
	if m != nil {
		return m.Members
	}
	return nil
}

type ClusterInfo_Member struct {
	Peer                 string   `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	Endpoint             string   `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Learner              bool     `protobuf:"varint,3,opt,name=learner,proto3" json:"learner,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClusterInfo_Member) Reset()         { *m = ClusterInfo_Member{} }
func (m *ClusterInfo_Member) String() string { return proto.CompactTextString(m) }
func (*ClusterInfo_Member) ProtoMessage()    {}
func (*ClusterInfo_Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{3, 0}
}
func (m *ClusterInfo_Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInfo_Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInfo_Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInfo_Member.Merge(m, src)
}
func (m *ClusterInfo_Member) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterInfo_Member) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInfo_Member proto.InternalMessageInfo

func (m *ClusterInfo_Member) GetPeer() string {
	if m != nil {
		return m.Peer
	}
	return ""
}

func (m *ClusterInfo_Member) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *ClusterInfo_Member) GetLearner() bool {
	if m != nil {
		return m.Learner
	}
	return false
}

type GetClusterInfoResponse struct {
	ClusterInfo          *ClusterInfo `protobuf:"bytes,1,opt,name=cluster_info,json=clusterInfo,proto3" json:"cluster_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *GetClusterInfoResponse) Reset()         { *m = GetClusterInfoResponse{} }
func (m *GetClusterInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetClusterInfoResponse) ProtoMessage()    {}
func (*GetClusterInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{4}
}
func (m *GetClusterInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoResponse.Merge(m, src)
}
func (m *GetClusterInfoResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetClusterInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoResponse proto.InternalMessageInfo

func (m *GetClusterInfoResponse) GetClusterInfo() *ClusterInfo {
	if m != nil {
		return m.ClusterInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*AddPeerRequest)(nil), "varlog.mrpb.AddPeerRequest")
	proto.RegisterType((*RemovePeerRequest)(nil), "varlog.mrpb.RemovePeerRequest")
	proto.RegisterType((*GetClusterInfoRequest)(nil), "varlog.mrpb.GetClusterInfoRequest")
	proto.RegisterType((*ClusterInfo)(nil), "varlog.mrpb.ClusterInfo")
	proto.RegisterMapType((map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]*ClusterInfo_Member)(nil), "varlog.mrpb.ClusterInfo.MembersEntry")
	proto.RegisterType((*ClusterInfo_Member)(nil), "varlog.mrpb.ClusterInfo.Member")
	proto.RegisterType((*GetClusterInfoResponse)(nil), "varlog.mrpb.GetClusterInfoResponse")
}

func init() { proto.RegisterFile("proto/mrpb/management.proto", fileDescriptor_8658321b298c6927) }

var fileDescriptor_8658321b298c6927 = []byte{
	// 592 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x55, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xee, 0xb6, 0x6e, 0xd2, 0x8c, 0x4b, 0x45, 0x57, 0xa2, 0xb2, 0x5c, 0x29, 0x89, 0x8c, 0x90,
	0x72, 0xa9, 0x23, 0xa5, 0x82, 0x22, 0x7a, 0xa1, 0x81, 0xb6, 0xea, 0xa1, 0x80, 0x56, 0xe2, 0xd2,
	0x1e, 0x2a, 0x27, 0x9e, 0x98, 0x28, 0xb6, 0xd7, 0xac, 0xd7, 0x11, 0x39, 0x21, 0xf1, 0x24, 0x3c,
	0x0e, 0x47, 0x6e, 0xdc, 0x82, 0x14, 0x24, 0x5e, 0x80, 0x1b, 0xe2, 0x80, 0xbc, 0x9b, 0x5f, 0x7e,
	0x0a, 0xf4, 0xc0, 0xa1, 0x27, 0xcf, 0xec, 0xcc, 0x7e, 0xdf, 0xcc, 0x78, 0xfc, 0x19, 0xb6, 0x13,
	0xc1, 0x25, 0xaf, 0x47, 0x22, 0x69, 0xd5, 0x23, 0x2f, 0xf6, 0x02, 0x8c, 0x30, 0x96, 0xae, 0x3a,
	0xa5, 0x66, 0xdf, 0x13, 0x21, 0x0f, 0xdc, 0x3c, 0x6a, 0xef, 0x04, 0x5d, 0xf9, 0x22, 0x6b, 0xb9,
	0x6d, 0x1e, 0xd5, 0x03, 0x1e, 0xf0, 0xba, 0xca, 0x69, 0x65, 0x1d, 0xe5, 0x69, 0x98, 0xdc, 0xd2,
	0x77, 0xed, 0xed, 0x80, 0xf3, 0x20, 0xc4, 0x59, 0x16, 0x46, 0x89, 0x1c, 0xe8, 0xa0, 0xf3, 0x99,
	0xc0, 0xc6, 0x81, 0xef, 0x3f, 0x43, 0x14, 0x0c, 0x5f, 0x66, 0x98, 0x4a, 0xda, 0x01, 0x68, 0x87,
	0x59, 0x2a, 0x51, 0x5c, 0x74, 0x7d, 0x8b, 0x54, 0x49, 0xed, 0x46, 0xf3, 0x78, 0x34, 0xac, 0x94,
	0x1e, 0xe9, 0xd3, 0x93, 0xc7, 0x5f, 0x87, 0x95, 0x7b, 0xe3, 0x1a, 0x7c, 0x2f, 0x8b, 0x7a, 0x5e,
	0xcf, 0xe3, 0xaa, 0x1a, 0x5d, 0xe5, 0xe4, 0x91, 0xf4, 0x82, 0xba, 0x1c, 0x24, 0x98, 0xba, 0xd3,
	0x9b, 0xac, 0x34, 0x86, 0x3e, 0xf1, 0xe9, 0x19, 0x14, 0x63, 0xee, 0x63, 0x4e, 0xb2, 0x5c, 0x25,
	0x35, 0xa3, 0x79, 0x30, 0x1a, 0x56, 0x0a, 0x4f, 0xb8, 0x8f, 0x8a, 0x61, 0xf7, 0x9f, 0x18, 0xf4,
	0x35, 0x56, 0xc8, 0x11, 0x4f, 0x7c, 0x7a, 0x13, 0x56, 0x32, 0x11, 0x5a, 0x2b, 0x55, 0x52, 0x2b,
	0xb1, 0xdc, 0x74, 0x3e, 0x10, 0xd8, 0x64, 0x18, 0xf1, 0x3e, 0x5e, 0xb3, 0x5e, 0x9d, 0xd7, 0x70,
	0xeb, 0x18, 0xe5, 0x84, 0x36, 0xee, 0xf0, 0xff, 0xdc, 0x9c, 0xf3, 0xcd, 0x00, 0x73, 0x8e, 0xfe,
	0x5a, 0x2c, 0xd0, 0x53, 0x28, 0x84, 0xe8, 0xf9, 0x28, 0xd4, 0x0e, 0x19, 0xcd, 0xbd, 0x2b, 0x03,
	0x6a, 0x18, 0xba, 0x03, 0x54, 0x60, 0x12, 0x76, 0xdb, 0x9e, 0xec, 0xf2, 0xf8, 0xa2, 0xe3, 0xb5,
	0x25, 0x17, 0x96, 0x51, 0x25, 0xb5, 0x55, 0xb6, 0x39, 0x17, 0x39, 0x52, 0x01, 0xfa, 0x0a, 0x8a,
	0x11, 0x46, 0x2d, 0x14, 0xa9, 0xb5, 0x5a, 0x5d, 0xa9, 0x99, 0x8d, 0x3b, 0xee, 0x9c, 0x04, 0xb8,
	0x73, 0xe3, 0x76, 0x4f, 0x75, 0xde, 0x61, 0x2c, 0xc5, 0xa0, 0xb9, 0xf7, 0xe6, 0xe3, 0xd5, 0xea,
	0x9c, 0xd0, 0xd9, 0x0c, 0x0a, 0x1a, 0x91, 0x52, 0x30, 0x12, 0x44, 0xa1, 0xde, 0x60, 0x89, 0x29,
	0x9b, 0xda, 0xb0, 0x86, 0xb1, 0x9f, 0xf0, 0x6e, 0x2c, 0xd5, 0xd0, 0x4b, 0x6c, 0xea, 0x53, 0x0b,
	0x8a, 0x21, 0x7a, 0x22, 0x1e, 0x0f, 0x6d, 0x8d, 0x4d, 0x5c, 0xfb, 0x1c, 0xd6, 0xe7, 0xab, 0xcc,
	0x3f, 0xcf, 0x1e, 0x0e, 0x14, 0xb0, 0xc1, 0x72, 0x93, 0xde, 0x85, 0xd5, 0xbe, 0x17, 0x66, 0xa8,
	0x40, 0xcd, 0x46, 0xe5, 0x0f, 0xdd, 0x32, 0x9d, 0xfd, 0x60, 0xf9, 0x3e, 0x71, 0x9e, 0xc3, 0xd6,
	0x8f, 0xfb, 0x9f, 0x26, 0x3c, 0x4e, 0x91, 0xee, 0xc3, 0xfa, 0x74, 0x11, 0xe3, 0x0e, 0x57, 0x7c,
	0x66, 0xc3, 0xfa, 0x1d, 0x36, 0x33, 0xdb, 0x33, 0xa7, 0xf1, 0x85, 0x00, 0x9c, 0x4e, 0x75, 0x98,
	0x3e, 0x84, 0xe2, 0x58, 0x27, 0xe9, 0xf6, 0x02, 0xc0, 0xa2, 0x7a, 0xda, 0x5b, 0xae, 0x96, 0x5b,
	0x77, 0x22, 0xb7, 0xee, 0x61, 0x2e, 0xb7, 0xce, 0x12, 0x3d, 0x02, 0x98, 0x09, 0x10, 0x2d, 0x2f,
	0x80, 0xfc, 0xa4, 0x4c, 0x97, 0xe0, 0x9c, 0xc3, 0xc6, 0x62, 0xbf, 0xd4, 0x59, 0xc0, 0xfa, 0xa5,
	0x18, 0xd8, 0xb7, 0x2f, 0xcd, 0xd1, 0x03, 0x73, 0x96, 0x9a, 0xfb, 0xef, 0x46, 0x65, 0xf2, 0x7e,
	0x54, 0x26, 0x6f, 0x3f, 0x95, 0xc9, 0xd9, 0xce, 0xdf, 0x6c, 0xd2, 0xf4, 0xb7, 0xd5, 0x2a, 0x28,
	0x7b, 0xf7, 0x7b, 0x00, 0x00, 0x00, 0xff, 0xff, 0xce, 0xcc, 0x1a, 0x25, 0xcb, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ManagementClient is the client API for Management service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ManagementClient interface {
	AddPeer(ctx context.Context, in *AddPeerRequest, opts ...grpc.CallOption) (*types.Empty, error)
	RemovePeer(ctx context.Context, in *RemovePeerRequest, opts ...grpc.CallOption) (*types.Empty, error)
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
}

type managementClient struct {
	cc *grpc.ClientConn
}

func NewManagementClient(cc *grpc.ClientConn) ManagementClient {
	return &managementClient{cc}
}

func (c *managementClient) AddPeer(ctx context.Context, in *AddPeerRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/varlog.mrpb.Management/AddPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementClient) RemovePeer(ctx context.Context, in *RemovePeerRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/varlog.mrpb.Management/RemovePeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/varlog.mrpb.Management/GetClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagementServer is the server API for Management service.
type ManagementServer interface {
	AddPeer(context.Context, *AddPeerRequest) (*types.Empty, error)
	RemovePeer(context.Context, *RemovePeerRequest) (*types.Empty, error)
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
}

// UnimplementedManagementServer can be embedded to have forward compatible implementations.
type UnimplementedManagementServer struct {
}

func (*UnimplementedManagementServer) AddPeer(ctx context.Context, req *AddPeerRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPeer not implemented")
}
func (*UnimplementedManagementServer) RemovePeer(ctx context.Context, req *RemovePeerRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePeer not implemented")
}
func (*UnimplementedManagementServer) GetClusterInfo(ctx context.Context, req *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}

func RegisterManagementServer(s *grpc.Server, srv ManagementServer) {
	s.RegisterService(&_Management_serviceDesc, srv)
}

func _Management_AddPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServer).AddPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.mrpb.Management/AddPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServer).AddPeer(ctx, req.(*AddPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Management_RemovePeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServer).RemovePeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.mrpb.Management/RemovePeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServer).RemovePeer(ctx, req.(*RemovePeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Management_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.mrpb.Management/GetClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Management_serviceDesc = grpc.ServiceDesc{
	ServiceName: "varlog.mrpb.Management",
	HandlerType: (*ManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddPeer",
			Handler:    _Management_AddPeer_Handler,
		},
		{
			MethodName: "RemovePeer",
			Handler:    _Management_RemovePeer_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _Management_GetClusterInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/mrpb/management.proto",
}

func (m *AddPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddPeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintManagement(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemovePeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemovePeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemovePeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NodeID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClusterID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Members) > 0 {
		for k := range m.Members {
			v := m.Members[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintManagement(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintManagement(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintManagement(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x20
	}
	if m.Leader != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x18
	}
	if m.NodeID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterInfo_Member) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInfo_Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInfo_Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Learner {
		i--
		if m.Learner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintManagement(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Peer) > 0 {
		i -= len(m.Peer)
		copy(dAtA[i:], m.Peer)
		i = encodeVarintManagement(dAtA, i, uint64(len(m.Peer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ClusterInfo != nil {
		{
			size, err := m.ClusterInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintManagement(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintManagement(dAtA []byte, offset int, v uint64) int {
	offset -= sovManagement(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AddPeerRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovManagement(uint64(m.ClusterID))
	}
	if m.NodeID != 0 {
		n += 1 + sovManagement(uint64(m.NodeID))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovManagement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemovePeerRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovManagement(uint64(m.ClusterID))
	}
	if m.NodeID != 0 {
		n += 1 + sovManagement(uint64(m.NodeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetClusterInfoRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovManagement(uint64(m.ClusterID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovManagement(uint64(m.ClusterID))
	}
	if m.NodeID != 0 {
		n += 1 + sovManagement(uint64(m.NodeID))
	}
	if m.Leader != 0 {
		n += 1 + sovManagement(uint64(m.Leader))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovManagement(uint64(m.ReplicationFactor))
	}
	if len(m.Members) > 0 {
		for k, v := range m.Members {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovManagement(uint64(l))
			}
			mapEntrySize := 1 + sovManagement(uint64(k)) + l
			n += mapEntrySize + 1 + sovManagement(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClusterInfo_Member) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Peer)
	if l > 0 {
		n += 1 + l + sovManagement(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovManagement(uint64(l))
	}
	if m.Learner {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetClusterInfoResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterInfo != nil {
		l = m.ClusterInfo.ProtoSize()
		n += 1 + l + sovManagement(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovManagement(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozManagement(x uint64) (n int) {
	return sovManagement(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_daumkakao_com_varlog_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_daumkakao_com_varlog_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemovePeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemovePeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemovePeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_daumkakao_com_varlog_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_daumkakao_com_varlog_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_daumkakao_com_varlog_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_daumkakao_com_varlog_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_daumkakao_com_varlog_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= github_daumkakao_com_varlog_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Members == nil {
				m.Members = make(map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]*ClusterInfo_Member)
			}
			var mapkey uint64
			var mapvalue *ClusterInfo_Member
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowManagement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowManagement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowManagement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthManagement
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthManagement
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ClusterInfo_Member{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipManagement(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthManagement
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Members[github_daumkakao_com_varlog_varlog_pkg_types.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInfo_Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learner = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterInfo == nil {
				m.ClusterInfo = &ClusterInfo{}
			}
			if err := m.ClusterInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipManagement(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthManagement
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupManagement
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthManagement
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthManagement        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowManagement          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupManagement = fmt.Errorf("proto: unexpected end of group")
)
