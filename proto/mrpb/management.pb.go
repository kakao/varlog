// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/mrpb/management.proto

package mrpb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	github_com_kakao_varlog_pkg_types "github.com/kakao/varlog/pkg/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// PeerInfo represents information about a RAFT peer.
type PeerInfo struct {
	// ClusterID is the identifier of the Varlog cluster.
	ClusterID github_com_kakao_varlog_pkg_types.ClusterID `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.com/kakao/varlog/pkg/types.ClusterID" json:"cluster_id,omitempty"`
	// NodeID is the identifier of the metadata repository node.
	NodeID github_com_kakao_varlog_pkg_types.NodeID `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.NodeID" json:"node_id,omitempty"`
	// URL is the RAFT endpoint of the metadata repository node.
	// It should be in the format of "http://<IP>:<Port>".
	URL string `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *PeerInfo) Reset()         { *m = PeerInfo{} }
func (m *PeerInfo) String() string { return proto.CompactTextString(m) }
func (*PeerInfo) ProtoMessage()    {}
func (*PeerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{0}
}
func (m *PeerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerInfo.Merge(m, src)
}
func (m *PeerInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *PeerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PeerInfo proto.InternalMessageInfo

func (m *PeerInfo) GetClusterID() github_com_kakao_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *PeerInfo) GetNodeID() github_com_kakao_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *PeerInfo) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

// AddPeerRequest is a request message for the AddPeer RPC.
type AddPeerRequest struct {
	ClusterID github_com_kakao_varlog_pkg_types.ClusterID `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.com/kakao/varlog/pkg/types.ClusterID" json:"cluster_id,omitempty"` // Deprecated: Do not use.
	NodeID    github_com_kakao_varlog_pkg_types.NodeID    `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.NodeID" json:"node_id,omitempty"`             // Deprecated: Do not use.
	Url       string                                      `protobuf:"bytes,3,opt,name=url,proto3" json:"url,omitempty"`                                                                                    // Deprecated: Do not use.
	Peer      PeerInfo                                    `protobuf:"bytes,4,opt,name=peer,proto3" json:"peer"`
}

func (m *AddPeerRequest) Reset()         { *m = AddPeerRequest{} }
func (m *AddPeerRequest) String() string { return proto.CompactTextString(m) }
func (*AddPeerRequest) ProtoMessage()    {}
func (*AddPeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{1}
}
func (m *AddPeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddPeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddPeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddPeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddPeerRequest.Merge(m, src)
}
func (m *AddPeerRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddPeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddPeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddPeerRequest proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *AddPeerRequest) GetClusterID() github_com_kakao_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

// Deprecated: Do not use.
func (m *AddPeerRequest) GetNodeID() github_com_kakao_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

// Deprecated: Do not use.
func (m *AddPeerRequest) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *AddPeerRequest) GetPeer() PeerInfo {
	if m != nil {
		return m.Peer
	}
	return PeerInfo{}
}

// RemovePeerRequest is a request message for RemovePeer RPC.
type RemovePeerRequest struct {
	ClusterID github_com_kakao_varlog_pkg_types.ClusterID `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.com/kakao/varlog/pkg/types.ClusterID" json:"cluster_id,omitempty"`
	NodeID    github_com_kakao_varlog_pkg_types.NodeID    `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.NodeID" json:"node_id,omitempty"`
}

func (m *RemovePeerRequest) Reset()         { *m = RemovePeerRequest{} }
func (m *RemovePeerRequest) String() string { return proto.CompactTextString(m) }
func (*RemovePeerRequest) ProtoMessage()    {}
func (*RemovePeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{2}
}
func (m *RemovePeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemovePeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemovePeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemovePeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemovePeerRequest.Merge(m, src)
}
func (m *RemovePeerRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemovePeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemovePeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemovePeerRequest proto.InternalMessageInfo

func (m *RemovePeerRequest) GetClusterID() github_com_kakao_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *RemovePeerRequest) GetNodeID() github_com_kakao_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

// GetClusterInfoRequest is a request message for GetClusterInfo RPC.
type GetClusterInfoRequest struct {
	ClusterID github_com_kakao_varlog_pkg_types.ClusterID `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.com/kakao/varlog/pkg/types.ClusterID" json:"cluster_id,omitempty"`
}

func (m *GetClusterInfoRequest) Reset()         { *m = GetClusterInfoRequest{} }
func (m *GetClusterInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetClusterInfoRequest) ProtoMessage()    {}
func (*GetClusterInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{3}
}
func (m *GetClusterInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoRequest.Merge(m, src)
}
func (m *GetClusterInfoRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetClusterInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoRequest proto.InternalMessageInfo

func (m *GetClusterInfoRequest) GetClusterID() github_com_kakao_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

// ClusterInfo is a metadata representing the Raft cluster.
type ClusterInfo struct {
	ClusterID         github_com_kakao_varlog_pkg_types.ClusterID                      `protobuf:"varint,1,opt,name=cluster_id,json=clusterId,proto3,casttype=github.com/kakao/varlog/pkg/types.ClusterID" json:"clusterId"`
	NodeID            github_com_kakao_varlog_pkg_types.NodeID                         `protobuf:"varint,2,opt,name=node_id,json=nodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.NodeID" json:"nodeId"`
	Leader            github_com_kakao_varlog_pkg_types.NodeID                         `protobuf:"varint,3,opt,name=leader,proto3,casttype=github.com/kakao/varlog/pkg/types.NodeID" json:"leader,omitempty"`
	ReplicationFactor int32                                                            `protobuf:"varint,4,opt,name=replication_factor,json=replicationFactor,proto3" json:"replicationFactor"`
	Members           map[github_com_kakao_varlog_pkg_types.NodeID]*ClusterInfo_Member `protobuf:"bytes,5,rep,name=members,proto3,castkey=github.com/kakao/varlog/pkg/types.NodeID" json:"members,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// applied_index is the AppliedIndex of RAFT that is updated by changing
	// configuration of members. For example, AddPeer and RemovePeer result in
	// increasing applied_index.
	AppliedIndex uint64 `protobuf:"varint,6,opt,name=applied_index,json=appliedIndex,proto3" json:"appliedIndex"`
}

func (m *ClusterInfo) Reset()         { *m = ClusterInfo{} }
func (m *ClusterInfo) String() string { return proto.CompactTextString(m) }
func (*ClusterInfo) ProtoMessage()    {}
func (*ClusterInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{4}
}
func (m *ClusterInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInfo.Merge(m, src)
}
func (m *ClusterInfo) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInfo proto.InternalMessageInfo

func (m *ClusterInfo) GetClusterID() github_com_kakao_varlog_pkg_types.ClusterID {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *ClusterInfo) GetNodeID() github_com_kakao_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *ClusterInfo) GetLeader() github_com_kakao_varlog_pkg_types.NodeID {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *ClusterInfo) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *ClusterInfo) GetMembers() map[github_com_kakao_varlog_pkg_types.NodeID]*ClusterInfo_Member {
	if m != nil {
		return m.Members
	}
	return nil
}

func (m *ClusterInfo) GetAppliedIndex() uint64 {
	if m != nil {
		return m.AppliedIndex
	}
	return 0
}

type ClusterInfo_Member struct {
	Peer     string `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Learner  bool   `protobuf:"varint,3,opt,name=learner,proto3" json:"learner,omitempty"`
}

func (m *ClusterInfo_Member) Reset()         { *m = ClusterInfo_Member{} }
func (m *ClusterInfo_Member) String() string { return proto.CompactTextString(m) }
func (*ClusterInfo_Member) ProtoMessage()    {}
func (*ClusterInfo_Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{4, 0}
}
func (m *ClusterInfo_Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterInfo_Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterInfo_Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterInfo_Member.Merge(m, src)
}
func (m *ClusterInfo_Member) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ClusterInfo_Member) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterInfo_Member proto.InternalMessageInfo

func (m *ClusterInfo_Member) GetPeer() string {
	if m != nil {
		return m.Peer
	}
	return ""
}

func (m *ClusterInfo_Member) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *ClusterInfo_Member) GetLearner() bool {
	if m != nil {
		return m.Learner
	}
	return false
}

// GetClusterInfoResponse is a response message for GetClusterInfo RPC.
type GetClusterInfoResponse struct {
	ClusterInfo *ClusterInfo `protobuf:"bytes,1,opt,name=cluster_info,json=clusterInfo,proto3" json:"cluster_info,omitempty"`
}

func (m *GetClusterInfoResponse) Reset()         { *m = GetClusterInfoResponse{} }
func (m *GetClusterInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetClusterInfoResponse) ProtoMessage()    {}
func (*GetClusterInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8658321b298c6927, []int{5}
}
func (m *GetClusterInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetClusterInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetClusterInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetClusterInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetClusterInfoResponse.Merge(m, src)
}
func (m *GetClusterInfoResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetClusterInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetClusterInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetClusterInfoResponse proto.InternalMessageInfo

func (m *GetClusterInfoResponse) GetClusterInfo() *ClusterInfo {
	if m != nil {
		return m.ClusterInfo
	}
	return nil
}

func init() {
	proto.RegisterType((*PeerInfo)(nil), "varlog.mrpb.PeerInfo")
	proto.RegisterType((*AddPeerRequest)(nil), "varlog.mrpb.AddPeerRequest")
	proto.RegisterType((*RemovePeerRequest)(nil), "varlog.mrpb.RemovePeerRequest")
	proto.RegisterType((*GetClusterInfoRequest)(nil), "varlog.mrpb.GetClusterInfoRequest")
	proto.RegisterType((*ClusterInfo)(nil), "varlog.mrpb.ClusterInfo")
	proto.RegisterMapType((map[github_com_kakao_varlog_pkg_types.NodeID]*ClusterInfo_Member)(nil), "varlog.mrpb.ClusterInfo.MembersEntry")
	proto.RegisterType((*ClusterInfo_Member)(nil), "varlog.mrpb.ClusterInfo.Member")
	proto.RegisterType((*GetClusterInfoResponse)(nil), "varlog.mrpb.GetClusterInfoResponse")
}

func init() { proto.RegisterFile("proto/mrpb/management.proto", fileDescriptor_8658321b298c6927) }

var fileDescriptor_8658321b298c6927 = []byte{
	// 737 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x55, 0xcb, 0x6a, 0xdb, 0x5c,
	0x10, 0xb6, 0x7c, 0x8d, 0xc7, 0xf9, 0x43, 0x72, 0xf8, 0x13, 0x54, 0x07, 0x2c, 0xa3, 0x52, 0x30,
	0x34, 0x95, 0xc0, 0x25, 0x25, 0xb4, 0xa1, 0xa4, 0x6a, 0x92, 0x62, 0x68, 0x7a, 0x39, 0x90, 0x45,
	0x1b, 0x4a, 0x90, 0xad, 0xb1, 0x62, 0x2c, 0xe9, 0xa8, 0xb2, 0x1c, 0xea, 0x6d, 0x77, 0xdd, 0xf5,
	0x11, 0xfa, 0x12, 0x7d, 0x80, 0xee, 0xb2, 0x0c, 0x74, 0xd3, 0x95, 0x0a, 0xf6, 0xce, 0xdb, 0xee,
	0xba, 0x2a, 0x92, 0x7c, 0x91, 0x72, 0x25, 0x09, 0x14, 0xba, 0xd3, 0x5c, 0xce, 0x37, 0xfa, 0xbe,
	0x33, 0x67, 0x06, 0x96, 0x6d, 0x87, 0xb9, 0x4c, 0x36, 0x1d, 0xbb, 0x2e, 0x9b, 0xaa, 0xa5, 0xea,
	0x68, 0xa2, 0xe5, 0x4a, 0x81, 0x97, 0x14, 0x0e, 0x55, 0xc7, 0x60, 0xba, 0xe4, 0x47, 0x8b, 0xf7,
	0xf4, 0x96, 0x7b, 0xd0, 0xad, 0x4b, 0x0d, 0x66, 0xca, 0x3a, 0xd3, 0x99, 0x1c, 0xe4, 0xd4, 0xbb,
	0xcd, 0xc0, 0x0a, 0x61, 0xfc, 0xaf, 0xf0, 0x6c, 0x71, 0x59, 0x67, 0x4c, 0x37, 0x70, 0x9a, 0x85,
	0xa6, 0xed, 0xf6, 0xc2, 0xa0, 0xf8, 0x9d, 0x83, 0x99, 0x57, 0x88, 0x4e, 0xcd, 0x6a, 0x32, 0xb2,
	0x07, 0xd0, 0x30, 0xba, 0x1d, 0x17, 0x9d, 0xfd, 0x96, 0xc6, 0x73, 0x65, 0xae, 0x92, 0x51, 0xd6,
	0xfb, 0x9e, 0x90, 0x7f, 0x1a, 0x7a, 0x6b, 0x9b, 0xbf, 0x3d, 0xe1, 0x6e, 0xa4, 0x7a, 0x5b, 0x6d,
	0xab, 0x4c, 0x0e, 0xff, 0x4d, 0xb6, 0xdb, 0xba, 0xec, 0xf6, 0x6c, 0xec, 0x48, 0x93, 0x74, 0x9a,
	0x1f, 0xe1, 0xd5, 0x34, 0xf2, 0x12, 0x72, 0x16, 0xd3, 0xd0, 0x47, 0x4e, 0x96, 0xb9, 0x4a, 0x5a,
	0x79, 0xd0, 0xf7, 0x84, 0xec, 0x0b, 0xa6, 0x61, 0x00, 0x5b, 0xb9, 0x1c, 0x36, 0xcc, 0xa5, 0x59,
	0x1f, 0xa6, 0xa6, 0x91, 0x5b, 0x90, 0xea, 0x3a, 0x06, 0x9f, 0x2a, 0x73, 0x95, 0xbc, 0x92, 0xeb,
	0x7b, 0x42, 0x6a, 0x97, 0x3e, 0xa7, 0xbe, 0x4f, 0xfc, 0x94, 0x84, 0xb9, 0x27, 0x9a, 0xe6, 0x13,
	0xa3, 0xf8, 0xbe, 0x8b, 0x1d, 0x97, 0xbc, 0x3b, 0x83, 0xdb, 0xe3, 0x9b, 0x70, 0xe3, 0xb9, 0x28,
	0xbb, 0xd7, 0x27, 0xd9, 0xad, 0x5d, 0x8f, 0x1d, 0xcf, 0x4d, 0xf8, 0xfd, 0x1f, 0xe5, 0x97, 0xe4,
	0xb9, 0x80, 0x1a, 0x91, 0x21, 0x6d, 0x23, 0x3a, 0x7c, 0xba, 0xcc, 0x55, 0x0a, 0xd5, 0x45, 0x29,
	0xd2, 0x18, 0xd2, 0xf8, 0x22, 0x95, 0xf4, 0x91, 0x27, 0x24, 0x68, 0x90, 0x28, 0x7e, 0xe3, 0x60,
	0x81, 0xa2, 0xc9, 0x0e, 0x31, 0x2a, 0xc7, 0x3f, 0x75, 0xd5, 0xa2, 0x0b, 0x8b, 0xcf, 0xd0, 0x1d,
	0xd7, 0xb2, 0x9a, 0xec, 0x6f, 0xd0, 0x10, 0xbf, 0x66, 0xa0, 0x10, 0xa9, 0x49, 0x0e, 0xce, 0x28,
	0x56, 0x8b, 0x15, 0x1b, 0x7a, 0xc2, 0xf4, 0xfc, 0x0d, 0x04, 0x7c, 0x73, 0x52, 0xc0, 0x8d, 0xa9,
	0x80, 0x43, 0x4f, 0x18, 0xc9, 0x72, 0xad, 0x57, 0xb3, 0x09, 0x59, 0x03, 0x55, 0x0d, 0x9d, 0xa0,
	0xb1, 0xd2, 0xca, 0xca, 0xd5, 0x50, 0xc2, 0xb3, 0x64, 0x13, 0x88, 0x83, 0xb6, 0xd1, 0x6a, 0xa8,
	0x6e, 0x8b, 0x59, 0xfb, 0x4d, 0xb5, 0xe1, 0xb2, 0xb0, 0x27, 0x33, 0xca, 0xe2, 0xd0, 0x13, 0x16,
	0x22, 0xd1, 0xed, 0x20, 0x48, 0x4f, 0xbb, 0x88, 0x09, 0x39, 0x13, 0xcd, 0x3a, 0x3a, 0x1d, 0x3e,
	0x53, 0x4e, 0x55, 0x0a, 0xd5, 0x3b, 0xb1, 0x76, 0x8e, 0x68, 0x2f, 0xed, 0x84, 0x79, 0x5b, 0x96,
	0xeb, 0xf4, 0x94, 0x95, 0x8f, 0x3f, 0xaf, 0xf0, 0xcf, 0xe3, 0x1a, 0x64, 0x15, 0xfe, 0x53, 0x6d,
	0xdb, 0x68, 0xa1, 0xb6, 0xdf, 0xb2, 0x34, 0xfc, 0xc0, 0x67, 0x03, 0x05, 0xe6, 0x87, 0x9e, 0x30,
	0x3b, 0x0a, 0xd4, 0x7c, 0x3f, 0x8d, 0x59, 0x45, 0x0a, 0xd9, 0xb0, 0x3a, 0x21, 0xa3, 0xb7, 0xe7,
	0x5f, 0x7d, 0x3e, 0x7c, 0x5e, 0xa4, 0x08, 0x33, 0x68, 0x69, 0x36, 0x6b, 0x59, 0x6e, 0x70, 0x57,
	0x79, 0x3a, 0xb1, 0x09, 0x0f, 0x39, 0x03, 0x55, 0xc7, 0x1a, 0x89, 0x3d, 0x43, 0xc7, 0x66, 0x71,
	0x0f, 0x66, 0xa3, 0x8c, 0xc8, 0x3c, 0xa4, 0xda, 0xd8, 0x0b, 0x80, 0xd3, 0xd4, 0xff, 0x24, 0xab,
	0x90, 0x39, 0x54, 0x8d, 0x2e, 0x06, 0xa0, 0x85, 0xaa, 0x70, 0x89, 0x32, 0x34, 0xcc, 0x7e, 0x98,
	0x5c, 0xe3, 0xc4, 0x5d, 0x58, 0x3a, 0xf9, 0x5a, 0x3a, 0x36, 0xb3, 0x3a, 0x48, 0x1e, 0xc1, 0xec,
	0xa4, 0x83, 0xad, 0x26, 0x0b, 0xea, 0x15, 0xaa, 0xfc, 0x79, 0xd8, 0xb4, 0xd0, 0x98, 0x1a, 0xd5,
	0x5f, 0x1c, 0xc0, 0xce, 0x64, 0x31, 0x91, 0x0d, 0xc8, 0x8d, 0x46, 0x2c, 0x59, 0x8e, 0x01, 0xc4,
	0x07, 0x6f, 0x71, 0x49, 0x0a, 0xf7, 0x8f, 0x34, 0xde, 0x3f, 0xd2, 0x96, 0xbf, 0x7f, 0xc4, 0x04,
	0xd9, 0x06, 0x98, 0x0e, 0x26, 0x52, 0x8a, 0x81, 0x9c, 0x9a, 0x58, 0x17, 0xe0, 0xec, 0xc1, 0x5c,
	0x9c, 0x2f, 0x11, 0x63, 0x58, 0x67, 0x8e, 0x8e, 0xe2, 0xed, 0x0b, 0x73, 0x42, 0xc1, 0xc4, 0x84,
	0xb2, 0x7e, 0xd4, 0x2f, 0x71, 0xc7, 0xfd, 0x12, 0xf7, 0x79, 0x50, 0x4a, 0x7c, 0x19, 0x94, 0xb8,
	0xe3, 0x41, 0x29, 0xf1, 0x63, 0x50, 0x4a, 0xbc, 0x15, 0xcf, 0xed, 0xc0, 0xc9, 0x22, 0xaf, 0x67,
	0x83, 0xef, 0xfb, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x2e, 0x00, 0x06, 0x96, 0xdd, 0x07, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ManagementClient is the client API for Management service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ManagementClient interface {
	// AddPeer adds a new node to the Raft cluster.
	//
	// It takes an AddPeerRequest as an argument and checks the validity of the
	// given Node ID. If the Node ID is invalid, it returns a gRPC status code
	// "InvalidArgument". If the node is already a member or learner, it returns a
	// gRPC status code "AlreadyExists". Upon successful execution, this operation
	// returns an instance of google.protobuf.Empty.
	//
	// Note that users can cancel this operation, but cancellation does not
	// guarantee that the addition of a new peer will not be handled.
	//
	// TODO: Implement a check for the cluster ID.
	AddPeer(ctx context.Context, in *AddPeerRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// RemovePeer removes a specific node from a Raft cluster.
	//
	// It takes a RemovePeerRequest as an argument and checks the validity of the
	// Node ID. If the Node ID is invalid, it returns a gRPC status code
	// "InvalidArgument". If the node is neither a member nor a learner in the
	// cluster, it returns a gRPC status code "NotFound". Upon successful
	// execution, this operation returns an instance of google.protobuf.Empty.
	//
	// Note that although users can cancel this operation, cancellation does not
	// guarantee that the node will not be removed.
	//
	// TODO: Implement a check for the cluster ID.
	RemovePeer(ctx context.Context, in *RemovePeerRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// GetClusterInfo is a remote procedure used to retrieve information about the
	// Raft cluster, specifically the ClusterInfo. If the current node is not a
	// member of the cluster, it will fail and return the gRPC status code
	// "codes.Unavailable".
	//
	// TODO: Check if the cluster ID is the same as the current node's. If they
	// are not the same, return a proper gRPC status code.
	//
	// TODO: Define ClusterInfo, which should contain the Raft cluster metadata.
	// Some fields will be removed due to unmatched semantics.
	GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error)
}

type managementClient struct {
	cc *grpc.ClientConn
}

func NewManagementClient(cc *grpc.ClientConn) ManagementClient {
	return &managementClient{cc}
}

func (c *managementClient) AddPeer(ctx context.Context, in *AddPeerRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/varlog.mrpb.Management/AddPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementClient) RemovePeer(ctx context.Context, in *RemovePeerRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/varlog.mrpb.Management/RemovePeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *managementClient) GetClusterInfo(ctx context.Context, in *GetClusterInfoRequest, opts ...grpc.CallOption) (*GetClusterInfoResponse, error) {
	out := new(GetClusterInfoResponse)
	err := c.cc.Invoke(ctx, "/varlog.mrpb.Management/GetClusterInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ManagementServer is the server API for Management service.
type ManagementServer interface {
	// AddPeer adds a new node to the Raft cluster.
	//
	// It takes an AddPeerRequest as an argument and checks the validity of the
	// given Node ID. If the Node ID is invalid, it returns a gRPC status code
	// "InvalidArgument". If the node is already a member or learner, it returns a
	// gRPC status code "AlreadyExists". Upon successful execution, this operation
	// returns an instance of google.protobuf.Empty.
	//
	// Note that users can cancel this operation, but cancellation does not
	// guarantee that the addition of a new peer will not be handled.
	//
	// TODO: Implement a check for the cluster ID.
	AddPeer(context.Context, *AddPeerRequest) (*types.Empty, error)
	// RemovePeer removes a specific node from a Raft cluster.
	//
	// It takes a RemovePeerRequest as an argument and checks the validity of the
	// Node ID. If the Node ID is invalid, it returns a gRPC status code
	// "InvalidArgument". If the node is neither a member nor a learner in the
	// cluster, it returns a gRPC status code "NotFound". Upon successful
	// execution, this operation returns an instance of google.protobuf.Empty.
	//
	// Note that although users can cancel this operation, cancellation does not
	// guarantee that the node will not be removed.
	//
	// TODO: Implement a check for the cluster ID.
	RemovePeer(context.Context, *RemovePeerRequest) (*types.Empty, error)
	// GetClusterInfo is a remote procedure used to retrieve information about the
	// Raft cluster, specifically the ClusterInfo. If the current node is not a
	// member of the cluster, it will fail and return the gRPC status code
	// "codes.Unavailable".
	//
	// TODO: Check if the cluster ID is the same as the current node's. If they
	// are not the same, return a proper gRPC status code.
	//
	// TODO: Define ClusterInfo, which should contain the Raft cluster metadata.
	// Some fields will be removed due to unmatched semantics.
	GetClusterInfo(context.Context, *GetClusterInfoRequest) (*GetClusterInfoResponse, error)
}

// UnimplementedManagementServer can be embedded to have forward compatible implementations.
type UnimplementedManagementServer struct {
}

func (*UnimplementedManagementServer) AddPeer(ctx context.Context, req *AddPeerRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPeer not implemented")
}
func (*UnimplementedManagementServer) RemovePeer(ctx context.Context, req *RemovePeerRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePeer not implemented")
}
func (*UnimplementedManagementServer) GetClusterInfo(ctx context.Context, req *GetClusterInfoRequest) (*GetClusterInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetClusterInfo not implemented")
}

func RegisterManagementServer(s *grpc.Server, srv ManagementServer) {
	s.RegisterService(&_Management_serviceDesc, srv)
}

func _Management_AddPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServer).AddPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.mrpb.Management/AddPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServer).AddPeer(ctx, req.(*AddPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Management_RemovePeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServer).RemovePeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.mrpb.Management/RemovePeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServer).RemovePeer(ctx, req.(*RemovePeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Management_GetClusterInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClusterInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ManagementServer).GetClusterInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.mrpb.Management/GetClusterInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ManagementServer).GetClusterInfo(ctx, req.(*GetClusterInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Management_serviceDesc = grpc.ServiceDesc{
	ServiceName: "varlog.mrpb.Management",
	HandlerType: (*ManagementServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddPeer",
			Handler:    _Management_AddPeer_Handler,
		},
		{
			MethodName: "RemovePeer",
			Handler:    _Management_RemovePeer_Handler,
		},
		{
			MethodName: "GetClusterInfo",
			Handler:    _Management_GetClusterInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/mrpb/management.proto",
}

func (m *PeerInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintManagement(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddPeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintManagement(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintManagement(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NodeID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemovePeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemovePeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemovePeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterInfo) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AppliedIndex != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.AppliedIndex))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Members) > 0 {
		for k := range m.Members {
			v := m.Members[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintManagement(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintManagement(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintManagement(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x20
	}
	if m.Leader != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x18
	}
	if m.NodeID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ClusterID != 0 {
		i = encodeVarintManagement(dAtA, i, uint64(m.ClusterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ClusterInfo_Member) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterInfo_Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterInfo_Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Learner {
		i--
		if m.Learner {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintManagement(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Peer) > 0 {
		i -= len(m.Peer)
		copy(dAtA[i:], m.Peer)
		i = encodeVarintManagement(dAtA, i, uint64(len(m.Peer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetClusterInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetClusterInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetClusterInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClusterInfo != nil {
		{
			size, err := m.ClusterInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintManagement(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintManagement(dAtA []byte, offset int, v uint64) int {
	offset -= sovManagement(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PeerInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovManagement(uint64(m.ClusterID))
	}
	if m.NodeID != 0 {
		n += 1 + sovManagement(uint64(m.NodeID))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovManagement(uint64(l))
	}
	return n
}

func (m *AddPeerRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovManagement(uint64(m.ClusterID))
	}
	if m.NodeID != 0 {
		n += 1 + sovManagement(uint64(m.NodeID))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovManagement(uint64(l))
	}
	l = m.Peer.ProtoSize()
	n += 1 + l + sovManagement(uint64(l))
	return n
}

func (m *RemovePeerRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovManagement(uint64(m.ClusterID))
	}
	if m.NodeID != 0 {
		n += 1 + sovManagement(uint64(m.NodeID))
	}
	return n
}

func (m *GetClusterInfoRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovManagement(uint64(m.ClusterID))
	}
	return n
}

func (m *ClusterInfo) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovManagement(uint64(m.ClusterID))
	}
	if m.NodeID != 0 {
		n += 1 + sovManagement(uint64(m.NodeID))
	}
	if m.Leader != 0 {
		n += 1 + sovManagement(uint64(m.Leader))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovManagement(uint64(m.ReplicationFactor))
	}
	if len(m.Members) > 0 {
		for k, v := range m.Members {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.ProtoSize()
				l += 1 + sovManagement(uint64(l))
			}
			mapEntrySize := 1 + sovManagement(uint64(k)) + l
			n += mapEntrySize + 1 + sovManagement(uint64(mapEntrySize))
		}
	}
	if m.AppliedIndex != 0 {
		n += 1 + sovManagement(uint64(m.AppliedIndex))
	}
	return n
}

func (m *ClusterInfo_Member) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Peer)
	if l > 0 {
		n += 1 + l + sovManagement(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovManagement(uint64(l))
	}
	if m.Learner {
		n += 2
	}
	return n
}

func (m *GetClusterInfoResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterInfo != nil {
		l = m.ClusterInfo.ProtoSize()
		n += 1 + l + sovManagement(uint64(l))
	}
	return n
}

func sovManagement(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozManagement(x uint64) (n int) {
	return sovManagement(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PeerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_com_kakao_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_kakao_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_com_kakao_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_kakao_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemovePeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemovePeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemovePeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_com_kakao_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_kakao_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_com_kakao_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= github_com_kakao_varlog_pkg_types.ClusterID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_kakao_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= github_com_kakao_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Members == nil {
				m.Members = make(map[github_com_kakao_varlog_pkg_types.NodeID]*ClusterInfo_Member)
			}
			var mapkey uint64
			var mapvalue *ClusterInfo_Member
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowManagement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowManagement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowManagement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthManagement
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthManagement
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ClusterInfo_Member{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipManagement(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthManagement
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Members[github_com_kakao_varlog_pkg_types.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppliedIndex", wireType)
			}
			m.AppliedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppliedIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterInfo_Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learner", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Learner = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClusterInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClusterInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClusterInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthManagement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthManagement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClusterInfo == nil {
				m.ClusterInfo = &ClusterInfo{}
			}
			if err := m.ClusterInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipManagement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthManagement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipManagement(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowManagement
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowManagement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthManagement
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupManagement
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthManagement
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthManagement        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowManagement          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupManagement = fmt.Errorf("proto: unexpected end of group")
)
