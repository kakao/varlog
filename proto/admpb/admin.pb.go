// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/admpb/admin.proto

package admpb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"

	github_com_kakao_varlog_pkg_types "github.com/kakao/varlog/pkg/types"
	snpb "github.com/kakao/varlog/proto/snpb"
	varlogpb "github.com/kakao/varlog/proto/varlogpb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// StorageNodeMetadata represents the current status of the storage node.
type StorageNodeMetadata struct {
	snpb.StorageNodeMetadataDescriptor `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3,embedded=storage_node" json:""`
	// CreateTime is the time when the storage node is created and registered to
	// the metadata repository.
	CreateTime time.Time `protobuf:"bytes,2,opt,name=create_time,json=createTime,proto3,stdtime" json:"createTime"`
	// LastHeartbeatTime is the time when the admin server checked the liveness of
	// the storage node. A zero value indicates that the admin server does not
	// check the storage node. Typically, since the storage node is just
	// registered, the admin server does not know the field. It is also possible
	// that the admin server is just restarted.
	LastHeartbeatTime time.Time `protobuf:"bytes,3,opt,name=last_heartbeat_time,json=lastHeartbeatTime,proto3,stdtime" json:"lastHeartbeatTime"`
}

func (m *StorageNodeMetadata) Reset()         { *m = StorageNodeMetadata{} }
func (m *StorageNodeMetadata) String() string { return proto.CompactTextString(m) }
func (*StorageNodeMetadata) ProtoMessage()    {}
func (*StorageNodeMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{0}
}
func (m *StorageNodeMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StorageNodeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StorageNodeMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StorageNodeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageNodeMetadata.Merge(m, src)
}
func (m *StorageNodeMetadata) XXX_Size() int {
	return m.ProtoSize()
}
func (m *StorageNodeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageNodeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_StorageNodeMetadata proto.InternalMessageInfo

func (m *StorageNodeMetadata) GetCreateTime() time.Time {
	if m != nil {
		return m.CreateTime
	}
	return time.Time{}
}

func (m *StorageNodeMetadata) GetLastHeartbeatTime() time.Time {
	if m != nil {
		return m.LastHeartbeatTime
	}
	return time.Time{}
}

type GetStorageNodeRequest struct {
	StorageNodeID github_com_kakao_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
}

func (m *GetStorageNodeRequest) Reset()         { *m = GetStorageNodeRequest{} }
func (m *GetStorageNodeRequest) String() string { return proto.CompactTextString(m) }
func (*GetStorageNodeRequest) ProtoMessage()    {}
func (*GetStorageNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{1}
}
func (m *GetStorageNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStorageNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStorageNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStorageNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStorageNodeRequest.Merge(m, src)
}
func (m *GetStorageNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetStorageNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStorageNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetStorageNodeRequest proto.InternalMessageInfo

func (m *GetStorageNodeRequest) GetStorageNodeID() github_com_kakao_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

type GetStorageNodeResponse struct {
	// StorageNode registered to the cluster.
	StorageNode *StorageNodeMetadata `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3" json:"storageNode"`
}

func (m *GetStorageNodeResponse) Reset()         { *m = GetStorageNodeResponse{} }
func (m *GetStorageNodeResponse) String() string { return proto.CompactTextString(m) }
func (*GetStorageNodeResponse) ProtoMessage()    {}
func (*GetStorageNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{2}
}
func (m *GetStorageNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStorageNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStorageNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStorageNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStorageNodeResponse.Merge(m, src)
}
func (m *GetStorageNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetStorageNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStorageNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStorageNodeResponse proto.InternalMessageInfo

func (m *GetStorageNodeResponse) GetStorageNode() *StorageNodeMetadata {
	if m != nil {
		return m.StorageNode
	}
	return nil
}

type ListStorageNodesRequest struct {
}

func (m *ListStorageNodesRequest) Reset()         { *m = ListStorageNodesRequest{} }
func (m *ListStorageNodesRequest) String() string { return proto.CompactTextString(m) }
func (*ListStorageNodesRequest) ProtoMessage()    {}
func (*ListStorageNodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{3}
}
func (m *ListStorageNodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListStorageNodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListStorageNodesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListStorageNodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListStorageNodesRequest.Merge(m, src)
}
func (m *ListStorageNodesRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListStorageNodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListStorageNodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListStorageNodesRequest proto.InternalMessageInfo

type ListStorageNodesResponse struct {
	// StorageNodes registered to the cluster.
	StorageNodes []StorageNodeMetadata `protobuf:"bytes,1,rep,name=storage_nodes,json=storageNodes,proto3" json:"storageNodes"`
}

func (m *ListStorageNodesResponse) Reset()         { *m = ListStorageNodesResponse{} }
func (m *ListStorageNodesResponse) String() string { return proto.CompactTextString(m) }
func (*ListStorageNodesResponse) ProtoMessage()    {}
func (*ListStorageNodesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{4}
}
func (m *ListStorageNodesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListStorageNodesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListStorageNodesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListStorageNodesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListStorageNodesResponse.Merge(m, src)
}
func (m *ListStorageNodesResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListStorageNodesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListStorageNodesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListStorageNodesResponse proto.InternalMessageInfo

func (m *ListStorageNodesResponse) GetStorageNodes() []StorageNodeMetadata {
	if m != nil {
		return m.StorageNodes
	}
	return nil
}

type AddStorageNodeRequest struct {
	StorageNode varlogpb.StorageNode `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3" json:"storage_node"`
}

func (m *AddStorageNodeRequest) Reset()         { *m = AddStorageNodeRequest{} }
func (m *AddStorageNodeRequest) String() string { return proto.CompactTextString(m) }
func (*AddStorageNodeRequest) ProtoMessage()    {}
func (*AddStorageNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{5}
}
func (m *AddStorageNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddStorageNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddStorageNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddStorageNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddStorageNodeRequest.Merge(m, src)
}
func (m *AddStorageNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddStorageNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddStorageNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddStorageNodeRequest proto.InternalMessageInfo

func (m *AddStorageNodeRequest) GetStorageNode() varlogpb.StorageNode {
	if m != nil {
		return m.StorageNode
	}
	return varlogpb.StorageNode{}
}

type AddStorageNodeResponse struct {
	StorageNode *StorageNodeMetadata `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3" json:"storageNode"`
}

func (m *AddStorageNodeResponse) Reset()         { *m = AddStorageNodeResponse{} }
func (m *AddStorageNodeResponse) String() string { return proto.CompactTextString(m) }
func (*AddStorageNodeResponse) ProtoMessage()    {}
func (*AddStorageNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{6}
}
func (m *AddStorageNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddStorageNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddStorageNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddStorageNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddStorageNodeResponse.Merge(m, src)
}
func (m *AddStorageNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddStorageNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddStorageNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddStorageNodeResponse proto.InternalMessageInfo

func (m *AddStorageNodeResponse) GetStorageNode() *StorageNodeMetadata {
	if m != nil {
		return m.StorageNode
	}
	return nil
}

type UnregisterStorageNodeRequest struct {
	StorageNodeID github_com_kakao_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
}

func (m *UnregisterStorageNodeRequest) Reset()         { *m = UnregisterStorageNodeRequest{} }
func (m *UnregisterStorageNodeRequest) String() string { return proto.CompactTextString(m) }
func (*UnregisterStorageNodeRequest) ProtoMessage()    {}
func (*UnregisterStorageNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{7}
}
func (m *UnregisterStorageNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterStorageNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterStorageNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterStorageNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterStorageNodeRequest.Merge(m, src)
}
func (m *UnregisterStorageNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterStorageNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterStorageNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterStorageNodeRequest proto.InternalMessageInfo

func (m *UnregisterStorageNodeRequest) GetStorageNodeID() github_com_kakao_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

type UnregisterStorageNodeResponse struct {
}

func (m *UnregisterStorageNodeResponse) Reset()         { *m = UnregisterStorageNodeResponse{} }
func (m *UnregisterStorageNodeResponse) String() string { return proto.CompactTextString(m) }
func (*UnregisterStorageNodeResponse) ProtoMessage()    {}
func (*UnregisterStorageNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{8}
}
func (m *UnregisterStorageNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterStorageNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterStorageNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterStorageNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterStorageNodeResponse.Merge(m, src)
}
func (m *UnregisterStorageNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterStorageNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterStorageNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterStorageNodeResponse proto.InternalMessageInfo

type GetTopicRequest struct {
	TopicID github_com_kakao_varlog_pkg_types.TopicID `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
}

func (m *GetTopicRequest) Reset()         { *m = GetTopicRequest{} }
func (m *GetTopicRequest) String() string { return proto.CompactTextString(m) }
func (*GetTopicRequest) ProtoMessage()    {}
func (*GetTopicRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{9}
}
func (m *GetTopicRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTopicRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTopicRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTopicRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTopicRequest.Merge(m, src)
}
func (m *GetTopicRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetTopicRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTopicRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetTopicRequest proto.InternalMessageInfo

func (m *GetTopicRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

type GetTopicResponse struct {
	Topic *varlogpb.TopicDescriptor `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic"`
}

func (m *GetTopicResponse) Reset()         { *m = GetTopicResponse{} }
func (m *GetTopicResponse) String() string { return proto.CompactTextString(m) }
func (*GetTopicResponse) ProtoMessage()    {}
func (*GetTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{10}
}
func (m *GetTopicResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetTopicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetTopicResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetTopicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetTopicResponse.Merge(m, src)
}
func (m *GetTopicResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetTopicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetTopicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetTopicResponse proto.InternalMessageInfo

func (m *GetTopicResponse) GetTopic() *varlogpb.TopicDescriptor {
	if m != nil {
		return m.Topic
	}
	return nil
}

type DescribeTopicRequest struct {
	TopicID github_com_kakao_varlog_pkg_types.TopicID `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
}

func (m *DescribeTopicRequest) Reset()         { *m = DescribeTopicRequest{} }
func (m *DescribeTopicRequest) String() string { return proto.CompactTextString(m) }
func (*DescribeTopicRequest) ProtoMessage()    {}
func (*DescribeTopicRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{11}
}
func (m *DescribeTopicRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescribeTopicRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DescribeTopicRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DescribeTopicRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeTopicRequest.Merge(m, src)
}
func (m *DescribeTopicRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DescribeTopicRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeTopicRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeTopicRequest proto.InternalMessageInfo

func (m *DescribeTopicRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

type DescribeTopicResponse struct {
	Topic      varlogpb.TopicDescriptor       `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic"`
	LogStreams []varlogpb.LogStreamDescriptor `protobuf:"bytes,2,rep,name=log_streams,json=logStreams,proto3" json:"log_streams"`
}

func (m *DescribeTopicResponse) Reset()         { *m = DescribeTopicResponse{} }
func (m *DescribeTopicResponse) String() string { return proto.CompactTextString(m) }
func (*DescribeTopicResponse) ProtoMessage()    {}
func (*DescribeTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{12}
}
func (m *DescribeTopicResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DescribeTopicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DescribeTopicResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DescribeTopicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DescribeTopicResponse.Merge(m, src)
}
func (m *DescribeTopicResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DescribeTopicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DescribeTopicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DescribeTopicResponse proto.InternalMessageInfo

func (m *DescribeTopicResponse) GetTopic() varlogpb.TopicDescriptor {
	if m != nil {
		return m.Topic
	}
	return varlogpb.TopicDescriptor{}
}

func (m *DescribeTopicResponse) GetLogStreams() []varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

type ListTopicsRequest struct {
}

func (m *ListTopicsRequest) Reset()         { *m = ListTopicsRequest{} }
func (m *ListTopicsRequest) String() string { return proto.CompactTextString(m) }
func (*ListTopicsRequest) ProtoMessage()    {}
func (*ListTopicsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{13}
}
func (m *ListTopicsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTopicsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTopicsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTopicsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTopicsRequest.Merge(m, src)
}
func (m *ListTopicsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListTopicsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTopicsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListTopicsRequest proto.InternalMessageInfo

type ListTopicsResponse struct {
	Topics []varlogpb.TopicDescriptor `protobuf:"bytes,1,rep,name=topics,proto3" json:"topics"`
}

func (m *ListTopicsResponse) Reset()         { *m = ListTopicsResponse{} }
func (m *ListTopicsResponse) String() string { return proto.CompactTextString(m) }
func (*ListTopicsResponse) ProtoMessage()    {}
func (*ListTopicsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{14}
}
func (m *ListTopicsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListTopicsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListTopicsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListTopicsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListTopicsResponse.Merge(m, src)
}
func (m *ListTopicsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListTopicsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListTopicsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListTopicsResponse proto.InternalMessageInfo

func (m *ListTopicsResponse) GetTopics() []varlogpb.TopicDescriptor {
	if m != nil {
		return m.Topics
	}
	return nil
}

// AddTopicRequest represents a request to add a topic to the cluster.
type AddTopicRequest struct {
}

func (m *AddTopicRequest) Reset()         { *m = AddTopicRequest{} }
func (m *AddTopicRequest) String() string { return proto.CompactTextString(m) }
func (*AddTopicRequest) ProtoMessage()    {}
func (*AddTopicRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{15}
}
func (m *AddTopicRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTopicRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTopicRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTopicRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTopicRequest.Merge(m, src)
}
func (m *AddTopicRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddTopicRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTopicRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddTopicRequest proto.InternalMessageInfo

// AddTopicResponse represents a response of AddTopicRequest.
type AddTopicResponse struct {
	Topic *varlogpb.TopicDescriptor `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic"`
}

func (m *AddTopicResponse) Reset()         { *m = AddTopicResponse{} }
func (m *AddTopicResponse) String() string { return proto.CompactTextString(m) }
func (*AddTopicResponse) ProtoMessage()    {}
func (*AddTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{16}
}
func (m *AddTopicResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTopicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTopicResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTopicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTopicResponse.Merge(m, src)
}
func (m *AddTopicResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddTopicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTopicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddTopicResponse proto.InternalMessageInfo

func (m *AddTopicResponse) GetTopic() *varlogpb.TopicDescriptor {
	if m != nil {
		return m.Topic
	}
	return nil
}

type UnregisterTopicRequest struct {
	TopicID github_com_kakao_varlog_pkg_types.TopicID `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
}

func (m *UnregisterTopicRequest) Reset()         { *m = UnregisterTopicRequest{} }
func (m *UnregisterTopicRequest) String() string { return proto.CompactTextString(m) }
func (*UnregisterTopicRequest) ProtoMessage()    {}
func (*UnregisterTopicRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{17}
}
func (m *UnregisterTopicRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterTopicRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterTopicRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterTopicRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterTopicRequest.Merge(m, src)
}
func (m *UnregisterTopicRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterTopicRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterTopicRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterTopicRequest proto.InternalMessageInfo

func (m *UnregisterTopicRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

type UnregisterTopicResponse struct {
}

func (m *UnregisterTopicResponse) Reset()         { *m = UnregisterTopicResponse{} }
func (m *UnregisterTopicResponse) String() string { return proto.CompactTextString(m) }
func (*UnregisterTopicResponse) ProtoMessage()    {}
func (*UnregisterTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{18}
}
func (m *UnregisterTopicResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterTopicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterTopicResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterTopicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterTopicResponse.Merge(m, src)
}
func (m *UnregisterTopicResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterTopicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterTopicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterTopicResponse proto.InternalMessageInfo

type GetLogStreamRequest struct {
	TopicID     github_com_kakao_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_com_kakao_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *GetLogStreamRequest) Reset()         { *m = GetLogStreamRequest{} }
func (m *GetLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*GetLogStreamRequest) ProtoMessage()    {}
func (*GetLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{19}
}
func (m *GetLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLogStreamRequest.Merge(m, src)
}
func (m *GetLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLogStreamRequest proto.InternalMessageInfo

func (m *GetLogStreamRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *GetLogStreamRequest) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type GetLogStreamResponse struct {
	LogStream *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"logStream"`
}

func (m *GetLogStreamResponse) Reset()         { *m = GetLogStreamResponse{} }
func (m *GetLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*GetLogStreamResponse) ProtoMessage()    {}
func (*GetLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{20}
}
func (m *GetLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLogStreamResponse.Merge(m, src)
}
func (m *GetLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetLogStreamResponse proto.InternalMessageInfo

func (m *GetLogStreamResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type ListLogStreamsRequest struct {
	TopicID github_com_kakao_varlog_pkg_types.TopicID `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
}

func (m *ListLogStreamsRequest) Reset()         { *m = ListLogStreamsRequest{} }
func (m *ListLogStreamsRequest) String() string { return proto.CompactTextString(m) }
func (*ListLogStreamsRequest) ProtoMessage()    {}
func (*ListLogStreamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{21}
}
func (m *ListLogStreamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListLogStreamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListLogStreamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListLogStreamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListLogStreamsRequest.Merge(m, src)
}
func (m *ListLogStreamsRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListLogStreamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListLogStreamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListLogStreamsRequest proto.InternalMessageInfo

func (m *ListLogStreamsRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

type ListLogStreamsResponse struct {
	LogStreams []varlogpb.LogStreamDescriptor `protobuf:"bytes,1,rep,name=log_streams,json=logStreams,proto3" json:"logStreams"`
}

func (m *ListLogStreamsResponse) Reset()         { *m = ListLogStreamsResponse{} }
func (m *ListLogStreamsResponse) String() string { return proto.CompactTextString(m) }
func (*ListLogStreamsResponse) ProtoMessage()    {}
func (*ListLogStreamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{22}
}
func (m *ListLogStreamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListLogStreamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListLogStreamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListLogStreamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListLogStreamsResponse.Merge(m, src)
}
func (m *ListLogStreamsResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListLogStreamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListLogStreamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListLogStreamsResponse proto.InternalMessageInfo

func (m *ListLogStreamsResponse) GetLogStreams() []varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

type AddLogStreamRequest struct {
	TopicID github_com_kakao_varlog_pkg_types.TopicID `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	// TODO: nullable = false
	Replicas []*varlogpb.ReplicaDescriptor `protobuf:"bytes,2,rep,name=replicas,proto3" json:"replicas,omitempty"`
}

func (m *AddLogStreamRequest) Reset()         { *m = AddLogStreamRequest{} }
func (m *AddLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*AddLogStreamRequest) ProtoMessage()    {}
func (*AddLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{23}
}
func (m *AddLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddLogStreamRequest.Merge(m, src)
}
func (m *AddLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddLogStreamRequest proto.InternalMessageInfo

func (m *AddLogStreamRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *AddLogStreamRequest) GetReplicas() []*varlogpb.ReplicaDescriptor {
	if m != nil {
		return m.Replicas
	}
	return nil
}

type AddLogStreamResponse struct {
	LogStream *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"log_stream,omitempty"`
}

func (m *AddLogStreamResponse) Reset()         { *m = AddLogStreamResponse{} }
func (m *AddLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*AddLogStreamResponse) ProtoMessage()    {}
func (*AddLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{24}
}
func (m *AddLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddLogStreamResponse.Merge(m, src)
}
func (m *AddLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddLogStreamResponse proto.InternalMessageInfo

func (m *AddLogStreamResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type UpdateLogStreamRequest struct {
	TopicID     github_com_kakao_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_com_kakao_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	//
	//// NOTE: popped_replica need not be varlog.ReplicaDescriptor, but it is
	//// natural. Though it is awkward, popped_storage_node_id is used here.
	//uint32 popped_storage_node_id = 2 [
	//(gogoproto.casttype) =
	//"github.com/kakao/varlog/pkg/types.StorageNodeID",
	//(gogoproto.customname) = "PoppedStorageNodeID"
	//];
	PoppedReplica varlogpb.ReplicaDescriptor `protobuf:"bytes,3,opt,name=popped_replica,json=poppedReplica,proto3" json:"popped_replica"`
	PushedReplica varlogpb.ReplicaDescriptor `protobuf:"bytes,4,opt,name=pushed_replica,json=pushedReplica,proto3" json:"pushed_replica"`
}

func (m *UpdateLogStreamRequest) Reset()         { *m = UpdateLogStreamRequest{} }
func (m *UpdateLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateLogStreamRequest) ProtoMessage()    {}
func (*UpdateLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{25}
}
func (m *UpdateLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLogStreamRequest.Merge(m, src)
}
func (m *UpdateLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLogStreamRequest proto.InternalMessageInfo

func (m *UpdateLogStreamRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *UpdateLogStreamRequest) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *UpdateLogStreamRequest) GetPoppedReplica() varlogpb.ReplicaDescriptor {
	if m != nil {
		return m.PoppedReplica
	}
	return varlogpb.ReplicaDescriptor{}
}

func (m *UpdateLogStreamRequest) GetPushedReplica() varlogpb.ReplicaDescriptor {
	if m != nil {
		return m.PushedReplica
	}
	return varlogpb.ReplicaDescriptor{}
}

type UpdateLogStreamResponse struct {
	LogStream *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"log_stream,omitempty"`
}

func (m *UpdateLogStreamResponse) Reset()         { *m = UpdateLogStreamResponse{} }
func (m *UpdateLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateLogStreamResponse) ProtoMessage()    {}
func (*UpdateLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{26}
}
func (m *UpdateLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLogStreamResponse.Merge(m, src)
}
func (m *UpdateLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLogStreamResponse proto.InternalMessageInfo

func (m *UpdateLogStreamResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type UnregisterLogStreamRequest struct {
	TopicID     github_com_kakao_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_com_kakao_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *UnregisterLogStreamRequest) Reset()         { *m = UnregisterLogStreamRequest{} }
func (m *UnregisterLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*UnregisterLogStreamRequest) ProtoMessage()    {}
func (*UnregisterLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{27}
}
func (m *UnregisterLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterLogStreamRequest.Merge(m, src)
}
func (m *UnregisterLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterLogStreamRequest proto.InternalMessageInfo

func (m *UnregisterLogStreamRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *UnregisterLogStreamRequest) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type UnregisterLogStreamResponse struct {
}

func (m *UnregisterLogStreamResponse) Reset()         { *m = UnregisterLogStreamResponse{} }
func (m *UnregisterLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*UnregisterLogStreamResponse) ProtoMessage()    {}
func (*UnregisterLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{28}
}
func (m *UnregisterLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterLogStreamResponse.Merge(m, src)
}
func (m *UnregisterLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterLogStreamResponse proto.InternalMessageInfo

type RemoveLogStreamReplicaRequest struct {
	StorageNodeID github_com_kakao_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	TopicID       github_com_kakao_varlog_pkg_types.TopicID       `protobuf:"varint,2,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID   github_com_kakao_varlog_pkg_types.LogStreamID   `protobuf:"varint,3,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *RemoveLogStreamReplicaRequest) Reset()         { *m = RemoveLogStreamReplicaRequest{} }
func (m *RemoveLogStreamReplicaRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveLogStreamReplicaRequest) ProtoMessage()    {}
func (*RemoveLogStreamReplicaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{29}
}
func (m *RemoveLogStreamReplicaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveLogStreamReplicaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveLogStreamReplicaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveLogStreamReplicaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveLogStreamReplicaRequest.Merge(m, src)
}
func (m *RemoveLogStreamReplicaRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveLogStreamReplicaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveLogStreamReplicaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveLogStreamReplicaRequest proto.InternalMessageInfo

func (m *RemoveLogStreamReplicaRequest) GetStorageNodeID() github_com_kakao_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *RemoveLogStreamReplicaRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *RemoveLogStreamReplicaRequest) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type RemoveLogStreamReplicaResponse struct {
}

func (m *RemoveLogStreamReplicaResponse) Reset()         { *m = RemoveLogStreamReplicaResponse{} }
func (m *RemoveLogStreamReplicaResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveLogStreamReplicaResponse) ProtoMessage()    {}
func (*RemoveLogStreamReplicaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{30}
}
func (m *RemoveLogStreamReplicaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveLogStreamReplicaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveLogStreamReplicaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveLogStreamReplicaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveLogStreamReplicaResponse.Merge(m, src)
}
func (m *RemoveLogStreamReplicaResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveLogStreamReplicaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveLogStreamReplicaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveLogStreamReplicaResponse proto.InternalMessageInfo

type SealRequest struct {
	TopicID     github_com_kakao_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_com_kakao_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *SealRequest) Reset()         { *m = SealRequest{} }
func (m *SealRequest) String() string { return proto.CompactTextString(m) }
func (*SealRequest) ProtoMessage()    {}
func (*SealRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{31}
}
func (m *SealRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealRequest.Merge(m, src)
}
func (m *SealRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SealRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SealRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SealRequest proto.InternalMessageInfo

func (m *SealRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *SealRequest) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type SealResponse struct {
	LogStreams []snpb.LogStreamReplicaMetadataDescriptor `protobuf:"bytes,1,rep,name=log_streams,json=logStreams,proto3" json:"logStreams"`
	SealedGLSN github_com_kakao_varlog_pkg_types.GLSN    `protobuf:"varint,2,opt,name=sealed_glsn,json=sealedGlsn,proto3,casttype=github.com/kakao/varlog/pkg/types.GLSN" json:"sealedGLSN"`
}

func (m *SealResponse) Reset()         { *m = SealResponse{} }
func (m *SealResponse) String() string { return proto.CompactTextString(m) }
func (*SealResponse) ProtoMessage()    {}
func (*SealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{32}
}
func (m *SealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealResponse.Merge(m, src)
}
func (m *SealResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SealResponse proto.InternalMessageInfo

func (m *SealResponse) GetLogStreams() []snpb.LogStreamReplicaMetadataDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

func (m *SealResponse) GetSealedGLSN() github_com_kakao_varlog_pkg_types.GLSN {
	if m != nil {
		return m.SealedGLSN
	}
	return 0
}

type UnsealRequest struct {
	TopicID     github_com_kakao_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_com_kakao_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *UnsealRequest) Reset()         { *m = UnsealRequest{} }
func (m *UnsealRequest) String() string { return proto.CompactTextString(m) }
func (*UnsealRequest) ProtoMessage()    {}
func (*UnsealRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{33}
}
func (m *UnsealRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsealRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsealRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsealRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsealRequest.Merge(m, src)
}
func (m *UnsealRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnsealRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsealRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnsealRequest proto.InternalMessageInfo

func (m *UnsealRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *UnsealRequest) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type UnsealResponse struct {
	LogStream *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"logStream"`
}

func (m *UnsealResponse) Reset()         { *m = UnsealResponse{} }
func (m *UnsealResponse) String() string { return proto.CompactTextString(m) }
func (*UnsealResponse) ProtoMessage()    {}
func (*UnsealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{34}
}
func (m *UnsealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsealResponse.Merge(m, src)
}
func (m *UnsealResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnsealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnsealResponse proto.InternalMessageInfo

func (m *UnsealResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type SyncRequest struct {
	TopicID          github_com_kakao_varlog_pkg_types.TopicID       `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID      github_com_kakao_varlog_pkg_types.LogStreamID   `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	SrcStorageNodeID github_com_kakao_varlog_pkg_types.StorageNodeID `protobuf:"varint,3,opt,name=src_storage_node_id,json=srcStorageNodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.StorageNodeID" json:"src_storage_node_id,omitempty"`
	DstStorageNodeID github_com_kakao_varlog_pkg_types.StorageNodeID `protobuf:"varint,4,opt,name=dst_storage_node_id,json=dstStorageNodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.StorageNodeID" json:"dst_storage_node_id,omitempty"`
}

func (m *SyncRequest) Reset()         { *m = SyncRequest{} }
func (m *SyncRequest) String() string { return proto.CompactTextString(m) }
func (*SyncRequest) ProtoMessage()    {}
func (*SyncRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{35}
}
func (m *SyncRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRequest.Merge(m, src)
}
func (m *SyncRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SyncRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRequest proto.InternalMessageInfo

func (m *SyncRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *SyncRequest) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *SyncRequest) GetSrcStorageNodeID() github_com_kakao_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.SrcStorageNodeID
	}
	return 0
}

func (m *SyncRequest) GetDstStorageNodeID() github_com_kakao_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.DstStorageNodeID
	}
	return 0
}

type SyncResponse struct {
	Status *snpb.SyncStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SyncResponse) Reset()         { *m = SyncResponse{} }
func (m *SyncResponse) String() string { return proto.CompactTextString(m) }
func (*SyncResponse) ProtoMessage()    {}
func (*SyncResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{36}
}
func (m *SyncResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncResponse.Merge(m, src)
}
func (m *SyncResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SyncResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncResponse proto.InternalMessageInfo

func (m *SyncResponse) GetStatus() *snpb.SyncStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type TrimRequest struct {
	TopicID  github_com_kakao_varlog_pkg_types.TopicID `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.com/kakao/varlog/pkg/types.TopicID" json:"topicId"`
	LastGLSN github_com_kakao_varlog_pkg_types.GLSN    `protobuf:"varint,2,opt,name=last_glsn,json=lastGlsn,proto3,casttype=github.com/kakao/varlog/pkg/types.GLSN" json:"lastGLSN"`
}

func (m *TrimRequest) Reset()         { *m = TrimRequest{} }
func (m *TrimRequest) String() string { return proto.CompactTextString(m) }
func (*TrimRequest) ProtoMessage()    {}
func (*TrimRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{37}
}
func (m *TrimRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrimRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrimRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrimRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrimRequest.Merge(m, src)
}
func (m *TrimRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TrimRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TrimRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TrimRequest proto.InternalMessageInfo

func (m *TrimRequest) GetTopicID() github_com_kakao_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *TrimRequest) GetLastGLSN() github_com_kakao_varlog_pkg_types.GLSN {
	if m != nil {
		return m.LastGLSN
	}
	return 0
}

type TrimResult struct {
	StorageNodeID github_com_kakao_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.StorageNodeID" json:"storageNodeId"`
	LogStreamID   github_com_kakao_varlog_pkg_types.LogStreamID   `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.com/kakao/varlog/pkg/types.LogStreamID" json:"logStreamId"`
	Error         string                                          `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *TrimResult) Reset()         { *m = TrimResult{} }
func (m *TrimResult) String() string { return proto.CompactTextString(m) }
func (*TrimResult) ProtoMessage()    {}
func (*TrimResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{38}
}
func (m *TrimResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrimResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrimResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrimResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrimResult.Merge(m, src)
}
func (m *TrimResult) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TrimResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TrimResult.DiscardUnknown(m)
}

var xxx_messageInfo_TrimResult proto.InternalMessageInfo

func (m *TrimResult) GetStorageNodeID() github_com_kakao_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *TrimResult) GetLogStreamID() github_com_kakao_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *TrimResult) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type TrimResponse struct {
	Results []TrimResult `protobuf:"bytes,1,rep,name=results,proto3" json:"results"`
}

func (m *TrimResponse) Reset()         { *m = TrimResponse{} }
func (m *TrimResponse) String() string { return proto.CompactTextString(m) }
func (*TrimResponse) ProtoMessage()    {}
func (*TrimResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{39}
}
func (m *TrimResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrimResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrimResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrimResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrimResponse.Merge(m, src)
}
func (m *TrimResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *TrimResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TrimResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TrimResponse proto.InternalMessageInfo

func (m *TrimResponse) GetResults() []TrimResult {
	if m != nil {
		return m.Results
	}
	return nil
}

type GetMetadataRepositoryNodeRequest struct {
	NodeID github_com_kakao_varlog_pkg_types.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.NodeID" json:"node_id,omitempty"`
}

func (m *GetMetadataRepositoryNodeRequest) Reset()         { *m = GetMetadataRepositoryNodeRequest{} }
func (m *GetMetadataRepositoryNodeRequest) String() string { return proto.CompactTextString(m) }
func (*GetMetadataRepositoryNodeRequest) ProtoMessage()    {}
func (*GetMetadataRepositoryNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{40}
}
func (m *GetMetadataRepositoryNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMetadataRepositoryNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMetadataRepositoryNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMetadataRepositoryNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMetadataRepositoryNodeRequest.Merge(m, src)
}
func (m *GetMetadataRepositoryNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetMetadataRepositoryNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMetadataRepositoryNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetMetadataRepositoryNodeRequest proto.InternalMessageInfo

func (m *GetMetadataRepositoryNodeRequest) GetNodeID() github_com_kakao_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

type GetMetadataRepositoryNodeResponse struct {
	Node *varlogpb.MetadataRepositoryNode `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
}

func (m *GetMetadataRepositoryNodeResponse) Reset()         { *m = GetMetadataRepositoryNodeResponse{} }
func (m *GetMetadataRepositoryNodeResponse) String() string { return proto.CompactTextString(m) }
func (*GetMetadataRepositoryNodeResponse) ProtoMessage()    {}
func (*GetMetadataRepositoryNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{41}
}
func (m *GetMetadataRepositoryNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMetadataRepositoryNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMetadataRepositoryNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMetadataRepositoryNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMetadataRepositoryNodeResponse.Merge(m, src)
}
func (m *GetMetadataRepositoryNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetMetadataRepositoryNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMetadataRepositoryNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMetadataRepositoryNodeResponse proto.InternalMessageInfo

func (m *GetMetadataRepositoryNodeResponse) GetNode() *varlogpb.MetadataRepositoryNode {
	if m != nil {
		return m.Node
	}
	return nil
}

type ListMetadataRepositoryNodesRequest struct {
}

func (m *ListMetadataRepositoryNodesRequest) Reset()         { *m = ListMetadataRepositoryNodesRequest{} }
func (m *ListMetadataRepositoryNodesRequest) String() string { return proto.CompactTextString(m) }
func (*ListMetadataRepositoryNodesRequest) ProtoMessage()    {}
func (*ListMetadataRepositoryNodesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{42}
}
func (m *ListMetadataRepositoryNodesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMetadataRepositoryNodesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMetadataRepositoryNodesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMetadataRepositoryNodesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMetadataRepositoryNodesRequest.Merge(m, src)
}
func (m *ListMetadataRepositoryNodesRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListMetadataRepositoryNodesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMetadataRepositoryNodesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListMetadataRepositoryNodesRequest proto.InternalMessageInfo

type ListMetadataRepositoryNodesResponse struct {
	Nodes []varlogpb.MetadataRepositoryNode `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes"`
}

func (m *ListMetadataRepositoryNodesResponse) Reset()         { *m = ListMetadataRepositoryNodesResponse{} }
func (m *ListMetadataRepositoryNodesResponse) String() string { return proto.CompactTextString(m) }
func (*ListMetadataRepositoryNodesResponse) ProtoMessage()    {}
func (*ListMetadataRepositoryNodesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{43}
}
func (m *ListMetadataRepositoryNodesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListMetadataRepositoryNodesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListMetadataRepositoryNodesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListMetadataRepositoryNodesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListMetadataRepositoryNodesResponse.Merge(m, src)
}
func (m *ListMetadataRepositoryNodesResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *ListMetadataRepositoryNodesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListMetadataRepositoryNodesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListMetadataRepositoryNodesResponse proto.InternalMessageInfo

func (m *ListMetadataRepositoryNodesResponse) GetNodes() []varlogpb.MetadataRepositoryNode {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type GetMRMembersResponse struct {
	Leader            github_com_kakao_varlog_pkg_types.NodeID            `protobuf:"varint,1,opt,name=leader,proto3,casttype=github.com/kakao/varlog/pkg/types.NodeID" json:"leader,omitempty"`
	ReplicationFactor int32                                               `protobuf:"varint,2,opt,name=replication_factor,json=replicationFactor,proto3" json:"replicationFactor,omitempty"`
	Members           map[github_com_kakao_varlog_pkg_types.NodeID]string `protobuf:"bytes,3,rep,name=members,proto3,castkey=github.com/kakao/varlog/pkg/types.NodeID" json:"members,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GetMRMembersResponse) Reset()         { *m = GetMRMembersResponse{} }
func (m *GetMRMembersResponse) String() string { return proto.CompactTextString(m) }
func (*GetMRMembersResponse) ProtoMessage()    {}
func (*GetMRMembersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{44}
}
func (m *GetMRMembersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMRMembersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMRMembersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMRMembersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMRMembersResponse.Merge(m, src)
}
func (m *GetMRMembersResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetMRMembersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMRMembersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMRMembersResponse proto.InternalMessageInfo

func (m *GetMRMembersResponse) GetLeader() github_com_kakao_varlog_pkg_types.NodeID {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *GetMRMembersResponse) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *GetMRMembersResponse) GetMembers() map[github_com_kakao_varlog_pkg_types.NodeID]string {
	if m != nil {
		return m.Members
	}
	return nil
}

type AddMetadataRepositoryNodeRequest struct {
	RaftURL string `protobuf:"bytes,1,opt,name=raft_url,json=raftUrl,proto3" json:"raft_url,omitempty"`
	RPCAddr string `protobuf:"bytes,2,opt,name=rpc_addr,json=rpcAddr,proto3" json:"rpc_addr,omitempty"`
}

func (m *AddMetadataRepositoryNodeRequest) Reset()         { *m = AddMetadataRepositoryNodeRequest{} }
func (m *AddMetadataRepositoryNodeRequest) String() string { return proto.CompactTextString(m) }
func (*AddMetadataRepositoryNodeRequest) ProtoMessage()    {}
func (*AddMetadataRepositoryNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{45}
}
func (m *AddMetadataRepositoryNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMetadataRepositoryNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMetadataRepositoryNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMetadataRepositoryNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMetadataRepositoryNodeRequest.Merge(m, src)
}
func (m *AddMetadataRepositoryNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddMetadataRepositoryNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMetadataRepositoryNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddMetadataRepositoryNodeRequest proto.InternalMessageInfo

func (m *AddMetadataRepositoryNodeRequest) GetRaftURL() string {
	if m != nil {
		return m.RaftURL
	}
	return ""
}

func (m *AddMetadataRepositoryNodeRequest) GetRPCAddr() string {
	if m != nil {
		return m.RPCAddr
	}
	return ""
}

type AddMetadataRepositoryNodeResponse struct {
	Node *varlogpb.MetadataRepositoryNode `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
}

func (m *AddMetadataRepositoryNodeResponse) Reset()         { *m = AddMetadataRepositoryNodeResponse{} }
func (m *AddMetadataRepositoryNodeResponse) String() string { return proto.CompactTextString(m) }
func (*AddMetadataRepositoryNodeResponse) ProtoMessage()    {}
func (*AddMetadataRepositoryNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{46}
}
func (m *AddMetadataRepositoryNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMetadataRepositoryNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMetadataRepositoryNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMetadataRepositoryNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMetadataRepositoryNodeResponse.Merge(m, src)
}
func (m *AddMetadataRepositoryNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddMetadataRepositoryNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMetadataRepositoryNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddMetadataRepositoryNodeResponse proto.InternalMessageInfo

func (m *AddMetadataRepositoryNodeResponse) GetNode() *varlogpb.MetadataRepositoryNode {
	if m != nil {
		return m.Node
	}
	return nil
}

type AddMRPeerRequest struct {
	RaftURL string `protobuf:"bytes,1,opt,name=raft_url,json=raftUrl,proto3" json:"raft_url,omitempty"`
	RPCAddr string `protobuf:"bytes,2,opt,name=rpc_addr,json=rpcAddr,proto3" json:"rpc_addr,omitempty"`
}

func (m *AddMRPeerRequest) Reset()         { *m = AddMRPeerRequest{} }
func (m *AddMRPeerRequest) String() string { return proto.CompactTextString(m) }
func (*AddMRPeerRequest) ProtoMessage()    {}
func (*AddMRPeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{47}
}
func (m *AddMRPeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMRPeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMRPeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMRPeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMRPeerRequest.Merge(m, src)
}
func (m *AddMRPeerRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddMRPeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMRPeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddMRPeerRequest proto.InternalMessageInfo

func (m *AddMRPeerRequest) GetRaftURL() string {
	if m != nil {
		return m.RaftURL
	}
	return ""
}

func (m *AddMRPeerRequest) GetRPCAddr() string {
	if m != nil {
		return m.RPCAddr
	}
	return ""
}

type AddMRPeerResponse struct {
	NodeID github_com_kakao_varlog_pkg_types.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.NodeID" json:"nodeId,omitempty"`
}

func (m *AddMRPeerResponse) Reset()         { *m = AddMRPeerResponse{} }
func (m *AddMRPeerResponse) String() string { return proto.CompactTextString(m) }
func (*AddMRPeerResponse) ProtoMessage()    {}
func (*AddMRPeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{48}
}
func (m *AddMRPeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMRPeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMRPeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMRPeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMRPeerResponse.Merge(m, src)
}
func (m *AddMRPeerResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddMRPeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMRPeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddMRPeerResponse proto.InternalMessageInfo

func (m *AddMRPeerResponse) GetNodeID() github_com_kakao_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

type DeleteMetadataRepositoryNodeRequest struct {
	NodeID github_com_kakao_varlog_pkg_types.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.com/kakao/varlog/pkg/types.NodeID" json:"nodeId"`
}

func (m *DeleteMetadataRepositoryNodeRequest) Reset()         { *m = DeleteMetadataRepositoryNodeRequest{} }
func (m *DeleteMetadataRepositoryNodeRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteMetadataRepositoryNodeRequest) ProtoMessage()    {}
func (*DeleteMetadataRepositoryNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{49}
}
func (m *DeleteMetadataRepositoryNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMetadataRepositoryNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMetadataRepositoryNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMetadataRepositoryNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMetadataRepositoryNodeRequest.Merge(m, src)
}
func (m *DeleteMetadataRepositoryNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeleteMetadataRepositoryNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMetadataRepositoryNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMetadataRepositoryNodeRequest proto.InternalMessageInfo

func (m *DeleteMetadataRepositoryNodeRequest) GetNodeID() github_com_kakao_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

type DeleteMetadataRepositoryNodeResponse struct {
}

func (m *DeleteMetadataRepositoryNodeResponse) Reset()         { *m = DeleteMetadataRepositoryNodeResponse{} }
func (m *DeleteMetadataRepositoryNodeResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteMetadataRepositoryNodeResponse) ProtoMessage()    {}
func (*DeleteMetadataRepositoryNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{50}
}
func (m *DeleteMetadataRepositoryNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteMetadataRepositoryNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteMetadataRepositoryNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteMetadataRepositoryNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteMetadataRepositoryNodeResponse.Merge(m, src)
}
func (m *DeleteMetadataRepositoryNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *DeleteMetadataRepositoryNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteMetadataRepositoryNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteMetadataRepositoryNodeResponse proto.InternalMessageInfo

type RemoveMRPeerRequest struct {
	RaftURL string `protobuf:"bytes,1,opt,name=raft_url,json=raftUrl,proto3" json:"raft_url,omitempty"`
}

func (m *RemoveMRPeerRequest) Reset()         { *m = RemoveMRPeerRequest{} }
func (m *RemoveMRPeerRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveMRPeerRequest) ProtoMessage()    {}
func (*RemoveMRPeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{51}
}
func (m *RemoveMRPeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveMRPeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveMRPeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveMRPeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveMRPeerRequest.Merge(m, src)
}
func (m *RemoveMRPeerRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveMRPeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveMRPeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveMRPeerRequest proto.InternalMessageInfo

func (m *RemoveMRPeerRequest) GetRaftURL() string {
	if m != nil {
		return m.RaftURL
	}
	return ""
}

type RemoveMRPeerResponse struct {
}

func (m *RemoveMRPeerResponse) Reset()         { *m = RemoveMRPeerResponse{} }
func (m *RemoveMRPeerResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveMRPeerResponse) ProtoMessage()    {}
func (*RemoveMRPeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_acd58c06882c23f8, []int{52}
}
func (m *RemoveMRPeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveMRPeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveMRPeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveMRPeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveMRPeerResponse.Merge(m, src)
}
func (m *RemoveMRPeerResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveMRPeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveMRPeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveMRPeerResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*StorageNodeMetadata)(nil), "varlog.admpb.StorageNodeMetadata")
	proto.RegisterType((*GetStorageNodeRequest)(nil), "varlog.admpb.GetStorageNodeRequest")
	proto.RegisterType((*GetStorageNodeResponse)(nil), "varlog.admpb.GetStorageNodeResponse")
	proto.RegisterType((*ListStorageNodesRequest)(nil), "varlog.admpb.ListStorageNodesRequest")
	proto.RegisterType((*ListStorageNodesResponse)(nil), "varlog.admpb.ListStorageNodesResponse")
	proto.RegisterType((*AddStorageNodeRequest)(nil), "varlog.admpb.AddStorageNodeRequest")
	proto.RegisterType((*AddStorageNodeResponse)(nil), "varlog.admpb.AddStorageNodeResponse")
	proto.RegisterType((*UnregisterStorageNodeRequest)(nil), "varlog.admpb.UnregisterStorageNodeRequest")
	proto.RegisterType((*UnregisterStorageNodeResponse)(nil), "varlog.admpb.UnregisterStorageNodeResponse")
	proto.RegisterType((*GetTopicRequest)(nil), "varlog.admpb.GetTopicRequest")
	proto.RegisterType((*GetTopicResponse)(nil), "varlog.admpb.GetTopicResponse")
	proto.RegisterType((*DescribeTopicRequest)(nil), "varlog.admpb.DescribeTopicRequest")
	proto.RegisterType((*DescribeTopicResponse)(nil), "varlog.admpb.DescribeTopicResponse")
	proto.RegisterType((*ListTopicsRequest)(nil), "varlog.admpb.ListTopicsRequest")
	proto.RegisterType((*ListTopicsResponse)(nil), "varlog.admpb.ListTopicsResponse")
	proto.RegisterType((*AddTopicRequest)(nil), "varlog.admpb.AddTopicRequest")
	proto.RegisterType((*AddTopicResponse)(nil), "varlog.admpb.AddTopicResponse")
	proto.RegisterType((*UnregisterTopicRequest)(nil), "varlog.admpb.UnregisterTopicRequest")
	proto.RegisterType((*UnregisterTopicResponse)(nil), "varlog.admpb.UnregisterTopicResponse")
	proto.RegisterType((*GetLogStreamRequest)(nil), "varlog.admpb.GetLogStreamRequest")
	proto.RegisterType((*GetLogStreamResponse)(nil), "varlog.admpb.GetLogStreamResponse")
	proto.RegisterType((*ListLogStreamsRequest)(nil), "varlog.admpb.ListLogStreamsRequest")
	proto.RegisterType((*ListLogStreamsResponse)(nil), "varlog.admpb.ListLogStreamsResponse")
	proto.RegisterType((*AddLogStreamRequest)(nil), "varlog.admpb.AddLogStreamRequest")
	proto.RegisterType((*AddLogStreamResponse)(nil), "varlog.admpb.AddLogStreamResponse")
	proto.RegisterType((*UpdateLogStreamRequest)(nil), "varlog.admpb.UpdateLogStreamRequest")
	proto.RegisterType((*UpdateLogStreamResponse)(nil), "varlog.admpb.UpdateLogStreamResponse")
	proto.RegisterType((*UnregisterLogStreamRequest)(nil), "varlog.admpb.UnregisterLogStreamRequest")
	proto.RegisterType((*UnregisterLogStreamResponse)(nil), "varlog.admpb.UnregisterLogStreamResponse")
	proto.RegisterType((*RemoveLogStreamReplicaRequest)(nil), "varlog.admpb.RemoveLogStreamReplicaRequest")
	proto.RegisterType((*RemoveLogStreamReplicaResponse)(nil), "varlog.admpb.RemoveLogStreamReplicaResponse")
	proto.RegisterType((*SealRequest)(nil), "varlog.admpb.SealRequest")
	proto.RegisterType((*SealResponse)(nil), "varlog.admpb.SealResponse")
	proto.RegisterType((*UnsealRequest)(nil), "varlog.admpb.UnsealRequest")
	proto.RegisterType((*UnsealResponse)(nil), "varlog.admpb.UnsealResponse")
	proto.RegisterType((*SyncRequest)(nil), "varlog.admpb.SyncRequest")
	proto.RegisterType((*SyncResponse)(nil), "varlog.admpb.SyncResponse")
	proto.RegisterType((*TrimRequest)(nil), "varlog.admpb.TrimRequest")
	proto.RegisterType((*TrimResult)(nil), "varlog.admpb.TrimResult")
	proto.RegisterType((*TrimResponse)(nil), "varlog.admpb.TrimResponse")
	proto.RegisterType((*GetMetadataRepositoryNodeRequest)(nil), "varlog.admpb.GetMetadataRepositoryNodeRequest")
	proto.RegisterType((*GetMetadataRepositoryNodeResponse)(nil), "varlog.admpb.GetMetadataRepositoryNodeResponse")
	proto.RegisterType((*ListMetadataRepositoryNodesRequest)(nil), "varlog.admpb.ListMetadataRepositoryNodesRequest")
	proto.RegisterType((*ListMetadataRepositoryNodesResponse)(nil), "varlog.admpb.ListMetadataRepositoryNodesResponse")
	proto.RegisterType((*GetMRMembersResponse)(nil), "varlog.admpb.GetMRMembersResponse")
	proto.RegisterMapType((map[github_com_kakao_varlog_pkg_types.NodeID]string)(nil), "varlog.admpb.GetMRMembersResponse.MembersEntry")
	proto.RegisterType((*AddMetadataRepositoryNodeRequest)(nil), "varlog.admpb.AddMetadataRepositoryNodeRequest")
	proto.RegisterType((*AddMetadataRepositoryNodeResponse)(nil), "varlog.admpb.AddMetadataRepositoryNodeResponse")
	proto.RegisterType((*AddMRPeerRequest)(nil), "varlog.admpb.AddMRPeerRequest")
	proto.RegisterType((*AddMRPeerResponse)(nil), "varlog.admpb.AddMRPeerResponse")
	proto.RegisterType((*DeleteMetadataRepositoryNodeRequest)(nil), "varlog.admpb.DeleteMetadataRepositoryNodeRequest")
	proto.RegisterType((*DeleteMetadataRepositoryNodeResponse)(nil), "varlog.admpb.DeleteMetadataRepositoryNodeResponse")
	proto.RegisterType((*RemoveMRPeerRequest)(nil), "varlog.admpb.RemoveMRPeerRequest")
	proto.RegisterType((*RemoveMRPeerResponse)(nil), "varlog.admpb.RemoveMRPeerResponse")
}

func init() { proto.RegisterFile("proto/admpb/admin.proto", fileDescriptor_acd58c06882c23f8) }

var fileDescriptor_acd58c06882c23f8 = []byte{
	// 2161 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x1a, 0x4b, 0x73, 0xdb, 0xc6,
	0x99, 0xa0, 0x64, 0x3d, 0x3e, 0xea, 0xe5, 0xa5, 0x5e, 0x86, 0x2c, 0x41, 0x81, 0x14, 0xd7, 0x4e,
	0x1d, 0xb2, 0x71, 0x67, 0x3a, 0x1e, 0xb7, 0x99, 0x44, 0xb4, 0x1c, 0xd9, 0x8d, 0x64, 0xa7, 0xa0,
	0x35, 0x9d, 0x24, 0x8d, 0x19, 0x90, 0x58, 0xd1, 0xac, 0x40, 0x02, 0xc5, 0x82, 0x6e, 0x74, 0x68,
	0xa7, 0xd3, 0x69, 0xa7, 0x97, 0x1e, 0xf2, 0x13, 0x32, 0xbd, 0xf6, 0xd2, 0x63, 0x0e, 0xfd, 0x01,
	0x9e, 0x1e, 0x3a, 0xbe, 0xb5, 0x97, 0x22, 0x53, 0xf9, 0xd2, 0xe1, 0xbd, 0x97, 0x9c, 0x3a, 0xd8,
	0x5d, 0x00, 0x8b, 0x07, 0x49, 0x49, 0xb1, 0x9a, 0x19, 0x5d, 0x44, 0x00, 0xfb, 0xbd, 0x5f, 0xfb,
	0xed, 0xb7, 0x82, 0x25, 0xdb, 0xb1, 0x5c, 0xab, 0xac, 0x1b, 0x6d, 0xbb, 0xee, 0xff, 0x6d, 0x75,
	0x4a, 0xf4, 0x0b, 0x9a, 0x7a, 0xa6, 0x3b, 0xa6, 0xd5, 0x2c, 0xd1, 0x15, 0xf9, 0xcd, 0x66, 0xcb,
	0x7d, 0xda, 0xad, 0x97, 0x1a, 0x56, 0xbb, 0xdc, 0xb4, 0x9a, 0x56, 0x99, 0x02, 0xd5, 0xbb, 0x07,
	0xf4, 0x8d, 0xd1, 0xf0, 0x9f, 0x18, 0xb2, 0xac, 0x34, 0x2d, 0xab, 0x69, 0xe2, 0x08, 0xca, 0x6d,
	0xb5, 0x31, 0x71, 0xf5, 0xb6, 0xcd, 0x01, 0x56, 0x92, 0x00, 0xb8, 0x6d, 0xbb, 0x47, 0x7c, 0x71,
	0x89, 0xb1, 0xb6, 0xeb, 0xe5, 0x36, 0x76, 0x75, 0x43, 0x77, 0x75, 0xbe, 0xb0, 0x40, 0x3a, 0x76,
	0xbd, 0xec, 0x60, 0xdb, 0x6c, 0x35, 0x74, 0xd7, 0x72, 0xf8, 0xe7, 0x22, 0xfd, 0x1c, 0x87, 0x55,
	0xbf, 0xcc, 0x43, 0xb1, 0xea, 0x5a, 0x8e, 0xde, 0xc4, 0x0f, 0x2d, 0x03, 0xef, 0xf1, 0x55, 0xf4,
	0x31, 0x4c, 0x11, 0xf6, 0xb9, 0xd6, 0xb1, 0x0c, 0xbc, 0x2c, 0xad, 0x4b, 0xd7, 0x0b, 0xb7, 0xde,
	0x28, 0x71, 0x75, 0x7d, 0x52, 0xa5, 0x0c, 0xbc, 0x6d, 0x4c, 0x1a, 0x4e, 0xcb, 0x76, 0x2d, 0xa7,
	0x32, 0xf5, 0xdc, 0x53, 0x72, 0x2f, 0x3c, 0x45, 0xea, 0x79, 0x4a, 0x4e, 0x2b, 0x90, 0x08, 0x18,
	0x55, 0xa1, 0xd0, 0x70, 0xb0, 0xee, 0xe2, 0x9a, 0xaf, 0xf0, 0x72, 0x9e, 0xd2, 0x96, 0x4b, 0x4c,
	0xd9, 0x52, 0xa0, 0x6c, 0xe9, 0x71, 0x60, 0x8d, 0xca, 0xa2, 0x4f, 0xab, 0xe7, 0x29, 0xc0, 0xd0,
	0xfc, 0x85, 0xcf, 0xbf, 0x52, 0x24, 0x4d, 0x78, 0x47, 0x2d, 0x28, 0x9a, 0x3a, 0x71, 0x6b, 0x4f,
	0xb1, 0xee, 0xb8, 0x75, 0xac, 0xbb, 0x8c, 0xf8, 0xc8, 0x50, 0xe2, 0xab, 0x9c, 0xf8, 0x65, 0x1f,
	0xfd, 0x7e, 0x80, 0x1d, 0xf2, 0x48, 0x7f, 0xbe, 0x33, 0xfa, 0x9f, 0x2f, 0x14, 0x49, 0xfd, 0xbd,
	0x04, 0x0b, 0x3b, 0xd8, 0x15, 0xac, 0xa0, 0xe1, 0x5f, 0x74, 0x31, 0x71, 0x91, 0x09, 0xb3, 0xa2,
	0xf1, 0x6a, 0x2d, 0x83, 0xda, 0xef, 0x52, 0x65, 0xfb, 0xd8, 0x53, 0xa6, 0x05, 0x84, 0x07, 0xdb,
	0x5f, 0x7b, 0x4a, 0x59, 0x08, 0x9a, 0x43, 0xfd, 0x50, 0xb7, 0xca, 0xcc, 0xc8, 0x65, 0xfb, 0xb0,
	0x59, 0x76, 0x8f, 0x6c, 0x4c, 0x4a, 0x31, 0x14, 0x6d, 0x5a, 0xb0, 0xe5, 0x03, 0x43, 0xb5, 0x60,
	0x31, 0x29, 0x06, 0xb1, 0xad, 0x0e, 0xc1, 0x68, 0x3f, 0xd3, 0x89, 0xaf, 0x95, 0xc4, 0x98, 0xcd,
	0xf2, 0x62, 0x65, 0xb6, 0xe7, 0x29, 0xa2, 0xc7, 0x62, 0xee, 0x53, 0xaf, 0xc0, 0xd2, 0x6e, 0x8b,
	0x88, 0x1c, 0x09, 0xd7, 0x5c, 0xfd, 0x0c, 0x96, 0xd3, 0x4b, 0x5c, 0x9a, 0x9f, 0xc1, 0xb4, 0x28,
	0x0d, 0x59, 0x96, 0xd6, 0x47, 0x4e, 0x26, 0xce, 0x3c, 0xf7, 0xd0, 0x14, 0x11, 0xe9, 0xc6, 0xde,
	0xd4, 0x27, 0xb0, 0xb0, 0x65, 0x18, 0x19, 0xce, 0xb8, 0x97, 0x69, 0x84, 0xab, 0x01, 0xd7, 0x20,
	0x89, 0x44, 0xc6, 0x95, 0xd1, 0xe7, 0xc9, 0x98, 0xf5, 0xad, 0x9c, 0xa4, 0x7f, 0xbe, 0x56, 0xfe,
	0xa3, 0x04, 0x57, 0xf7, 0x3b, 0x0e, 0x6e, 0xb6, 0x88, 0x8b, 0x9d, 0x6f, 0x3d, 0xca, 0x14, 0x58,
	0xed, 0x23, 0x0d, 0x33, 0x83, 0x7a, 0x00, 0xb3, 0x3b, 0xd8, 0x7d, 0x6c, 0xd9, 0xad, 0x46, 0x20,
	0x61, 0x15, 0x26, 0x5c, 0xff, 0x3d, 0x12, 0xed, 0xf6, 0xb1, 0xa7, 0x8c, 0x53, 0x18, 0x2a, 0xd4,
	0x8d, 0xe1, 0x42, 0x71, 0x60, 0x6d, 0x9c, 0x52, 0x7a, 0x60, 0xa8, 0xfb, 0x30, 0x17, 0xf1, 0xe1,
	0x2e, 0xd8, 0x82, 0x4b, 0x74, 0x99, 0xdb, 0x7e, 0x3d, 0xe5, 0x5c, 0x0a, 0x2e, 0x14, 0xa7, 0xc9,
	0x9e, 0xa7, 0x30, 0x14, 0x8d, 0xfd, 0xa8, 0x87, 0x30, 0xcf, 0xd6, 0xeb, 0xf8, 0xfc, 0x75, 0xf8,
	0x93, 0x04, 0x0b, 0x09, 0x6e, 0x5c, 0x93, 0x1f, 0x9d, 0x56, 0x13, 0x16, 0xaa, 0x0c, 0x09, 0xbd,
	0x0f, 0x05, 0xd3, 0x6a, 0xd6, 0x88, 0xeb, 0x60, 0xbd, 0x4d, 0x96, 0xf3, 0x34, 0xc1, 0x36, 0x53,
	0x34, 0x76, 0xad, 0x66, 0x95, 0x82, 0xa4, 0xe8, 0x80, 0x19, 0x2c, 0x11, 0xb5, 0x08, 0x97, 0xfd,
	0x5c, 0xa6, 0x0c, 0xc3, 0x04, 0x7f, 0x02, 0x48, 0xfc, 0xc8, 0xa5, 0xbe, 0x0f, 0x63, 0x54, 0x80,
	0x20, 0xa7, 0x87, 0x8b, 0x3d, 0xc3, 0x53, 0x9a, 0xe3, 0x69, 0xfc, 0x57, 0xbd, 0x0c, 0xb3, 0x5b,
	0x86, 0x21, 0x7a, 0xc0, 0x77, 0x78, 0xf4, 0xe9, 0xd5, 0x39, 0xbc, 0x0d, 0x8b, 0x51, 0x40, 0x9f,
	0xbf, 0xcb, 0xaf, 0xc0, 0x52, 0x8a, 0x1d, 0xcf, 0x9c, 0x17, 0x12, 0x14, 0x77, 0xb0, 0x1b, 0x7a,
	0xe5, 0x3c, 0xe5, 0x40, 0x06, 0x4c, 0x47, 0x21, 0xe2, 0x53, 0xce, 0x53, 0xca, 0xef, 0x1e, 0x7b,
	0x4a, 0x21, 0x94, 0x80, 0x52, 0x7f, 0x73, 0x38, 0x75, 0x01, 0x41, 0x2b, 0x84, 0xa1, 0xf3, 0xc0,
	0x50, 0x7f, 0x0e, 0xf3, 0x71, 0x8d, 0xb8, 0xdf, 0x34, 0x80, 0x88, 0x3b, 0x77, 0xde, 0xc9, 0xe2,
	0x73, 0xba, 0xe7, 0x29, 0x93, 0x21, 0x0b, 0x2d, 0x7a, 0x54, 0x4d, 0x58, 0xf0, 0x43, 0x32, 0x44,
	0x22, 0xe7, 0xea, 0x47, 0x02, 0x8b, 0x49, 0x6e, 0x5c, 0xb7, 0x0f, 0xe3, 0xc9, 0x27, 0x9d, 0x22,
	0xf9, 0x50, 0xd0, 0xdf, 0x44, 0xe9, 0x17, 0x4b, 0xc5, 0xbf, 0x48, 0x50, 0xdc, 0x32, 0x8c, 0xff,
	0x4f, 0x84, 0x6c, 0xc3, 0x04, 0xef, 0x1d, 0x83, 0x0a, 0xa2, 0xa6, 0x94, 0xd0, 0x18, 0x40, 0xa2,
	0x7e, 0x48, 0x5a, 0x88, 0xa9, 0x7e, 0x0c, 0xf3, 0x71, 0x89, 0xb9, 0x95, 0xee, 0x9e, 0x35, 0x02,
	0x44, 0x97, 0xff, 0x37, 0x0f, 0x8b, 0xfb, 0xb6, 0xa1, 0xbb, 0xf8, 0x02, 0x25, 0x0d, 0x7a, 0x04,
	0x33, 0xb6, 0x65, 0xdb, 0xd8, 0xa8, 0x71, 0x2b, 0xf2, 0xe6, 0xf5, 0xa4, 0xe6, 0xcf, 0x69, 0xd3,
	0x0c, 0x9f, 0x2f, 0x53, 0x82, 0x5d, 0xf2, 0x54, 0x20, 0x38, 0x7a, 0x6a, 0x82, 0x14, 0x9f, 0x2f,
	0xab, 0x4f, 0x60, 0x29, 0x65, 0xf6, 0x57, 0xe9, 0xd7, 0x7f, 0x48, 0x20, 0x47, 0x55, 0xf2, 0x22,
	0x15, 0xc4, 0x55, 0x58, 0xc9, 0x54, 0x8c, 0x6f, 0x01, 0xcf, 0xf3, 0xb0, 0xaa, 0xe1, 0xb6, 0xf5,
	0x4c, 0xb4, 0x2c, 0xb5, 0xf9, 0xb7, 0xd2, 0xed, 0xc5, 0x2c, 0x9d, 0x3f, 0x37, 0x4b, 0x8f, 0x9c,
	0x87, 0xa5, 0xd7, 0x61, 0xad, 0x9f, 0x25, 0x03, 0x63, 0x4b, 0x50, 0xa8, 0x62, 0xdd, 0xbc, 0x00,
	0x61, 0xf5, 0x2f, 0x09, 0xa6, 0x98, 0x2a, 0x3c, 0x0d, 0x8d, 0xac, 0x4d, 0xa8, 0x1c, 0x3b, 0xb6,
	0x27, 0xed, 0x92, 0x71, 0x76, 0x1f, 0xb2, 0x1f, 0xa1, 0x26, 0x14, 0x08, 0xd6, 0x4d, 0x6c, 0xd4,
	0x9a, 0x26, 0xe9, 0x50, 0xd5, 0x46, 0x2b, 0xef, 0x1d, 0x7b, 0x0a, 0x54, 0xe9, 0xe7, 0x9d, 0xdd,
	0xea, 0x43, 0x1f, 0x9d, 0x84, 0x6f, 0x5f, 0x7b, 0xca, 0xb5, 0xe1, 0x7a, 0xfa, 0x90, 0x5a, 0x80,
	0x65, 0x92, 0x8e, 0xfa, 0x37, 0x09, 0xa6, 0xf7, 0x3b, 0xe4, 0x62, 0x38, 0xcb, 0x80, 0x99, 0x40,
	0x97, 0x73, 0x6c, 0x87, 0xbe, 0x1c, 0x81, 0x42, 0xf5, 0xa8, 0xd3, 0xb8, 0x00, 0x1b, 0xe2, 0x33,
	0x28, 0x12, 0xa7, 0x51, 0x4b, 0xd6, 0x3d, 0x56, 0x36, 0x76, 0x8e, 0x3d, 0x65, 0xae, 0xea, 0x34,
	0xbe, 0x71, 0xe9, 0x9b, 0x23, 0x71, 0x22, 0x94, 0xaf, 0x41, 0xdc, 0x14, 0xdf, 0xd1, 0x88, 0xef,
	0x76, 0x6c, 0xc6, 0x71, 0x46, 0xbe, 0x46, 0x9c, 0x88, 0xa1, 0xbe, 0x03, 0x53, 0xcc, 0x73, 0x3c,
	0x3c, 0xca, 0x30, 0x46, 0x5c, 0xdd, 0xed, 0x12, 0x1e, 0x1a, 0x4b, 0xf1, 0xf1, 0xdb, 0x51, 0xa7,
	0x51, 0xa5, 0xcb, 0x1a, 0x07, 0x53, 0xff, 0x2e, 0x41, 0xe1, 0xb1, 0xd3, 0x0a, 0x37, 0xcc, 0x27,
	0x29, 0xdf, 0xdf, 0x15, 0x7c, 0xdf, 0xf3, 0x94, 0xc0, 0xa1, 0x67, 0x0c, 0x83, 0x1a, 0x4c, 0xd2,
	0x99, 0x9b, 0x50, 0x05, 0x2a, 0xc7, 0x9e, 0x32, 0xb1, 0xab, 0x13, 0x97, 0xd7, 0x80, 0x09, 0x93,
	0x3f, 0x9f, 0xa2, 0x02, 0x30, 0x1c, 0x3f, 0xff, 0xff, 0x9c, 0x07, 0x60, 0x0a, 0x91, 0xae, 0xe9,
	0xa2, 0x5f, 0xf5, 0xdb, 0x04, 0xf7, 0x53, 0x9b, 0x60, 0xcf, 0x53, 0xe2, 0x7b, 0xda, 0x2b, 0xd8,
	0x15, 0x49, 0x76, 0xd4, 0x3f, 0x4a, 0x44, 0x7d, 0xcf, 0x53, 0xc4, 0x30, 0xfe, 0x86, 0x49, 0x70,
	0x03, 0x2e, 0x61, 0xc7, 0xb1, 0x1c, 0x1a, 0xf6, 0x93, 0x95, 0x62, 0xcf, 0x53, 0x66, 0xe9, 0x87,
	0x9b, 0x56, 0xbb, 0xe5, 0xd2, 0x81, 0xb0, 0xc6, 0x20, 0xd4, 0xfb, 0x30, 0xc5, 0x8d, 0xc5, 0xe2,
	0xe7, 0x36, 0x8c, 0x3b, 0xd4, 0x70, 0xc1, 0x46, 0xb0, 0x1c, 0x1f, 0x4a, 0x45, 0x96, 0xe5, 0xed,
	0x5e, 0x00, 0xae, 0x12, 0x58, 0xdf, 0xc1, 0x6e, 0xb0, 0x33, 0x68, 0xd8, 0xb6, 0x48, 0xcb, 0xb5,
	0x9c, 0x23, 0x71, 0xfe, 0xf4, 0x08, 0xc6, 0x45, 0x27, 0x8c, 0x56, 0x7e, 0x70, 0xec, 0x29, 0x63,
	0x61, 0x3e, 0x5c, 0x1f, 0xae, 0x33, 0xb7, 0xf2, 0x58, 0x87, 0x85, 0xff, 0xa7, 0xf0, 0xda, 0x00,
	0xa6, 0x5c, 0xa7, 0x1f, 0xc2, 0xa8, 0x30, 0x65, 0xfb, 0x4e, 0xaa, 0x58, 0xf6, 0x41, 0xa7, 0x48,
	0xea, 0x26, 0xa8, 0xfe, 0xe1, 0x2d, 0x1b, 0x26, 0x9c, 0x71, 0x10, 0xd8, 0x18, 0x08, 0xc5, 0x25,
	0xd9, 0x85, 0x4b, 0xe2, 0x1c, 0xf3, 0xa4, 0xa2, 0x54, 0xa6, 0xf9, 0xe6, 0xca, 0xb0, 0x35, 0xf6,
	0xa3, 0xfe, 0x3b, 0x4f, 0x8f, 0xcc, 0x7b, 0xda, 0x1e, 0x6e, 0xd7, 0xb1, 0x13, 0xb1, 0xd9, 0x86,
	0x31, 0x13, 0xeb, 0x06, 0x76, 0xb8, 0x95, 0x6f, 0x9e, 0xce, 0xb6, 0x0c, 0x17, 0x3d, 0x04, 0x14,
	0x5c, 0x08, 0xb4, 0xac, 0x4e, 0xed, 0x40, 0x6f, 0xb8, 0x96, 0xc3, 0xe3, 0x57, 0xe9, 0x79, 0xca,
	0x8a, 0xb0, 0xfa, 0x1e, 0x5d, 0x14, 0xc2, 0xeb, 0x72, 0x6a, 0x11, 0xfd, 0x12, 0xc6, 0xdb, 0x4c,
	0xd0, 0xe5, 0x91, 0x78, 0x8f, 0xc1, 0x42, 0x2b, 0x4b, 0x95, 0x12, 0x7f, 0xbf, 0xd7, 0x71, 0x9d,
	0xa3, 0xca, 0xcd, 0xdf, 0x7e, 0x75, 0x0a, 0x3d, 0x02, 0x6e, 0xf2, 0x1d, 0x98, 0x12, 0xc9, 0xa0,
	0x39, 0x18, 0x39, 0xc4, 0x47, 0xcc, 0x36, 0x9a, 0xff, 0x88, 0xe6, 0xe1, 0xd2, 0x33, 0xdd, 0xec,
	0xb2, 0x7b, 0x85, 0x49, 0x8d, 0xbd, 0xdc, 0xc9, 0xdf, 0x96, 0x54, 0x07, 0xd6, 0xb7, 0x0c, 0x63,
	0x70, 0x54, 0x5f, 0x83, 0x09, 0x47, 0x3f, 0x70, 0x6b, 0x5d, 0xc7, 0xa4, 0x44, 0x27, 0x2b, 0x05,
	0xbf, 0x64, 0x6a, 0xfa, 0x81, 0xbb, 0xaf, 0xed, 0x6a, 0xe3, 0xfe, 0xe2, 0xbe, 0x63, 0x52, 0x38,
	0xbb, 0x51, 0xd3, 0x0d, 0x83, 0x99, 0x31, 0x80, 0xfb, 0xe0, 0xee, 0x96, 0x61, 0x38, 0xda, 0xb8,
	0x63, 0x37, 0xfc, 0x07, 0x3f, 0xa8, 0x07, 0xf0, 0x7c, 0x15, 0x41, 0x5d, 0xa7, 0xf3, 0xb1, 0x3d,
	0xed, 0x03, 0x8c, 0x9d, 0xf3, 0xd2, 0xe2, 0x33, 0xb8, 0x2c, 0xf0, 0xe0, 0x52, 0x37, 0x92, 0x05,
	0xe0, 0xc7, 0x51, 0x01, 0xe8, 0x79, 0xca, 0x1c, 0x4b, 0xeb, 0x28, 0x8e, 0xce, 0x54, 0x14, 0x7e,
	0x23, 0xc1, 0xc6, 0x36, 0x36, 0xb1, 0x8b, 0x07, 0xfb, 0xed, 0xc3, 0xa4, 0x30, 0xef, 0xc6, 0x84,
	0xe1, 0xe4, 0xce, 0x24, 0xc2, 0x35, 0xd8, 0x1c, 0x2c, 0x01, 0x3f, 0x57, 0xbc, 0x0d, 0x45, 0x76,
	0xf2, 0x38, 0x93, 0x2f, 0xd4, 0x45, 0x98, 0x8f, 0xa3, 0x33, 0xb2, 0xb7, 0xfe, 0x5a, 0x84, 0x99,
	0xbb, 0x66, 0xd7, 0x3f, 0x38, 0xee, 0xe9, 0x1d, 0xbd, 0x89, 0x1d, 0xf4, 0x09, 0xcc, 0xc4, 0xaf,
	0x7c, 0xd0, 0x46, 0x2a, 0xfd, 0xd2, 0x37, 0x06, 0xf2, 0xe6, 0x60, 0x20, 0xae, 0x46, 0x0e, 0x35,
	0x60, 0x2e, 0x79, 0x8b, 0x83, 0x5e, 0x8f, 0xe3, 0xf6, 0xb9, 0x00, 0x92, 0xaf, 0x0d, 0x03, 0x0b,
	0x99, 0x7c, 0x02, 0x33, 0xf1, 0x0b, 0x95, 0xa4, 0x0e, 0x99, 0xd7, 0x39, 0x49, 0x1d, 0xb2, 0xef,
	0x64, 0xd4, 0x1c, 0x72, 0x60, 0x21, 0xf3, 0xbe, 0x02, 0xbd, 0x11, 0x27, 0x30, 0xe8, 0x8a, 0x45,
	0xfe, 0xee, 0x89, 0x60, 0x43, 0x9e, 0xef, 0xc3, 0x44, 0x70, 0x35, 0x81, 0x56, 0x53, 0xb6, 0x16,
	0x67, 0xcc, 0xf2, 0x5a, 0xbf, 0xe5, 0x90, 0xd8, 0x47, 0x30, 0x1d, 0xbb, 0x22, 0x40, 0x6a, 0x1c,
	0x25, 0xeb, 0xb6, 0x42, 0xde, 0x18, 0x08, 0x13, 0xd2, 0xfe, 0x09, 0x40, 0x34, 0xc5, 0x47, 0x4a,
	0xda, 0x67, 0xb1, 0xa1, 0xbf, 0xbc, 0xde, 0x1f, 0x40, 0xd4, 0x3d, 0x98, 0xd2, 0x27, 0x75, 0x4f,
	0x0c, 0xf4, 0x93, 0xba, 0x27, 0x87, 0xfb, 0x6a, 0x0e, 0x7d, 0x0a, 0xb3, 0x89, 0x61, 0x39, 0xda,
	0xec, 0xe7, 0x8a, 0x18, 0xe9, 0xd7, 0x87, 0x40, 0x85, 0x1c, 0x7e, 0x0a, 0x53, 0xe2, 0x80, 0x1a,
	0xbd, 0x96, 0xf2, 0x47, 0x72, 0xfa, 0x24, 0xab, 0x83, 0x40, 0xc4, 0xb0, 0x8e, 0xcf, 0x87, 0x93,
	0x61, 0x9d, 0x39, 0xab, 0x4e, 0x86, 0x75, 0xf6, 0x88, 0x99, 0xc9, 0x2d, 0x8e, 0x55, 0x93, 0x72,
	0x67, 0x0c, 0x89, 0x93, 0x72, 0x67, 0x4d, 0x65, 0xb9, 0xc9, 0xe3, 0xa3, 0xbd, 0x94, 0xc9, 0x33,
	0x07, 0xae, 0x29, 0x93, 0x67, 0xcf, 0x07, 0xd5, 0x1c, 0x32, 0xa1, 0x98, 0x31, 0x02, 0x43, 0xd7,
	0xfb, 0xb9, 0x2c, 0xc5, 0xe9, 0xc6, 0x09, 0x20, 0x43, 0x6e, 0x5d, 0x58, 0xcc, 0x1e, 0x03, 0xa1,
	0x44, 0x52, 0x0f, 0x1c, 0xbb, 0xc9, 0x37, 0x4f, 0x06, 0x1c, 0xb2, 0x7d, 0x07, 0x46, 0xab, 0x58,
	0x37, 0xd1, 0x95, 0xc4, 0xf5, 0x6f, 0x34, 0xc1, 0x90, 0xe5, 0xac, 0xa5, 0x90, 0xc0, 0x3d, 0x18,
	0x63, 0x43, 0x02, 0xb4, 0x92, 0x54, 0x57, 0x18, 0x83, 0xc8, 0x57, 0xb3, 0x17, 0x63, 0x72, 0x1c,
	0x75, 0x1a, 0x29, 0x39, 0xa2, 0xc1, 0x40, 0x4a, 0x0e, 0xe1, 0xe4, 0xc9, 0x08, 0xf8, 0xc7, 0x83,
	0x24, 0x01, 0xe1, 0x74, 0x99, 0x24, 0x20, 0x1e, 0x3d, 0xd4, 0x1c, 0xfa, 0x35, 0x5c, 0xe9, 0xdb,
	0xcd, 0xa3, 0x52, 0xba, 0x5b, 0x1c, 0xb4, 0xbb, 0xcb, 0xe5, 0x13, 0xc3, 0x87, 0xfc, 0x7f, 0x27,
	0xc1, 0xca, 0x80, 0x36, 0x1e, 0x7d, 0x2f, 0x9d, 0x71, 0x83, 0xcf, 0x05, 0xf2, 0x5b, 0xa7, 0xc0,
	0x08, 0xc5, 0xd8, 0xa5, 0x85, 0x26, 0xec, 0x85, 0xd1, 0x62, 0xea, 0x3f, 0x51, 0xee, 0xf9, 0xbd,
	0x51, 0x46, 0x75, 0x49, 0xf5, 0xcf, 0xcc, 0xa8, 0x7d, 0xbb, 0xc9, 0xa4, 0x51, 0x87, 0xb5, 0xba,
	0x49, 0xa3, 0x0e, 0x6d, 0x53, 0xd5, 0x1c, 0x7a, 0x08, 0x93, 0x61, 0x1f, 0x88, 0xd2, 0x75, 0x3c,
	0xd6, 0xf8, 0xc8, 0x4a, 0xdf, 0xf5, 0x90, 0xde, 0x1f, 0x24, 0xb8, 0x3a, 0xa8, 0xb7, 0x42, 0x6f,
	0x25, 0x37, 0xb4, 0xa1, 0x9d, 0xa0, 0x7c, 0xeb, 0x34, 0x28, 0x62, 0x61, 0x15, 0xbb, 0xaf, 0x64,
	0x61, 0xcd, 0x68, 0xec, 0x92, 0x2e, 0xcb, 0x6a, 0xde, 0xd4, 0x5c, 0xe5, 0xed, 0xe7, 0xc7, 0x6b,
	0xd2, 0x8b, 0xe3, 0x35, 0xe9, 0xf3, 0x97, 0x6b, 0xb9, 0x2f, 0x5e, 0xae, 0x49, 0x2f, 0x5e, 0xae,
	0xe5, 0xfe, 0xf9, 0x72, 0x2d, 0xf7, 0xd1, 0x46, 0xdf, 0x4e, 0x34, 0xfa, 0x67, 0xb3, 0xfa, 0x18,
	0x7d, 0xf9, 0xfe, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x72, 0xa8, 0x94, 0x14, 0x82, 0x26, 0x00,
	0x00,
}

func (this *StorageNodeMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*StorageNodeMetadata)
	if !ok {
		that2, ok := that.(StorageNodeMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.StorageNodeMetadataDescriptor.Equal(&that1.StorageNodeMetadataDescriptor) {
		return false
	}
	if !this.CreateTime.Equal(that1.CreateTime) {
		return false
	}
	if !this.LastHeartbeatTime.Equal(that1.LastHeartbeatTime) {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClusterManagerClient is the client API for ClusterManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterManagerClient interface {
	// GetStorageNode returns the metadata of storage node requested.
	// It returns NotFound if the storage node does not exist.
	GetStorageNode(ctx context.Context, in *GetStorageNodeRequest, opts ...grpc.CallOption) (*GetStorageNodeResponse, error)
	// ListStorageNodes returns a list of storage nodes in the cluster.
	ListStorageNodes(ctx context.Context, in *ListStorageNodesRequest, opts ...grpc.CallOption) (*ListStorageNodesResponse, error)
	// AddStorageNode adds a new storage node to the cluster.
	// It is idempotent, that is, adding an already added storage node is okay.
	AddStorageNode(ctx context.Context, in *AddStorageNodeRequest, opts ...grpc.CallOption) (*AddStorageNodeResponse, error)
	// UnregisterStorageNode unregisters the storage node specified by the
	// request.
	UnregisterStorageNode(ctx context.Context, in *UnregisterStorageNodeRequest, opts ...grpc.CallOption) (*UnregisterStorageNodeResponse, error)
	// GetTopic returns the topic specified by the request.
	GetTopic(ctx context.Context, in *GetTopicRequest, opts ...grpc.CallOption) (*GetTopicResponse, error)
	// DescribeTopic returns the topic specified by the request.
	// Deprecated: Use GetTopic.
	DescribeTopic(ctx context.Context, in *DescribeTopicRequest, opts ...grpc.CallOption) (*DescribeTopicResponse, error)
	// ListTopics returns a list of topics in the cluster.
	ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error)
	// AddTopic adds a new topic and returns its metadata.
	AddTopic(ctx context.Context, in *AddTopicRequest, opts ...grpc.CallOption) (*AddTopicResponse, error)
	UnregisterTopic(ctx context.Context, in *UnregisterTopicRequest, opts ...grpc.CallOption) (*UnregisterTopicResponse, error)
	GetLogStream(ctx context.Context, in *GetLogStreamRequest, opts ...grpc.CallOption) (*GetLogStreamResponse, error)
	ListLogStreams(ctx context.Context, in *ListLogStreamsRequest, opts ...grpc.CallOption) (*ListLogStreamsResponse, error)
	// AddLogStream adds a new log stream to the cluster.
	// The error code ResourceExhausted is returned if the number of log streams
	// is reached the upper limit.
	AddLogStream(ctx context.Context, in *AddLogStreamRequest, opts ...grpc.CallOption) (*AddLogStreamResponse, error)
	// UpdateLogStream changes the configuration of replicas in a log stream.
	// Its codes are defines as followings:
	// - InvalidArgument: The client tries to swap the same replica.
	// - Unavailable: The cluster metadata cannot be fetched from the metadata
	// repository transiently.
	// - NotFound: The target log stream does not exist.
	// - FailedPrecondition: Either the target log stream is not sealed, the
	// target log stream doesn't have a victim replica, or the target log stream
	// already has both victim and new replica. Note that clients should not retry
	// without any action.
	// - Unknown: Either storage node or metadata repository returns an error.
	//
	// TODO: Moving the data directory within the same node is not supported yet.
	// TODO: We will define codes for errors returned from storage nodes and
	// metadata repository soon.
	UpdateLogStream(ctx context.Context, in *UpdateLogStreamRequest, opts ...grpc.CallOption) (*UpdateLogStreamResponse, error)
	UnregisterLogStream(ctx context.Context, in *UnregisterLogStreamRequest, opts ...grpc.CallOption) (*UnregisterLogStreamResponse, error)
	RemoveLogStreamReplica(ctx context.Context, in *RemoveLogStreamReplicaRequest, opts ...grpc.CallOption) (*RemoveLogStreamReplicaResponse, error)
	Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error)
	Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error)
	Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error)
	Trim(ctx context.Context, in *TrimRequest, opts ...grpc.CallOption) (*TrimResponse, error)
	GetMetadataRepositoryNode(ctx context.Context, in *GetMetadataRepositoryNodeRequest, opts ...grpc.CallOption) (*GetMetadataRepositoryNodeResponse, error)
	ListMetadataRepositoryNodes(ctx context.Context, in *ListMetadataRepositoryNodesRequest, opts ...grpc.CallOption) (*ListMetadataRepositoryNodesResponse, error)
	GetMRMembers(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetMRMembersResponse, error)
	AddMetadataRepositoryNode(ctx context.Context, in *AddMetadataRepositoryNodeRequest, opts ...grpc.CallOption) (*AddMetadataRepositoryNodeResponse, error)
	AddMRPeer(ctx context.Context, in *AddMRPeerRequest, opts ...grpc.CallOption) (*AddMRPeerResponse, error)
	DeleteMetadataRepositoryNode(ctx context.Context, in *DeleteMetadataRepositoryNodeRequest, opts ...grpc.CallOption) (*DeleteMetadataRepositoryNodeResponse, error)
	RemoveMRPeer(ctx context.Context, in *RemoveMRPeerRequest, opts ...grpc.CallOption) (*RemoveMRPeerResponse, error)
}

type clusterManagerClient struct {
	cc *grpc.ClientConn
}

func NewClusterManagerClient(cc *grpc.ClientConn) ClusterManagerClient {
	return &clusterManagerClient{cc}
}

func (c *clusterManagerClient) GetStorageNode(ctx context.Context, in *GetStorageNodeRequest, opts ...grpc.CallOption) (*GetStorageNodeResponse, error) {
	out := new(GetStorageNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/GetStorageNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) ListStorageNodes(ctx context.Context, in *ListStorageNodesRequest, opts ...grpc.CallOption) (*ListStorageNodesResponse, error) {
	out := new(ListStorageNodesResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/ListStorageNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddStorageNode(ctx context.Context, in *AddStorageNodeRequest, opts ...grpc.CallOption) (*AddStorageNodeResponse, error) {
	out := new(AddStorageNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/AddStorageNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UnregisterStorageNode(ctx context.Context, in *UnregisterStorageNodeRequest, opts ...grpc.CallOption) (*UnregisterStorageNodeResponse, error) {
	out := new(UnregisterStorageNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/UnregisterStorageNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) GetTopic(ctx context.Context, in *GetTopicRequest, opts ...grpc.CallOption) (*GetTopicResponse, error) {
	out := new(GetTopicResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/GetTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) DescribeTopic(ctx context.Context, in *DescribeTopicRequest, opts ...grpc.CallOption) (*DescribeTopicResponse, error) {
	out := new(DescribeTopicResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/DescribeTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) ListTopics(ctx context.Context, in *ListTopicsRequest, opts ...grpc.CallOption) (*ListTopicsResponse, error) {
	out := new(ListTopicsResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/ListTopics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddTopic(ctx context.Context, in *AddTopicRequest, opts ...grpc.CallOption) (*AddTopicResponse, error) {
	out := new(AddTopicResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/AddTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UnregisterTopic(ctx context.Context, in *UnregisterTopicRequest, opts ...grpc.CallOption) (*UnregisterTopicResponse, error) {
	out := new(UnregisterTopicResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/UnregisterTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) GetLogStream(ctx context.Context, in *GetLogStreamRequest, opts ...grpc.CallOption) (*GetLogStreamResponse, error) {
	out := new(GetLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/GetLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) ListLogStreams(ctx context.Context, in *ListLogStreamsRequest, opts ...grpc.CallOption) (*ListLogStreamsResponse, error) {
	out := new(ListLogStreamsResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/ListLogStreams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddLogStream(ctx context.Context, in *AddLogStreamRequest, opts ...grpc.CallOption) (*AddLogStreamResponse, error) {
	out := new(AddLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/AddLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UpdateLogStream(ctx context.Context, in *UpdateLogStreamRequest, opts ...grpc.CallOption) (*UpdateLogStreamResponse, error) {
	out := new(UpdateLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/UpdateLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UnregisterLogStream(ctx context.Context, in *UnregisterLogStreamRequest, opts ...grpc.CallOption) (*UnregisterLogStreamResponse, error) {
	out := new(UnregisterLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/UnregisterLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) RemoveLogStreamReplica(ctx context.Context, in *RemoveLogStreamReplicaRequest, opts ...grpc.CallOption) (*RemoveLogStreamReplicaResponse, error) {
	out := new(RemoveLogStreamReplicaResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/RemoveLogStreamReplica", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error) {
	out := new(SealResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/Seal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error) {
	out := new(UnsealResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/Unseal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error) {
	out := new(SyncResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/Sync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Trim(ctx context.Context, in *TrimRequest, opts ...grpc.CallOption) (*TrimResponse, error) {
	out := new(TrimResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/Trim", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) GetMetadataRepositoryNode(ctx context.Context, in *GetMetadataRepositoryNodeRequest, opts ...grpc.CallOption) (*GetMetadataRepositoryNodeResponse, error) {
	out := new(GetMetadataRepositoryNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/GetMetadataRepositoryNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) ListMetadataRepositoryNodes(ctx context.Context, in *ListMetadataRepositoryNodesRequest, opts ...grpc.CallOption) (*ListMetadataRepositoryNodesResponse, error) {
	out := new(ListMetadataRepositoryNodesResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/ListMetadataRepositoryNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) GetMRMembers(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetMRMembersResponse, error) {
	out := new(GetMRMembersResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/GetMRMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddMetadataRepositoryNode(ctx context.Context, in *AddMetadataRepositoryNodeRequest, opts ...grpc.CallOption) (*AddMetadataRepositoryNodeResponse, error) {
	out := new(AddMetadataRepositoryNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/AddMetadataRepositoryNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddMRPeer(ctx context.Context, in *AddMRPeerRequest, opts ...grpc.CallOption) (*AddMRPeerResponse, error) {
	out := new(AddMRPeerResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/AddMRPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) DeleteMetadataRepositoryNode(ctx context.Context, in *DeleteMetadataRepositoryNodeRequest, opts ...grpc.CallOption) (*DeleteMetadataRepositoryNodeResponse, error) {
	out := new(DeleteMetadataRepositoryNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/DeleteMetadataRepositoryNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) RemoveMRPeer(ctx context.Context, in *RemoveMRPeerRequest, opts ...grpc.CallOption) (*RemoveMRPeerResponse, error) {
	out := new(RemoveMRPeerResponse)
	err := c.cc.Invoke(ctx, "/varlog.admpb.ClusterManager/RemoveMRPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterManagerServer is the server API for ClusterManager service.
type ClusterManagerServer interface {
	// GetStorageNode returns the metadata of storage node requested.
	// It returns NotFound if the storage node does not exist.
	GetStorageNode(context.Context, *GetStorageNodeRequest) (*GetStorageNodeResponse, error)
	// ListStorageNodes returns a list of storage nodes in the cluster.
	ListStorageNodes(context.Context, *ListStorageNodesRequest) (*ListStorageNodesResponse, error)
	// AddStorageNode adds a new storage node to the cluster.
	// It is idempotent, that is, adding an already added storage node is okay.
	AddStorageNode(context.Context, *AddStorageNodeRequest) (*AddStorageNodeResponse, error)
	// UnregisterStorageNode unregisters the storage node specified by the
	// request.
	UnregisterStorageNode(context.Context, *UnregisterStorageNodeRequest) (*UnregisterStorageNodeResponse, error)
	// GetTopic returns the topic specified by the request.
	GetTopic(context.Context, *GetTopicRequest) (*GetTopicResponse, error)
	// DescribeTopic returns the topic specified by the request.
	// Deprecated: Use GetTopic.
	DescribeTopic(context.Context, *DescribeTopicRequest) (*DescribeTopicResponse, error)
	// ListTopics returns a list of topics in the cluster.
	ListTopics(context.Context, *ListTopicsRequest) (*ListTopicsResponse, error)
	// AddTopic adds a new topic and returns its metadata.
	AddTopic(context.Context, *AddTopicRequest) (*AddTopicResponse, error)
	UnregisterTopic(context.Context, *UnregisterTopicRequest) (*UnregisterTopicResponse, error)
	GetLogStream(context.Context, *GetLogStreamRequest) (*GetLogStreamResponse, error)
	ListLogStreams(context.Context, *ListLogStreamsRequest) (*ListLogStreamsResponse, error)
	// AddLogStream adds a new log stream to the cluster.
	// The error code ResourceExhausted is returned if the number of log streams
	// is reached the upper limit.
	AddLogStream(context.Context, *AddLogStreamRequest) (*AddLogStreamResponse, error)
	// UpdateLogStream changes the configuration of replicas in a log stream.
	// Its codes are defines as followings:
	// - InvalidArgument: The client tries to swap the same replica.
	// - Unavailable: The cluster metadata cannot be fetched from the metadata
	// repository transiently.
	// - NotFound: The target log stream does not exist.
	// - FailedPrecondition: Either the target log stream is not sealed, the
	// target log stream doesn't have a victim replica, or the target log stream
	// already has both victim and new replica. Note that clients should not retry
	// without any action.
	// - Unknown: Either storage node or metadata repository returns an error.
	//
	// TODO: Moving the data directory within the same node is not supported yet.
	// TODO: We will define codes for errors returned from storage nodes and
	// metadata repository soon.
	UpdateLogStream(context.Context, *UpdateLogStreamRequest) (*UpdateLogStreamResponse, error)
	UnregisterLogStream(context.Context, *UnregisterLogStreamRequest) (*UnregisterLogStreamResponse, error)
	RemoveLogStreamReplica(context.Context, *RemoveLogStreamReplicaRequest) (*RemoveLogStreamReplicaResponse, error)
	Seal(context.Context, *SealRequest) (*SealResponse, error)
	Unseal(context.Context, *UnsealRequest) (*UnsealResponse, error)
	Sync(context.Context, *SyncRequest) (*SyncResponse, error)
	Trim(context.Context, *TrimRequest) (*TrimResponse, error)
	GetMetadataRepositoryNode(context.Context, *GetMetadataRepositoryNodeRequest) (*GetMetadataRepositoryNodeResponse, error)
	ListMetadataRepositoryNodes(context.Context, *ListMetadataRepositoryNodesRequest) (*ListMetadataRepositoryNodesResponse, error)
	GetMRMembers(context.Context, *types.Empty) (*GetMRMembersResponse, error)
	AddMetadataRepositoryNode(context.Context, *AddMetadataRepositoryNodeRequest) (*AddMetadataRepositoryNodeResponse, error)
	AddMRPeer(context.Context, *AddMRPeerRequest) (*AddMRPeerResponse, error)
	DeleteMetadataRepositoryNode(context.Context, *DeleteMetadataRepositoryNodeRequest) (*DeleteMetadataRepositoryNodeResponse, error)
	RemoveMRPeer(context.Context, *RemoveMRPeerRequest) (*RemoveMRPeerResponse, error)
}

// UnimplementedClusterManagerServer can be embedded to have forward compatible implementations.
type UnimplementedClusterManagerServer struct {
}

func (*UnimplementedClusterManagerServer) GetStorageNode(ctx context.Context, req *GetStorageNodeRequest) (*GetStorageNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorageNode not implemented")
}
func (*UnimplementedClusterManagerServer) ListStorageNodes(ctx context.Context, req *ListStorageNodesRequest) (*ListStorageNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListStorageNodes not implemented")
}
func (*UnimplementedClusterManagerServer) AddStorageNode(ctx context.Context, req *AddStorageNodeRequest) (*AddStorageNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddStorageNode not implemented")
}
func (*UnimplementedClusterManagerServer) UnregisterStorageNode(ctx context.Context, req *UnregisterStorageNodeRequest) (*UnregisterStorageNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterStorageNode not implemented")
}
func (*UnimplementedClusterManagerServer) GetTopic(ctx context.Context, req *GetTopicRequest) (*GetTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopic not implemented")
}
func (*UnimplementedClusterManagerServer) DescribeTopic(ctx context.Context, req *DescribeTopicRequest) (*DescribeTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DescribeTopic not implemented")
}
func (*UnimplementedClusterManagerServer) ListTopics(ctx context.Context, req *ListTopicsRequest) (*ListTopicsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTopics not implemented")
}
func (*UnimplementedClusterManagerServer) AddTopic(ctx context.Context, req *AddTopicRequest) (*AddTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTopic not implemented")
}
func (*UnimplementedClusterManagerServer) UnregisterTopic(ctx context.Context, req *UnregisterTopicRequest) (*UnregisterTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterTopic not implemented")
}
func (*UnimplementedClusterManagerServer) GetLogStream(ctx context.Context, req *GetLogStreamRequest) (*GetLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) ListLogStreams(ctx context.Context, req *ListLogStreamsRequest) (*ListLogStreamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLogStreams not implemented")
}
func (*UnimplementedClusterManagerServer) AddLogStream(ctx context.Context, req *AddLogStreamRequest) (*AddLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) UpdateLogStream(ctx context.Context, req *UpdateLogStreamRequest) (*UpdateLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) UnregisterLogStream(ctx context.Context, req *UnregisterLogStreamRequest) (*UnregisterLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) RemoveLogStreamReplica(ctx context.Context, req *RemoveLogStreamReplicaRequest) (*RemoveLogStreamReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveLogStreamReplica not implemented")
}
func (*UnimplementedClusterManagerServer) Seal(ctx context.Context, req *SealRequest) (*SealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seal not implemented")
}
func (*UnimplementedClusterManagerServer) Unseal(ctx context.Context, req *UnsealRequest) (*UnsealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unseal not implemented")
}
func (*UnimplementedClusterManagerServer) Sync(ctx context.Context, req *SyncRequest) (*SyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sync not implemented")
}
func (*UnimplementedClusterManagerServer) Trim(ctx context.Context, req *TrimRequest) (*TrimResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Trim not implemented")
}
func (*UnimplementedClusterManagerServer) GetMetadataRepositoryNode(ctx context.Context, req *GetMetadataRepositoryNodeRequest) (*GetMetadataRepositoryNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMetadataRepositoryNode not implemented")
}
func (*UnimplementedClusterManagerServer) ListMetadataRepositoryNodes(ctx context.Context, req *ListMetadataRepositoryNodesRequest) (*ListMetadataRepositoryNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListMetadataRepositoryNodes not implemented")
}
func (*UnimplementedClusterManagerServer) GetMRMembers(ctx context.Context, req *types.Empty) (*GetMRMembersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMRMembers not implemented")
}
func (*UnimplementedClusterManagerServer) AddMetadataRepositoryNode(ctx context.Context, req *AddMetadataRepositoryNodeRequest) (*AddMetadataRepositoryNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMetadataRepositoryNode not implemented")
}
func (*UnimplementedClusterManagerServer) AddMRPeer(ctx context.Context, req *AddMRPeerRequest) (*AddMRPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMRPeer not implemented")
}
func (*UnimplementedClusterManagerServer) DeleteMetadataRepositoryNode(ctx context.Context, req *DeleteMetadataRepositoryNodeRequest) (*DeleteMetadataRepositoryNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteMetadataRepositoryNode not implemented")
}
func (*UnimplementedClusterManagerServer) RemoveMRPeer(ctx context.Context, req *RemoveMRPeerRequest) (*RemoveMRPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveMRPeer not implemented")
}

func RegisterClusterManagerServer(s *grpc.Server, srv ClusterManagerServer) {
	s.RegisterService(&_ClusterManager_serviceDesc, srv)
}

func _ClusterManager_GetStorageNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStorageNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).GetStorageNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/GetStorageNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).GetStorageNode(ctx, req.(*GetStorageNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_ListStorageNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStorageNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).ListStorageNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/ListStorageNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).ListStorageNodes(ctx, req.(*ListStorageNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddStorageNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddStorageNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddStorageNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/AddStorageNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddStorageNode(ctx, req.(*AddStorageNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UnregisterStorageNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterStorageNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UnregisterStorageNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/UnregisterStorageNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UnregisterStorageNode(ctx, req.(*UnregisterStorageNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_GetTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).GetTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/GetTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).GetTopic(ctx, req.(*GetTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_DescribeTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DescribeTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).DescribeTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/DescribeTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).DescribeTopic(ctx, req.(*DescribeTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_ListTopics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTopicsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).ListTopics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/ListTopics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).ListTopics(ctx, req.(*ListTopicsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/AddTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddTopic(ctx, req.(*AddTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UnregisterTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UnregisterTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/UnregisterTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UnregisterTopic(ctx, req.(*UnregisterTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_GetLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).GetLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/GetLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).GetLogStream(ctx, req.(*GetLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_ListLogStreams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLogStreamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).ListLogStreams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/ListLogStreams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).ListLogStreams(ctx, req.(*ListLogStreamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/AddLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddLogStream(ctx, req.(*AddLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UpdateLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UpdateLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/UpdateLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UpdateLogStream(ctx, req.(*UpdateLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UnregisterLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UnregisterLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/UnregisterLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UnregisterLogStream(ctx, req.(*UnregisterLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_RemoveLogStreamReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveLogStreamReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).RemoveLogStreamReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/RemoveLogStreamReplica",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).RemoveLogStreamReplica(ctx, req.(*RemoveLogStreamReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Seal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Seal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/Seal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Seal(ctx, req.(*SealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Unseal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Unseal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/Unseal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Unseal(ctx, req.(*UnsealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Sync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Sync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/Sync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Sync(ctx, req.(*SyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Trim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TrimRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Trim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/Trim",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Trim(ctx, req.(*TrimRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_GetMetadataRepositoryNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetadataRepositoryNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).GetMetadataRepositoryNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/GetMetadataRepositoryNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).GetMetadataRepositoryNode(ctx, req.(*GetMetadataRepositoryNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_ListMetadataRepositoryNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMetadataRepositoryNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).ListMetadataRepositoryNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/ListMetadataRepositoryNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).ListMetadataRepositoryNodes(ctx, req.(*ListMetadataRepositoryNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_GetMRMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).GetMRMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/GetMRMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).GetMRMembers(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddMetadataRepositoryNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMetadataRepositoryNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddMetadataRepositoryNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/AddMetadataRepositoryNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddMetadataRepositoryNode(ctx, req.(*AddMetadataRepositoryNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddMRPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMRPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddMRPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/AddMRPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddMRPeer(ctx, req.(*AddMRPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_DeleteMetadataRepositoryNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMetadataRepositoryNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).DeleteMetadataRepositoryNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/DeleteMetadataRepositoryNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).DeleteMetadataRepositoryNode(ctx, req.(*DeleteMetadataRepositoryNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_RemoveMRPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveMRPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).RemoveMRPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.admpb.ClusterManager/RemoveMRPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).RemoveMRPeer(ctx, req.(*RemoveMRPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClusterManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "varlog.admpb.ClusterManager",
	HandlerType: (*ClusterManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStorageNode",
			Handler:    _ClusterManager_GetStorageNode_Handler,
		},
		{
			MethodName: "ListStorageNodes",
			Handler:    _ClusterManager_ListStorageNodes_Handler,
		},
		{
			MethodName: "AddStorageNode",
			Handler:    _ClusterManager_AddStorageNode_Handler,
		},
		{
			MethodName: "UnregisterStorageNode",
			Handler:    _ClusterManager_UnregisterStorageNode_Handler,
		},
		{
			MethodName: "GetTopic",
			Handler:    _ClusterManager_GetTopic_Handler,
		},
		{
			MethodName: "DescribeTopic",
			Handler:    _ClusterManager_DescribeTopic_Handler,
		},
		{
			MethodName: "ListTopics",
			Handler:    _ClusterManager_ListTopics_Handler,
		},
		{
			MethodName: "AddTopic",
			Handler:    _ClusterManager_AddTopic_Handler,
		},
		{
			MethodName: "UnregisterTopic",
			Handler:    _ClusterManager_UnregisterTopic_Handler,
		},
		{
			MethodName: "GetLogStream",
			Handler:    _ClusterManager_GetLogStream_Handler,
		},
		{
			MethodName: "ListLogStreams",
			Handler:    _ClusterManager_ListLogStreams_Handler,
		},
		{
			MethodName: "AddLogStream",
			Handler:    _ClusterManager_AddLogStream_Handler,
		},
		{
			MethodName: "UpdateLogStream",
			Handler:    _ClusterManager_UpdateLogStream_Handler,
		},
		{
			MethodName: "UnregisterLogStream",
			Handler:    _ClusterManager_UnregisterLogStream_Handler,
		},
		{
			MethodName: "RemoveLogStreamReplica",
			Handler:    _ClusterManager_RemoveLogStreamReplica_Handler,
		},
		{
			MethodName: "Seal",
			Handler:    _ClusterManager_Seal_Handler,
		},
		{
			MethodName: "Unseal",
			Handler:    _ClusterManager_Unseal_Handler,
		},
		{
			MethodName: "Sync",
			Handler:    _ClusterManager_Sync_Handler,
		},
		{
			MethodName: "Trim",
			Handler:    _ClusterManager_Trim_Handler,
		},
		{
			MethodName: "GetMetadataRepositoryNode",
			Handler:    _ClusterManager_GetMetadataRepositoryNode_Handler,
		},
		{
			MethodName: "ListMetadataRepositoryNodes",
			Handler:    _ClusterManager_ListMetadataRepositoryNodes_Handler,
		},
		{
			MethodName: "GetMRMembers",
			Handler:    _ClusterManager_GetMRMembers_Handler,
		},
		{
			MethodName: "AddMetadataRepositoryNode",
			Handler:    _ClusterManager_AddMetadataRepositoryNode_Handler,
		},
		{
			MethodName: "AddMRPeer",
			Handler:    _ClusterManager_AddMRPeer_Handler,
		},
		{
			MethodName: "DeleteMetadataRepositoryNode",
			Handler:    _ClusterManager_DeleteMetadataRepositoryNode_Handler,
		},
		{
			MethodName: "RemoveMRPeer",
			Handler:    _ClusterManager_RemoveMRPeer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/admpb/admin.proto",
}

func (m *StorageNodeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StorageNodeMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StorageNodeMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.LastHeartbeatTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.LastHeartbeatTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintAdmin(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1a
	n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CreateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CreateTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintAdmin(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.StorageNodeMetadataDescriptor.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *GetStorageNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStorageNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStorageNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetStorageNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStorageNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStorageNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageNode != nil {
		{
			size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListStorageNodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListStorageNodesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListStorageNodesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListStorageNodesResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListStorageNodesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListStorageNodesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StorageNodes) > 0 {
		for iNdEx := len(m.StorageNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StorageNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddStorageNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStorageNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddStorageNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddStorageNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStorageNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddStorageNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageNode != nil {
		{
			size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterStorageNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterStorageNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterStorageNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterStorageNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterStorageNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterStorageNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetTopicRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopicRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTopicRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetTopicResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTopicResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetTopicResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Topic != nil {
		{
			size, err := m.Topic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DescribeTopicRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeTopicRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescribeTopicRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DescribeTopicResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DescribeTopicResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DescribeTopicResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Topic.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ListTopicsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTopicsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTopicsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListTopicsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListTopicsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListTopicsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for iNdEx := len(m.Topics) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Topics[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddTopicRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTopicRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTopicRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AddTopicResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTopicResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTopicResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Topic != nil {
		{
			size, err := m.Topic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterTopicRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterTopicRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterTopicRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterTopicResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterTopicResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterTopicResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListLogStreamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListLogStreamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListLogStreamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ListLogStreamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListLogStreamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListLogStreamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.PushedReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size, err := m.PoppedReplica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintAdmin(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.LogStreamID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RemoveLogStreamReplicaRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveLogStreamReplicaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveLogStreamReplicaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x18
	}
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x10
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveLogStreamReplicaResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveLogStreamReplicaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveLogStreamReplicaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SealRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SealResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SealedGLSN != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SealedGLSN))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UnsealRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsealRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsealRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnsealResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstStorageNodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.DstStorageNodeID))
		i--
		dAtA[i] = 0x20
	}
	if m.SrcStorageNodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.SrcStorageNodeID))
		i--
		dAtA[i] = 0x18
	}
	if m.LogStreamID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrimRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrimRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrimRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastGLSN != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LastGLSN))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrimResult) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrimResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrimResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.LogStreamID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TrimResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrimResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrimResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for iNdEx := len(m.Results) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Results[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetMetadataRepositoryNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMetadataRepositoryNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMetadataRepositoryNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetMetadataRepositoryNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMetadataRepositoryNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMetadataRepositoryNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListMetadataRepositoryNodesRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMetadataRepositoryNodesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMetadataRepositoryNodesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ListMetadataRepositoryNodesResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListMetadataRepositoryNodesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListMetadataRepositoryNodesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAdmin(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GetMRMembersResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMRMembersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMRMembersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for k := range m.Members {
			v := m.Members[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAdmin(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintAdmin(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintAdmin(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x10
	}
	if m.Leader != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddMetadataRepositoryNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMetadataRepositoryNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMetadataRepositoryNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RPCAddr) > 0 {
		i -= len(m.RPCAddr)
		copy(dAtA[i:], m.RPCAddr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.RPCAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RaftURL) > 0 {
		i -= len(m.RaftURL)
		copy(dAtA[i:], m.RaftURL)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.RaftURL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMetadataRepositoryNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMetadataRepositoryNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMetadataRepositoryNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAdmin(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMRPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMRPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMRPeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RPCAddr) > 0 {
		i -= len(m.RPCAddr)
		copy(dAtA[i:], m.RPCAddr)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.RPCAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RaftURL) > 0 {
		i -= len(m.RaftURL)
		copy(dAtA[i:], m.RaftURL)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.RaftURL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMRPeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMRPeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMRPeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMetadataRepositoryNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMetadataRepositoryNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMetadataRepositoryNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		i = encodeVarintAdmin(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeleteMetadataRepositoryNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteMetadataRepositoryNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteMetadataRepositoryNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RemoveMRPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveMRPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveMRPeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RaftURL) > 0 {
		i -= len(m.RaftURL)
		copy(dAtA[i:], m.RaftURL)
		i = encodeVarintAdmin(dAtA, i, uint64(len(m.RaftURL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveMRPeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveMRPeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveMRPeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintAdmin(dAtA []byte, offset int, v uint64) int {
	offset -= sovAdmin(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StorageNodeMetadata) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StorageNodeMetadataDescriptor.ProtoSize()
	n += 1 + l + sovAdmin(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CreateTime)
	n += 1 + l + sovAdmin(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.LastHeartbeatTime)
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *GetStorageNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovAdmin(uint64(m.StorageNodeID))
	}
	return n
}

func (m *GetStorageNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNode != nil {
		l = m.StorageNode.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ListStorageNodesRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListStorageNodesResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StorageNodes) > 0 {
		for _, e := range m.StorageNodes {
			l = e.ProtoSize()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *AddStorageNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.StorageNode.ProtoSize()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *AddStorageNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNode != nil {
		l = m.StorageNode.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *UnregisterStorageNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovAdmin(uint64(m.StorageNodeID))
	}
	return n
}

func (m *UnregisterStorageNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetTopicRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	return n
}

func (m *GetTopicResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != nil {
		l = m.Topic.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *DescribeTopicRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	return n
}

func (m *DescribeTopicResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Topic.ProtoSize()
	n += 1 + l + sovAdmin(uint64(l))
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *ListTopicsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListTopicsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Topics) > 0 {
		for _, e := range m.Topics {
			l = e.ProtoSize()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *AddTopicRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AddTopicResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != nil {
		l = m.Topic.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *UnregisterTopicRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	return n
}

func (m *UnregisterTopicResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovAdmin(uint64(m.LogStreamID))
	}
	return n
}

func (m *GetLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ListLogStreamsRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	return n
}

func (m *ListLogStreamsResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *AddLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.ProtoSize()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *AddLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *UpdateLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovAdmin(uint64(m.LogStreamID))
	}
	l = m.PoppedReplica.ProtoSize()
	n += 1 + l + sovAdmin(uint64(l))
	l = m.PushedReplica.ProtoSize()
	n += 1 + l + sovAdmin(uint64(l))
	return n
}

func (m *UpdateLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *UnregisterLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovAdmin(uint64(m.LogStreamID))
	}
	return n
}

func (m *UnregisterLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RemoveLogStreamReplicaRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovAdmin(uint64(m.StorageNodeID))
	}
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovAdmin(uint64(m.LogStreamID))
	}
	return n
}

func (m *RemoveLogStreamReplicaResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SealRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovAdmin(uint64(m.LogStreamID))
	}
	return n
}

func (m *SealResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	if m.SealedGLSN != 0 {
		n += 1 + sovAdmin(uint64(m.SealedGLSN))
	}
	return n
}

func (m *UnsealRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovAdmin(uint64(m.LogStreamID))
	}
	return n
}

func (m *UnsealResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *SyncRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovAdmin(uint64(m.LogStreamID))
	}
	if m.SrcStorageNodeID != 0 {
		n += 1 + sovAdmin(uint64(m.SrcStorageNodeID))
	}
	if m.DstStorageNodeID != 0 {
		n += 1 + sovAdmin(uint64(m.DstStorageNodeID))
	}
	return n
}

func (m *SyncResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *TrimRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovAdmin(uint64(m.TopicID))
	}
	if m.LastGLSN != 0 {
		n += 1 + sovAdmin(uint64(m.LastGLSN))
	}
	return n
}

func (m *TrimResult) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovAdmin(uint64(m.StorageNodeID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovAdmin(uint64(m.LogStreamID))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *TrimResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Results) > 0 {
		for _, e := range m.Results {
			l = e.ProtoSize()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *GetMetadataRepositoryNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovAdmin(uint64(m.NodeID))
	}
	return n
}

func (m *GetMetadataRepositoryNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *ListMetadataRepositoryNodesRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ListMetadataRepositoryNodesResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.ProtoSize()
			n += 1 + l + sovAdmin(uint64(l))
		}
	}
	return n
}

func (m *GetMRMembersResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leader != 0 {
		n += 1 + sovAdmin(uint64(m.Leader))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovAdmin(uint64(m.ReplicationFactor))
	}
	if len(m.Members) > 0 {
		for k, v := range m.Members {
			_ = k
			_ = v
			mapEntrySize := 1 + sovAdmin(uint64(k)) + 1 + len(v) + sovAdmin(uint64(len(v)))
			n += mapEntrySize + 1 + sovAdmin(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AddMetadataRepositoryNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RaftURL)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.RPCAddr)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *AddMetadataRepositoryNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.ProtoSize()
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *AddMRPeerRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RaftURL)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	l = len(m.RPCAddr)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *AddMRPeerResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovAdmin(uint64(m.NodeID))
	}
	return n
}

func (m *DeleteMetadataRepositoryNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovAdmin(uint64(m.NodeID))
	}
	return n
}

func (m *DeleteMetadataRepositoryNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RemoveMRPeerRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RaftURL)
	if l > 0 {
		n += 1 + l + sovAdmin(uint64(l))
	}
	return n
}

func (m *RemoveMRPeerResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovAdmin(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAdmin(x uint64) (n int) {
	return sovAdmin(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StorageNodeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StorageNodeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StorageNodeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeMetadataDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorageNodeMetadataDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CreateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeatTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.LastHeartbeatTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStorageNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStorageNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStorageNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_com_kakao_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStorageNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStorageNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStorageNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageNode == nil {
				m.StorageNode = &StorageNodeMetadata{}
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListStorageNodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListStorageNodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListStorageNodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListStorageNodesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListStorageNodesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListStorageNodesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageNodes = append(m.StorageNodes, StorageNodeMetadata{})
			if err := m.StorageNodes[len(m.StorageNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddStorageNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddStorageNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddStorageNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddStorageNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddStorageNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddStorageNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageNode == nil {
				m.StorageNode = &StorageNodeMetadata{}
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterStorageNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterStorageNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterStorageNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_com_kakao_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterStorageNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterStorageNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterStorageNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopicRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopicRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopicRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTopicResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTopicResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTopicResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Topic == nil {
				m.Topic = &varlogpb.TopicDescriptor{}
			}
			if err := m.Topic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeTopicRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeTopicRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeTopicRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DescribeTopicResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DescribeTopicResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DescribeTopicResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Topic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, varlogpb.LogStreamDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTopicsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTopicsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTopicsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListTopicsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListTopicsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListTopicsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topics = append(m.Topics, varlogpb.TopicDescriptor{})
			if err := m.Topics[len(m.Topics)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTopicRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTopicRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTopicRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTopicResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTopicResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTopicResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Topic == nil {
				m.Topic = &varlogpb.TopicDescriptor{}
			}
			if err := m.Topic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterTopicRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterTopicRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterTopicRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterTopicResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterTopicResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterTopicResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListLogStreamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListLogStreamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListLogStreamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListLogStreamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListLogStreamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListLogStreamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, varlogpb.LogStreamDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &varlogpb.ReplicaDescriptor{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoppedReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PoppedReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PushedReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveLogStreamReplicaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_com_kakao_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveLogStreamReplicaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, snpb.LogStreamReplicaMetadataDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedGLSN", wireType)
			}
			m.SealedGLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SealedGLSN |= github_com_kakao_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsealRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsealRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsealRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcStorageNodeID", wireType)
			}
			m.SrcStorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcStorageNodeID |= github_com_kakao_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstStorageNodeID", wireType)
			}
			m.DstStorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstStorageNodeID |= github_com_kakao_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &snpb.SyncStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrimRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrimRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrimRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_com_kakao_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastGLSN", wireType)
			}
			m.LastGLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastGLSN |= github_com_kakao_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrimResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrimResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrimResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_com_kakao_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_com_kakao_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrimResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrimResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrimResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Results = append(m.Results, TrimResult{})
			if err := m.Results[len(m.Results)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMetadataRepositoryNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMetadataRepositoryNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMetadataRepositoryNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_kakao_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMetadataRepositoryNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMetadataRepositoryNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMetadataRepositoryNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &varlogpb.MetadataRepositoryNode{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMetadataRepositoryNodesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMetadataRepositoryNodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMetadataRepositoryNodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListMetadataRepositoryNodesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListMetadataRepositoryNodesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListMetadataRepositoryNodesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, varlogpb.MetadataRepositoryNode{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMRMembersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMRMembersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMRMembersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= github_com_kakao_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Members == nil {
				m.Members = make(map[github_com_kakao_varlog_pkg_types.NodeID]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAdmin
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAdmin
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAdmin
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAdmin
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAdmin(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAdmin
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Members[github_com_kakao_varlog_pkg_types.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMetadataRepositoryNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMetadataRepositoryNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMetadataRepositoryNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RPCAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMetadataRepositoryNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMetadataRepositoryNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMetadataRepositoryNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &varlogpb.MetadataRepositoryNode{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMRPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMRPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMRPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RPCAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMRPeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMRPeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMRPeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_kakao_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMetadataRepositoryNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMetadataRepositoryNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMetadataRepositoryNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_com_kakao_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteMetadataRepositoryNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteMetadataRepositoryNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteMetadataRepositoryNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveMRPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveMRPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveMRPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAdmin
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAdmin
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveMRPeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveMRPeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveMRPeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAdmin(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAdmin
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAdmin(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAdmin
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAdmin
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAdmin
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAdmin
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAdmin
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAdmin        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAdmin          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAdmin = fmt.Errorf("proto: unexpected end of group")
)
