// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/vmspb/vms.proto

package vmspb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	github_daumkakao_com_varlog_varlog_pkg_types "github.daumkakao.com/varlog/varlog/pkg/types"
	snpb "github.daumkakao.com/varlog/varlog/proto/snpb"
	varlogpb "github.daumkakao.com/varlog/varlog/proto/varlogpb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AddStorageNodeRequest struct {
	// address is IP of a node to be added to the cluster.
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *AddStorageNodeRequest) Reset()         { *m = AddStorageNodeRequest{} }
func (m *AddStorageNodeRequest) String() string { return proto.CompactTextString(m) }
func (*AddStorageNodeRequest) ProtoMessage()    {}
func (*AddStorageNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{0}
}
func (m *AddStorageNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddStorageNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddStorageNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddStorageNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddStorageNodeRequest.Merge(m, src)
}
func (m *AddStorageNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddStorageNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddStorageNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddStorageNodeRequest proto.InternalMessageInfo

func (m *AddStorageNodeRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type AddStorageNodeResponse struct {
	StorageNode *varlogpb.StorageNodeMetadataDescriptor `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3" json:"storage_node,omitempty"`
}

func (m *AddStorageNodeResponse) Reset()         { *m = AddStorageNodeResponse{} }
func (m *AddStorageNodeResponse) String() string { return proto.CompactTextString(m) }
func (*AddStorageNodeResponse) ProtoMessage()    {}
func (*AddStorageNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{1}
}
func (m *AddStorageNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddStorageNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddStorageNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddStorageNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddStorageNodeResponse.Merge(m, src)
}
func (m *AddStorageNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddStorageNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddStorageNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddStorageNodeResponse proto.InternalMessageInfo

func (m *AddStorageNodeResponse) GetStorageNode() *varlogpb.StorageNodeMetadataDescriptor {
	if m != nil {
		return m.StorageNode
	}
	return nil
}

type UnregisterStorageNodeRequest struct {
	StorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
}

func (m *UnregisterStorageNodeRequest) Reset()         { *m = UnregisterStorageNodeRequest{} }
func (m *UnregisterStorageNodeRequest) String() string { return proto.CompactTextString(m) }
func (*UnregisterStorageNodeRequest) ProtoMessage()    {}
func (*UnregisterStorageNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{2}
}
func (m *UnregisterStorageNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterStorageNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterStorageNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterStorageNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterStorageNodeRequest.Merge(m, src)
}
func (m *UnregisterStorageNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterStorageNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterStorageNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterStorageNodeRequest proto.InternalMessageInfo

func (m *UnregisterStorageNodeRequest) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

type UnregisterStorageNodeResponse struct {
}

func (m *UnregisterStorageNodeResponse) Reset()         { *m = UnregisterStorageNodeResponse{} }
func (m *UnregisterStorageNodeResponse) String() string { return proto.CompactTextString(m) }
func (*UnregisterStorageNodeResponse) ProtoMessage()    {}
func (*UnregisterStorageNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{3}
}
func (m *UnregisterStorageNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterStorageNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterStorageNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterStorageNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterStorageNodeResponse.Merge(m, src)
}
func (m *UnregisterStorageNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterStorageNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterStorageNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterStorageNodeResponse proto.InternalMessageInfo

type AddTopicRequest struct {
	TopicID github_daumkakao_com_varlog_varlog_pkg_types.TopicID `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
}

func (m *AddTopicRequest) Reset()         { *m = AddTopicRequest{} }
func (m *AddTopicRequest) String() string { return proto.CompactTextString(m) }
func (*AddTopicRequest) ProtoMessage()    {}
func (*AddTopicRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{4}
}
func (m *AddTopicRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTopicRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTopicRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTopicRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTopicRequest.Merge(m, src)
}
func (m *AddTopicRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddTopicRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTopicRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddTopicRequest proto.InternalMessageInfo

func (m *AddTopicRequest) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

type AddTopicResponse struct {
	Topic *varlogpb.TopicDescriptor `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
}

func (m *AddTopicResponse) Reset()         { *m = AddTopicResponse{} }
func (m *AddTopicResponse) String() string { return proto.CompactTextString(m) }
func (*AddTopicResponse) ProtoMessage()    {}
func (*AddTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{5}
}
func (m *AddTopicResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddTopicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddTopicResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddTopicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddTopicResponse.Merge(m, src)
}
func (m *AddTopicResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddTopicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddTopicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddTopicResponse proto.InternalMessageInfo

func (m *AddTopicResponse) GetTopic() *varlogpb.TopicDescriptor {
	if m != nil {
		return m.Topic
	}
	return nil
}

type UnregisterTopicRequest struct {
	TopicID github_daumkakao_com_varlog_varlog_pkg_types.TopicID `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
}

func (m *UnregisterTopicRequest) Reset()         { *m = UnregisterTopicRequest{} }
func (m *UnregisterTopicRequest) String() string { return proto.CompactTextString(m) }
func (*UnregisterTopicRequest) ProtoMessage()    {}
func (*UnregisterTopicRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{6}
}
func (m *UnregisterTopicRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterTopicRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterTopicRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterTopicRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterTopicRequest.Merge(m, src)
}
func (m *UnregisterTopicRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterTopicRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterTopicRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterTopicRequest proto.InternalMessageInfo

func (m *UnregisterTopicRequest) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

type UnregisterTopicResponse struct {
}

func (m *UnregisterTopicResponse) Reset()         { *m = UnregisterTopicResponse{} }
func (m *UnregisterTopicResponse) String() string { return proto.CompactTextString(m) }
func (*UnregisterTopicResponse) ProtoMessage()    {}
func (*UnregisterTopicResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{7}
}
func (m *UnregisterTopicResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterTopicResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterTopicResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterTopicResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterTopicResponse.Merge(m, src)
}
func (m *UnregisterTopicResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterTopicResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterTopicResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterTopicResponse proto.InternalMessageInfo

type AddLogStreamRequest struct {
	TopicID github_daumkakao_com_varlog_varlog_pkg_types.TopicID `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	// TODO: nullable = false
	Replicas []*varlogpb.ReplicaDescriptor `protobuf:"bytes,2,rep,name=replicas,proto3" json:"replicas,omitempty"`
}

func (m *AddLogStreamRequest) Reset()         { *m = AddLogStreamRequest{} }
func (m *AddLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*AddLogStreamRequest) ProtoMessage()    {}
func (*AddLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{8}
}
func (m *AddLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddLogStreamRequest.Merge(m, src)
}
func (m *AddLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddLogStreamRequest proto.InternalMessageInfo

func (m *AddLogStreamRequest) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *AddLogStreamRequest) GetReplicas() []*varlogpb.ReplicaDescriptor {
	if m != nil {
		return m.Replicas
	}
	return nil
}

type AddLogStreamResponse struct {
	LogStream *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"log_stream,omitempty"`
}

func (m *AddLogStreamResponse) Reset()         { *m = AddLogStreamResponse{} }
func (m *AddLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*AddLogStreamResponse) ProtoMessage()    {}
func (*AddLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{9}
}
func (m *AddLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddLogStreamResponse.Merge(m, src)
}
func (m *AddLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddLogStreamResponse proto.InternalMessageInfo

func (m *AddLogStreamResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type UnregisterLogStreamRequest struct {
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *UnregisterLogStreamRequest) Reset()         { *m = UnregisterLogStreamRequest{} }
func (m *UnregisterLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*UnregisterLogStreamRequest) ProtoMessage()    {}
func (*UnregisterLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{10}
}
func (m *UnregisterLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterLogStreamRequest.Merge(m, src)
}
func (m *UnregisterLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterLogStreamRequest proto.InternalMessageInfo

func (m *UnregisterLogStreamRequest) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *UnregisterLogStreamRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type UnregisterLogStreamResponse struct {
}

func (m *UnregisterLogStreamResponse) Reset()         { *m = UnregisterLogStreamResponse{} }
func (m *UnregisterLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*UnregisterLogStreamResponse) ProtoMessage()    {}
func (*UnregisterLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{11}
}
func (m *UnregisterLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterLogStreamResponse.Merge(m, src)
}
func (m *UnregisterLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterLogStreamResponse proto.InternalMessageInfo

type RemoveLogStreamReplicaRequest struct {
	StorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	TopicID       github_daumkakao_com_varlog_varlog_pkg_types.TopicID       `protobuf:"varint,2,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID   github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID   `protobuf:"varint,3,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *RemoveLogStreamReplicaRequest) Reset()         { *m = RemoveLogStreamReplicaRequest{} }
func (m *RemoveLogStreamReplicaRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveLogStreamReplicaRequest) ProtoMessage()    {}
func (*RemoveLogStreamReplicaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{12}
}
func (m *RemoveLogStreamReplicaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveLogStreamReplicaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveLogStreamReplicaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveLogStreamReplicaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveLogStreamReplicaRequest.Merge(m, src)
}
func (m *RemoveLogStreamReplicaRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveLogStreamReplicaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveLogStreamReplicaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveLogStreamReplicaRequest proto.InternalMessageInfo

func (m *RemoveLogStreamReplicaRequest) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *RemoveLogStreamReplicaRequest) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *RemoveLogStreamReplicaRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type RemoveLogStreamReplicaResponse struct {
}

func (m *RemoveLogStreamReplicaResponse) Reset()         { *m = RemoveLogStreamReplicaResponse{} }
func (m *RemoveLogStreamReplicaResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveLogStreamReplicaResponse) ProtoMessage()    {}
func (*RemoveLogStreamReplicaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{13}
}
func (m *RemoveLogStreamReplicaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveLogStreamReplicaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveLogStreamReplicaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveLogStreamReplicaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveLogStreamReplicaResponse.Merge(m, src)
}
func (m *RemoveLogStreamReplicaResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveLogStreamReplicaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveLogStreamReplicaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveLogStreamReplicaResponse proto.InternalMessageInfo

type UpdateLogStreamRequest struct {
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	//
	//// NOTE: popped_replica need not be varlog.ReplicaDescriptor, but it is
	//// natural. Though it is awkward, popped_storage_node_id is used here.
	//uint32 popped_storage_node_id = 2 [
	//(gogoproto.casttype) =
	//"github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID",
	//(gogoproto.customname) = "PoppedStorageNodeID"
	//];
	PoppedReplica *varlogpb.ReplicaDescriptor `protobuf:"bytes,3,opt,name=popped_replica,json=poppedReplica,proto3" json:"popped_replica,omitempty"`
	PushedReplica *varlogpb.ReplicaDescriptor `protobuf:"bytes,4,opt,name=pushed_replica,json=pushedReplica,proto3" json:"pushed_replica,omitempty"`
}

func (m *UpdateLogStreamRequest) Reset()         { *m = UpdateLogStreamRequest{} }
func (m *UpdateLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateLogStreamRequest) ProtoMessage()    {}
func (*UpdateLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{14}
}
func (m *UpdateLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLogStreamRequest.Merge(m, src)
}
func (m *UpdateLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLogStreamRequest proto.InternalMessageInfo

func (m *UpdateLogStreamRequest) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *UpdateLogStreamRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *UpdateLogStreamRequest) GetPoppedReplica() *varlogpb.ReplicaDescriptor {
	if m != nil {
		return m.PoppedReplica
	}
	return nil
}

func (m *UpdateLogStreamRequest) GetPushedReplica() *varlogpb.ReplicaDescriptor {
	if m != nil {
		return m.PushedReplica
	}
	return nil
}

type UpdateLogStreamResponse struct {
	LogStream *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"log_stream,omitempty"`
}

func (m *UpdateLogStreamResponse) Reset()         { *m = UpdateLogStreamResponse{} }
func (m *UpdateLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateLogStreamResponse) ProtoMessage()    {}
func (*UpdateLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{15}
}
func (m *UpdateLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLogStreamResponse.Merge(m, src)
}
func (m *UpdateLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLogStreamResponse proto.InternalMessageInfo

func (m *UpdateLogStreamResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type SealRequest struct {
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *SealRequest) Reset()         { *m = SealRequest{} }
func (m *SealRequest) String() string { return proto.CompactTextString(m) }
func (*SealRequest) ProtoMessage()    {}
func (*SealRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{16}
}
func (m *SealRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealRequest.Merge(m, src)
}
func (m *SealRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SealRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SealRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SealRequest proto.InternalMessageInfo

func (m *SealRequest) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *SealRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type SealResponse struct {
	LogStreams []varlogpb.LogStreamMetadataDescriptor            `protobuf:"bytes,1,rep,name=log_streams,json=logStreams,proto3" json:"log_streams"`
	SealedGLSN github_daumkakao_com_varlog_varlog_pkg_types.GLSN `protobuf:"varint,2,opt,name=sealed_glsn,json=sealedGlsn,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"sealed_glsn,omitempty"`
}

func (m *SealResponse) Reset()         { *m = SealResponse{} }
func (m *SealResponse) String() string { return proto.CompactTextString(m) }
func (*SealResponse) ProtoMessage()    {}
func (*SealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{17}
}
func (m *SealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealResponse.Merge(m, src)
}
func (m *SealResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SealResponse proto.InternalMessageInfo

func (m *SealResponse) GetLogStreams() []varlogpb.LogStreamMetadataDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

func (m *SealResponse) GetSealedGLSN() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.SealedGLSN
	}
	return 0
}

type SyncRequest struct {
	TopicID          github_daumkakao_com_varlog_varlog_pkg_types.TopicID       `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID      github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID   `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	SrcStorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,3,opt,name=src_storage_node_id,json=srcStorageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"src_storage_node_id,omitempty"`
	DstStorageNodeID github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,4,opt,name=dst_storage_node_id,json=dstStorageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"dst_storage_node_id,omitempty"`
}

func (m *SyncRequest) Reset()         { *m = SyncRequest{} }
func (m *SyncRequest) String() string { return proto.CompactTextString(m) }
func (*SyncRequest) ProtoMessage()    {}
func (*SyncRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{18}
}
func (m *SyncRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRequest.Merge(m, src)
}
func (m *SyncRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SyncRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRequest proto.InternalMessageInfo

func (m *SyncRequest) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *SyncRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *SyncRequest) GetSrcStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.SrcStorageNodeID
	}
	return 0
}

func (m *SyncRequest) GetDstStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.DstStorageNodeID
	}
	return 0
}

type SyncResponse struct {
	Status *snpb.SyncStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *SyncResponse) Reset()         { *m = SyncResponse{} }
func (m *SyncResponse) String() string { return proto.CompactTextString(m) }
func (*SyncResponse) ProtoMessage()    {}
func (*SyncResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{19}
}
func (m *SyncResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncResponse.Merge(m, src)
}
func (m *SyncResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SyncResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncResponse proto.InternalMessageInfo

func (m *SyncResponse) GetStatus() *snpb.SyncStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type UnsealRequest struct {
	TopicID     github_daumkakao_com_varlog_varlog_pkg_types.TopicID     `protobuf:"varint,1,opt,name=topic_id,json=topicId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.TopicID" json:"topic_id,omitempty"`
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
}

func (m *UnsealRequest) Reset()         { *m = UnsealRequest{} }
func (m *UnsealRequest) String() string { return proto.CompactTextString(m) }
func (*UnsealRequest) ProtoMessage()    {}
func (*UnsealRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{20}
}
func (m *UnsealRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsealRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsealRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsealRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsealRequest.Merge(m, src)
}
func (m *UnsealRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnsealRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsealRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnsealRequest proto.InternalMessageInfo

func (m *UnsealRequest) GetTopicID() github_daumkakao_com_varlog_varlog_pkg_types.TopicID {
	if m != nil {
		return m.TopicID
	}
	return 0
}

func (m *UnsealRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type UnsealResponse struct {
	LogStream *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"log_stream,omitempty"`
}

func (m *UnsealResponse) Reset()         { *m = UnsealResponse{} }
func (m *UnsealResponse) String() string { return proto.CompactTextString(m) }
func (*UnsealResponse) ProtoMessage()    {}
func (*UnsealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{21}
}
func (m *UnsealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsealResponse.Merge(m, src)
}
func (m *UnsealResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnsealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnsealResponse proto.InternalMessageInfo

func (m *UnsealResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type GetMRMembersResponse struct {
	Leader            github_daumkakao_com_varlog_varlog_pkg_types.NodeID            `protobuf:"varint,1,opt,name=leader,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"leader,omitempty"`
	ReplicationFactor int32                                                          `protobuf:"varint,2,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	Members           map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]string `protobuf:"bytes,3,rep,name=members,proto3,castkey=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"members,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GetMRMembersResponse) Reset()         { *m = GetMRMembersResponse{} }
func (m *GetMRMembersResponse) String() string { return proto.CompactTextString(m) }
func (*GetMRMembersResponse) ProtoMessage()    {}
func (*GetMRMembersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{22}
}
func (m *GetMRMembersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMRMembersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMRMembersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMRMembersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMRMembersResponse.Merge(m, src)
}
func (m *GetMRMembersResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetMRMembersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMRMembersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMRMembersResponse proto.InternalMessageInfo

func (m *GetMRMembersResponse) GetLeader() github_daumkakao_com_varlog_varlog_pkg_types.NodeID {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *GetMRMembersResponse) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *GetMRMembersResponse) GetMembers() map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]string {
	if m != nil {
		return m.Members
	}
	return nil
}

type GetStorageNodesResponse struct {
	Storagenodes map[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID]string `protobuf:"bytes,1,rep,name=storagenodes,proto3,castkey=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storagenodes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *GetStorageNodesResponse) Reset()         { *m = GetStorageNodesResponse{} }
func (m *GetStorageNodesResponse) String() string { return proto.CompactTextString(m) }
func (*GetStorageNodesResponse) ProtoMessage()    {}
func (*GetStorageNodesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{23}
}
func (m *GetStorageNodesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStorageNodesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStorageNodesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStorageNodesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStorageNodesResponse.Merge(m, src)
}
func (m *GetStorageNodesResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetStorageNodesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStorageNodesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStorageNodesResponse proto.InternalMessageInfo

func (m *GetStorageNodesResponse) GetStoragenodes() map[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID]string {
	if m != nil {
		return m.Storagenodes
	}
	return nil
}

type AddMRPeerRequest struct {
	RaftURL string `protobuf:"bytes,1,opt,name=raft_url,json=raftUrl,proto3" json:"raft_url,omitempty"`
	RPCAddr string `protobuf:"bytes,2,opt,name=rpc_addr,json=rpcAddr,proto3" json:"rpc_addr,omitempty"`
}

func (m *AddMRPeerRequest) Reset()         { *m = AddMRPeerRequest{} }
func (m *AddMRPeerRequest) String() string { return proto.CompactTextString(m) }
func (*AddMRPeerRequest) ProtoMessage()    {}
func (*AddMRPeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{24}
}
func (m *AddMRPeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMRPeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMRPeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMRPeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMRPeerRequest.Merge(m, src)
}
func (m *AddMRPeerRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddMRPeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMRPeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddMRPeerRequest proto.InternalMessageInfo

func (m *AddMRPeerRequest) GetRaftURL() string {
	if m != nil {
		return m.RaftURL
	}
	return ""
}

func (m *AddMRPeerRequest) GetRPCAddr() string {
	if m != nil {
		return m.RPCAddr
	}
	return ""
}

type AddMRPeerResponse struct {
	NodeID github_daumkakao_com_varlog_varlog_pkg_types.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"node_id,omitempty"`
}

func (m *AddMRPeerResponse) Reset()         { *m = AddMRPeerResponse{} }
func (m *AddMRPeerResponse) String() string { return proto.CompactTextString(m) }
func (*AddMRPeerResponse) ProtoMessage()    {}
func (*AddMRPeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{25}
}
func (m *AddMRPeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMRPeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMRPeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMRPeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMRPeerResponse.Merge(m, src)
}
func (m *AddMRPeerResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddMRPeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMRPeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddMRPeerResponse proto.InternalMessageInfo

func (m *AddMRPeerResponse) GetNodeID() github_daumkakao_com_varlog_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

type RemoveMRPeerRequest struct {
	RaftURL string `protobuf:"bytes,1,opt,name=raft_url,json=raftUrl,proto3" json:"raft_url,omitempty"`
}

func (m *RemoveMRPeerRequest) Reset()         { *m = RemoveMRPeerRequest{} }
func (m *RemoveMRPeerRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveMRPeerRequest) ProtoMessage()    {}
func (*RemoveMRPeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{26}
}
func (m *RemoveMRPeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveMRPeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveMRPeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveMRPeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveMRPeerRequest.Merge(m, src)
}
func (m *RemoveMRPeerRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveMRPeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveMRPeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveMRPeerRequest proto.InternalMessageInfo

func (m *RemoveMRPeerRequest) GetRaftURL() string {
	if m != nil {
		return m.RaftURL
	}
	return ""
}

type RemoveMRPeerResponse struct {
}

func (m *RemoveMRPeerResponse) Reset()         { *m = RemoveMRPeerResponse{} }
func (m *RemoveMRPeerResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveMRPeerResponse) ProtoMessage()    {}
func (*RemoveMRPeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{27}
}
func (m *RemoveMRPeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveMRPeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveMRPeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveMRPeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveMRPeerResponse.Merge(m, src)
}
func (m *RemoveMRPeerResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveMRPeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveMRPeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveMRPeerResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*AddStorageNodeRequest)(nil), "varlog.vmspb.AddStorageNodeRequest")
	proto.RegisterType((*AddStorageNodeResponse)(nil), "varlog.vmspb.AddStorageNodeResponse")
	proto.RegisterType((*UnregisterStorageNodeRequest)(nil), "varlog.vmspb.UnregisterStorageNodeRequest")
	proto.RegisterType((*UnregisterStorageNodeResponse)(nil), "varlog.vmspb.UnregisterStorageNodeResponse")
	proto.RegisterType((*AddTopicRequest)(nil), "varlog.vmspb.AddTopicRequest")
	proto.RegisterType((*AddTopicResponse)(nil), "varlog.vmspb.AddTopicResponse")
	proto.RegisterType((*UnregisterTopicRequest)(nil), "varlog.vmspb.UnregisterTopicRequest")
	proto.RegisterType((*UnregisterTopicResponse)(nil), "varlog.vmspb.UnregisterTopicResponse")
	proto.RegisterType((*AddLogStreamRequest)(nil), "varlog.vmspb.AddLogStreamRequest")
	proto.RegisterType((*AddLogStreamResponse)(nil), "varlog.vmspb.AddLogStreamResponse")
	proto.RegisterType((*UnregisterLogStreamRequest)(nil), "varlog.vmspb.UnregisterLogStreamRequest")
	proto.RegisterType((*UnregisterLogStreamResponse)(nil), "varlog.vmspb.UnregisterLogStreamResponse")
	proto.RegisterType((*RemoveLogStreamReplicaRequest)(nil), "varlog.vmspb.RemoveLogStreamReplicaRequest")
	proto.RegisterType((*RemoveLogStreamReplicaResponse)(nil), "varlog.vmspb.RemoveLogStreamReplicaResponse")
	proto.RegisterType((*UpdateLogStreamRequest)(nil), "varlog.vmspb.UpdateLogStreamRequest")
	proto.RegisterType((*UpdateLogStreamResponse)(nil), "varlog.vmspb.UpdateLogStreamResponse")
	proto.RegisterType((*SealRequest)(nil), "varlog.vmspb.SealRequest")
	proto.RegisterType((*SealResponse)(nil), "varlog.vmspb.SealResponse")
	proto.RegisterType((*SyncRequest)(nil), "varlog.vmspb.SyncRequest")
	proto.RegisterType((*SyncResponse)(nil), "varlog.vmspb.SyncResponse")
	proto.RegisterType((*UnsealRequest)(nil), "varlog.vmspb.UnsealRequest")
	proto.RegisterType((*UnsealResponse)(nil), "varlog.vmspb.UnsealResponse")
	proto.RegisterType((*GetMRMembersResponse)(nil), "varlog.vmspb.GetMRMembersResponse")
	proto.RegisterMapType((map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]string)(nil), "varlog.vmspb.GetMRMembersResponse.MembersEntry")
	proto.RegisterType((*GetStorageNodesResponse)(nil), "varlog.vmspb.GetStorageNodesResponse")
	proto.RegisterMapType((map[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID]string)(nil), "varlog.vmspb.GetStorageNodesResponse.StoragenodesEntry")
	proto.RegisterType((*AddMRPeerRequest)(nil), "varlog.vmspb.AddMRPeerRequest")
	proto.RegisterType((*AddMRPeerResponse)(nil), "varlog.vmspb.AddMRPeerResponse")
	proto.RegisterType((*RemoveMRPeerRequest)(nil), "varlog.vmspb.RemoveMRPeerRequest")
	proto.RegisterType((*RemoveMRPeerResponse)(nil), "varlog.vmspb.RemoveMRPeerResponse")
}

func init() { proto.RegisterFile("proto/vmspb/vms.proto", fileDescriptor_682aff4a3f93d15c) }

var fileDescriptor_682aff4a3f93d15c = []byte{
	// 1408 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xf7, 0x26, 0x4e, 0x9c, 0x3c, 0x3b, 0x3f, 0x3a, 0xf9, 0xd9, 0x6d, 0x63, 0xe7, 0xbb, 0xdf,
	0x16, 0x15, 0x68, 0xd7, 0x6a, 0x8b, 0x68, 0x55, 0x09, 0xaa, 0x38, 0x29, 0x21, 0x34, 0x69, 0xcb,
	0x9a, 0x08, 0xa9, 0x88, 0x9a, 0xb5, 0x67, 0xe2, 0x5a, 0x59, 0x7b, 0xb7, 0x3b, 0xeb, 0x80, 0x8f,
	0xf4, 0x2f, 0xe0, 0xc6, 0x81, 0x0b, 0xff, 0x07, 0x77, 0x54, 0x6e, 0xbd, 0xc1, 0xc9, 0x45, 0x8e,
	0x84, 0xc4, 0x81, 0x3b, 0xea, 0x05, 0xb4, 0x33, 0xb3, 0xbf, 0xbc, 0xeb, 0x34, 0x29, 0x21, 0x48,
	0xb9, 0x24, 0x9e, 0x7d, 0xbf, 0x3e, 0xef, 0xbd, 0x79, 0x6f, 0xe6, 0x0d, 0xcc, 0x59, 0xb6, 0xe9,
	0x98, 0xc5, 0xbd, 0x26, 0xb5, 0xaa, 0xee, 0x5f, 0x95, 0xad, 0x51, 0x6e, 0x4f, 0xb7, 0x0d, 0xb3,
	0xae, 0xb2, 0xef, 0xf2, 0x95, 0x7a, 0xc3, 0x79, 0xdc, 0xae, 0xaa, 0x35, 0xb3, 0x59, 0xac, 0x9b,
	0x75, 0xb3, 0xc8, 0x98, 0xaa, 0xed, 0x1d, 0xb6, 0xe2, 0x1a, 0xdc, 0x5f, 0x5c, 0x58, 0x3e, 0x57,
	0x37, 0xcd, 0xba, 0x41, 0x02, 0x2e, 0xd2, 0xb4, 0x9c, 0x8e, 0x20, 0x2e, 0x70, 0xcd, 0x56, 0xb5,
	0xd8, 0x24, 0x8e, 0x8e, 0x75, 0x47, 0x17, 0x84, 0x39, 0xda, 0xb2, 0xaa, 0x45, 0x9b, 0x58, 0x46,
	0xa3, 0xa6, 0x3b, 0xa6, 0xcd, 0x3f, 0x2b, 0x57, 0x61, 0x6e, 0x05, 0xe3, 0xb2, 0x63, 0xda, 0x7a,
	0x9d, 0xdc, 0x33, 0x31, 0xd1, 0xc8, 0x93, 0x36, 0xa1, 0x0e, 0x5a, 0x84, 0x8c, 0x8e, 0xb1, 0x4d,
	0x28, 0x5d, 0x94, 0x96, 0xa5, 0x4b, 0xe3, 0x9a, 0xb7, 0x54, 0x76, 0x61, 0xbe, 0x5f, 0x84, 0x5a,
	0x66, 0x8b, 0x12, 0xf4, 0x31, 0xe4, 0x28, 0xff, 0x5c, 0x69, 0x99, 0x98, 0x30, 0xc1, 0xec, 0x35,
	0x55, 0xf5, 0xbc, 0x15, 0xd0, 0xd4, 0x90, 0xec, 0x96, 0x40, 0xb9, 0x46, 0x68, 0xcd, 0x6e, 0x58,
	0x8e, 0x69, 0x6b, 0x59, 0x1a, 0x90, 0x95, 0x6f, 0x25, 0x38, 0xbf, 0xdd, 0xb2, 0x49, 0xbd, 0x41,
	0x1d, 0x62, 0x27, 0xe0, 0xfc, 0x12, 0xa6, 0xc2, 0x36, 0x2b, 0x0d, 0xcc, 0xcc, 0x8e, 0x94, 0xee,
	0xf7, 0xba, 0x85, 0x89, 0x90, 0xc0, 0xc6, 0xda, 0xcb, 0x6e, 0xe1, 0x96, 0x08, 0x35, 0xd6, 0xdb,
	0xcd, 0x5d, 0x7d, 0x57, 0x37, 0x59, 0xd0, 0x39, 0x30, 0xef, 0x9f, 0xb5, 0x5b, 0x2f, 0x3a, 0x1d,
	0x8b, 0x50, 0x35, 0x22, 0xad, 0x4d, 0x84, 0x70, 0x6d, 0x60, 0xa5, 0x00, 0x4b, 0x03, 0x80, 0xf1,
	0x68, 0x28, 0x4f, 0x60, 0x6a, 0x05, 0xe3, 0x4f, 0x4c, 0xab, 0x51, 0xf3, 0xc0, 0x3e, 0x82, 0x31,
	0xc7, 0x5d, 0x07, 0x28, 0x57, 0x7b, 0xdd, 0x42, 0x86, 0xf1, 0x30, 0x7c, 0xef, 0x1c, 0x09, 0x9f,
	0x90, 0xd3, 0x32, 0x4c, 0xe9, 0x06, 0x56, 0x3e, 0x82, 0xe9, 0xc0, 0xa4, 0x48, 0xca, 0xbb, 0x30,
	0xc2, 0xc8, 0x22, 0x1b, 0xcb, 0xb1, 0x6c, 0x30, 0xf6, 0x50, 0xfc, 0x39, 0xbb, 0xf2, 0x15, 0xcc,
	0x07, 0xfe, 0x9d, 0xa8, 0x17, 0x67, 0x61, 0x21, 0x66, 0x59, 0xc4, 0xf4, 0x07, 0x09, 0x66, 0x56,
	0x30, 0xde, 0x34, 0xeb, 0x65, 0xc7, 0x26, 0x7a, 0xf3, 0x84, 0x20, 0xa1, 0x35, 0x18, 0x13, 0xa5,
	0x43, 0x17, 0x87, 0x96, 0x87, 0x2f, 0x65, 0xaf, 0x29, 0xb1, 0x38, 0x6a, 0x9c, 0x21, 0x88, 0x64,
	0x29, 0xfd, 0xac, 0x5b, 0x90, 0x34, 0x5f, 0x52, 0xf9, 0x0c, 0x66, 0xa3, 0xe0, 0x45, 0x8a, 0x56,
	0x01, 0x0c, 0xb3, 0x5e, 0xa1, 0xec, 0xab, 0xc8, 0xd3, 0x85, 0x98, 0x7e, 0x5f, 0x2e, 0x94, 0xab,
	0x71, 0xc3, 0xfb, 0xa8, 0xfc, 0x21, 0x81, 0x1c, 0x84, 0xed, 0xc4, 0x23, 0x64, 0xc2, 0x44, 0xe0,
	0x83, 0x6b, 0x64, 0x88, 0x19, 0xb9, 0xdb, 0xeb, 0x16, 0xb2, 0x3e, 0x18, 0x66, 0xe8, 0xe6, 0x91,
	0x0c, 0x85, 0x64, 0xb5, 0xac, 0xef, 0xed, 0x06, 0x56, 0x96, 0xe0, 0x5c, 0xa2, 0xbb, 0x62, 0xa7,
	0xfc, 0x3e, 0x04, 0x4b, 0x1a, 0x69, 0x9a, 0x7b, 0x24, 0x44, 0x63, 0x79, 0xf8, 0xaf, 0x3b, 0x47,
	0x24, 0x15, 0x43, 0x27, 0x91, 0x8a, 0xe1, 0x7f, 0x39, 0x15, 0xcb, 0x90, 0x1f, 0x14, 0x6a, 0x91,
	0x8d, 0xbf, 0x86, 0x60, 0x7e, 0xdb, 0xc2, 0xba, 0x43, 0x4e, 0xfd, 0xc6, 0x44, 0x1b, 0x30, 0x69,
	0x99, 0x96, 0x45, 0x70, 0x45, 0x14, 0x3e, 0x8b, 0xff, 0xa1, 0x3a, 0x86, 0x36, 0xc1, 0x25, 0x05,
	0x81, 0xa9, 0x6a, 0xd3, 0xc7, 0x21, 0x55, 0xe9, 0x23, 0xa8, 0x62, 0x92, 0x82, 0xa0, 0x3c, 0x82,
	0x85, 0x58, 0x02, 0x8e, 0xb3, 0xfd, 0x74, 0x25, 0xc8, 0x96, 0x89, 0x6e, 0x9c, 0xda, 0x7e, 0xf3,
	0x93, 0x04, 0x39, 0xee, 0xa0, 0x08, 0x5b, 0x19, 0xb2, 0x01, 0x02, 0xf7, 0x96, 0xe4, 0x1e, 0x0b,
	0x97, 0x07, 0xc7, 0x2d, 0x7e, 0xd5, 0x61, 0x07, 0x44, 0x4a, 0x03, 0xdf, 0x0c, 0x45, 0x18, 0xb2,
	0x94, 0xe8, 0x06, 0xc1, 0x95, 0xba, 0x41, 0x5b, 0xcc, 0xa9, 0x34, 0x8b, 0x1c, 0x94, 0xd9, 0xe7,
	0xf5, 0xcd, 0xf2, 0xbd, 0x97, 0xdd, 0xc2, 0xd5, 0x23, 0xf9, 0xe4, 0x0a, 0x69, 0xc0, 0xf5, 0xae,
	0x1b, 0xb4, 0xa5, 0xfc, 0x36, 0x0c, 0xd9, 0x72, 0xa7, 0x55, 0x3b, 0xb5, 0x35, 0xf8, 0xb5, 0x04,
	0x33, 0xd4, 0xae, 0x55, 0xfa, 0x1b, 0x3c, 0xef, 0x84, 0x5a, 0xaf, 0x5b, 0x98, 0x2e, 0xdb, 0xb5,
	0xe3, 0xec, 0xf1, 0xd3, 0x34, 0xaa, 0x8f, 0x63, 0xc0, 0xd4, 0x89, 0x61, 0x48, 0x07, 0x18, 0xd6,
	0xa8, 0x73, 0xac, 0x18, 0x70, 0x54, 0x1f, 0x56, 0x6e, 0x43, 0x8e, 0xe7, 0x59, 0xec, 0xd9, 0x22,
	0x8c, 0x52, 0x47, 0x77, 0xda, 0x54, 0x94, 0xf9, 0x82, 0xb7, 0x5d, 0xdd, 0xe9, 0x40, 0x75, 0x59,
	0xcb, 0x8c, 0xac, 0x09, 0x36, 0xe5, 0x57, 0x09, 0x26, 0xb6, 0x5b, 0xf4, 0x34, 0x17, 0xf6, 0x36,
	0x4c, 0x7a, 0x1e, 0x1e, 0x67, 0x43, 0xfc, 0x79, 0x08, 0x66, 0xd7, 0x89, 0xb3, 0xa5, 0x6d, 0x91,
	0x66, 0x95, 0xd8, 0xd4, 0xd7, 0x7e, 0x1f, 0x46, 0x0d, 0xa2, 0x63, 0x62, 0x33, 0xcd, 0xe9, 0xd2,
	0x8d, 0x97, 0xdd, 0xc2, 0xf5, 0x23, 0xb9, 0x22, 0xd2, 0x2d, 0xd4, 0xa0, 0x2b, 0x80, 0xbc, 0xb9,
	0xae, 0x61, 0xb6, 0x2a, 0x3b, 0x7a, 0xcd, 0x31, 0x6d, 0x1e, 0x36, 0xed, 0x4c, 0x88, 0xf2, 0x01,
	0x23, 0xa0, 0xa7, 0x12, 0x64, 0x9a, 0x1c, 0xd3, 0xe2, 0x30, 0x6b, 0x5a, 0x45, 0x35, 0x3c, 0x8f,
	0xaa, 0x49, 0xa8, 0x55, 0xb1, 0xbe, 0xd3, 0x72, 0xec, 0x4e, 0xe9, 0xc6, 0xd3, 0x17, 0xaf, 0x07,
	0xd9, 0x33, 0x2c, 0xdf, 0x82, 0x5c, 0x58, 0x23, 0x9a, 0x86, 0xe1, 0x5d, 0xd2, 0xe1, 0x11, 0xd1,
	0xdc, 0x9f, 0x68, 0x16, 0x46, 0xf6, 0x74, 0xa3, 0x4d, 0x98, 0x23, 0xe3, 0x1a, 0x5f, 0xdc, 0x1a,
	0xba, 0x29, 0x29, 0x7f, 0x4a, 0xb0, 0xb0, 0x4e, 0xc2, 0x3b, 0x3d, 0x08, 0xee, 0x77, 0x92, 0x3f,
	0x83, 0xba, 0xf5, 0xe6, 0xb5, 0xe5, 0x1b, 0x31, 0x0f, 0x93, 0xa4, 0xbd, 0x72, 0x62, 0x92, 0xdc,
	0xd3, 0xf7, 0x9f, 0xbe, 0xf8, 0x47, 0x25, 0x19, 0x01, 0x23, 0xdf, 0x86, 0x33, 0x31, 0x13, 0x61,
	0xd7, 0x47, 0x5e, 0xe5, 0x7a, 0x95, 0x0d, 0x78, 0x5b, 0xda, 0x03, 0x42, 0x6c, 0xaf, 0x20, 0xdf,
	0x80, 0x31, 0x5b, 0xdf, 0x71, 0x2a, 0x6d, 0xdb, 0xe0, 0xa3, 0x7a, 0x29, 0xeb, 0x16, 0xa4, 0xa6,
	0xef, 0x38, 0xdb, 0xda, 0xa6, 0x96, 0x71, 0x89, 0xdb, 0xb6, 0xc1, 0xf8, 0xac, 0x5a, 0xc5, 0x1d,
	0xe3, 0xb9, 0x62, 0xc1, 0xf7, 0x60, 0x75, 0x05, 0x63, 0x5b, 0xcb, 0xd8, 0x56, 0xcd, 0xfd, 0xa1,
	0x98, 0x70, 0x26, 0x64, 0x43, 0xc4, 0xf5, 0x21, 0x64, 0xc2, 0x97, 0xe4, 0x74, 0x69, 0xa5, 0xd7,
	0x2d, 0x8c, 0xfa, 0x5d, 0xeb, 0xf5, 0xf6, 0x6f, 0x8b, 0x37, 0xa9, 0xf7, 0x60, 0x86, 0x5f, 0x1f,
	0x5f, 0xcb, 0x2f, 0x65, 0x1e, 0x66, 0xa3, 0xe2, 0x1c, 0xf2, 0xb5, 0x1f, 0x01, 0x26, 0x57, 0x8d,
	0xb6, 0x3b, 0x1e, 0x6c, 0xe9, 0x2d, 0xbd, 0x4e, 0x6c, 0xf4, 0x39, 0x4c, 0x46, 0x9f, 0x2e, 0xd0,
	0xff, 0xa3, 0x1b, 0x23, 0xf1, 0x2d, 0x44, 0xbe, 0x70, 0x30, 0x93, 0xb8, 0xe3, 0xa6, 0x90, 0x0d,
	0x73, 0x89, 0x4f, 0x02, 0xe8, 0xad, 0xa8, 0x82, 0x83, 0x1e, 0x34, 0xe4, 0xb7, 0x0f, 0xc5, 0xeb,
	0xdb, 0xbc, 0x0b, 0x63, 0xde, 0xc8, 0x8f, 0x96, 0x62, 0x38, 0xc3, 0x73, 0xbb, 0x9c, 0x1f, 0x44,
	0xf6, 0x95, 0x7d, 0x01, 0x53, 0x7d, 0x93, 0x37, 0xba, 0x30, 0x08, 0x4e, 0x44, 0xf5, 0xc5, 0x57,
	0x70, 0xf9, 0x16, 0x3e, 0x85, 0x5c, 0x78, 0x04, 0x46, 0xff, 0x8b, 0x61, 0xea, 0x1f, 0x10, 0x64,
	0xe5, 0x20, 0x16, 0x5f, 0xb1, 0x01, 0x33, 0x09, 0xe3, 0x20, 0xba, 0x34, 0x08, 0x58, 0xcc, 0xcc,
	0x9b, 0x87, 0xe0, 0xf4, 0xad, 0xb5, 0x61, 0x3e, 0x79, 0xe2, 0x41, 0x7d, 0xe9, 0x3b, 0x70, 0x04,
	0x95, 0x2f, 0x1f, 0x8e, 0x39, 0x92, 0x9f, 0xe8, 0x25, 0x3e, 0x96, 0x9f, 0xc4, 0x21, 0x2b, 0x96,
	0x9f, 0xe4, 0x49, 0x40, 0x49, 0xa1, 0xdb, 0x90, 0x76, 0x2f, 0x9a, 0xe8, 0x6c, 0x54, 0x20, 0x74,
	0xb3, 0x97, 0xe5, 0x24, 0x52, 0x44, 0x41, 0xa7, 0x55, 0x8b, 0x29, 0x08, 0x6e, 0x9b, 0x31, 0x05,
	0xa1, 0x0b, 0x8a, 0x92, 0x42, 0x77, 0x60, 0x94, 0x1f, 0xc7, 0xe8, 0x5c, 0x7f, 0x46, 0x42, 0xd7,
	0x10, 0xf9, 0x7c, 0x32, 0xd1, 0x57, 0xb3, 0x09, 0xb9, 0xf0, 0x39, 0x86, 0xe6, 0x55, 0xfe, 0x6c,
	0xaa, 0x7a, 0xcf, 0xa6, 0xea, 0x9d, 0xa6, 0xe5, 0x74, 0xfa, 0x77, 0x57, 0xd2, 0xd9, 0xa7, 0xa4,
	0xd0, 0x3d, 0x18, 0xf7, 0x7b, 0x22, 0x8a, 0xd7, 0x51, 0xa4, 0x71, 0xc9, 0x85, 0x81, 0xf4, 0x70,
	0x19, 0x84, 0x7b, 0x56, 0x7f, 0x19, 0x24, 0xb4, 0xc3, 0x7e, 0xa0, 0x49, 0x2d, 0x4f, 0x49, 0x21,
	0x0d, 0xa6, 0xfa, 0x0e, 0xb7, 0x81, 0x9e, 0x5f, 0x3c, 0xd4, 0x99, 0xa8, 0xa4, 0x4a, 0x1f, 0x3e,
	0xeb, 0xe5, 0xa5, 0xe7, 0xbd, 0xbc, 0xf4, 0xcd, 0x7e, 0x3e, 0xf5, 0xfd, 0x7e, 0x5e, 0x7a, 0xbe,
	0x9f, 0x4f, 0xfd, 0xb2, 0x9f, 0x4f, 0x3d, 0x54, 0x0f, 0xd3, 0xf6, 0x83, 0x17, 0xf0, 0xea, 0x28,
	0x5b, 0x5c, 0xff, 0x3b, 0x00, 0x00, 0xff, 0xff, 0xa5, 0x49, 0xbf, 0xe5, 0x17, 0x17, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClusterManagerClient is the client API for ClusterManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterManagerClient interface {
	AddStorageNode(ctx context.Context, in *AddStorageNodeRequest, opts ...grpc.CallOption) (*AddStorageNodeResponse, error)
	UnregisterStorageNode(ctx context.Context, in *UnregisterStorageNodeRequest, opts ...grpc.CallOption) (*UnregisterStorageNodeResponse, error)
	AddTopic(ctx context.Context, in *AddTopicRequest, opts ...grpc.CallOption) (*AddTopicResponse, error)
	UnregisterTopic(ctx context.Context, in *UnregisterTopicRequest, opts ...grpc.CallOption) (*UnregisterTopicResponse, error)
	AddLogStream(ctx context.Context, in *AddLogStreamRequest, opts ...grpc.CallOption) (*AddLogStreamResponse, error)
	UnregisterLogStream(ctx context.Context, in *UnregisterLogStreamRequest, opts ...grpc.CallOption) (*UnregisterLogStreamResponse, error)
	RemoveLogStreamReplica(ctx context.Context, in *RemoveLogStreamReplicaRequest, opts ...grpc.CallOption) (*RemoveLogStreamReplicaResponse, error)
	UpdateLogStream(ctx context.Context, in *UpdateLogStreamRequest, opts ...grpc.CallOption) (*UpdateLogStreamResponse, error)
	Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error)
	Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error)
	Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error)
	GetMRMembers(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetMRMembersResponse, error)
	AddMRPeer(ctx context.Context, in *AddMRPeerRequest, opts ...grpc.CallOption) (*AddMRPeerResponse, error)
	RemoveMRPeer(ctx context.Context, in *RemoveMRPeerRequest, opts ...grpc.CallOption) (*RemoveMRPeerResponse, error)
	GetStorageNodes(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetStorageNodesResponse, error)
}

type clusterManagerClient struct {
	cc *grpc.ClientConn
}

func NewClusterManagerClient(cc *grpc.ClientConn) ClusterManagerClient {
	return &clusterManagerClient{cc}
}

func (c *clusterManagerClient) AddStorageNode(ctx context.Context, in *AddStorageNodeRequest, opts ...grpc.CallOption) (*AddStorageNodeResponse, error) {
	out := new(AddStorageNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/AddStorageNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UnregisterStorageNode(ctx context.Context, in *UnregisterStorageNodeRequest, opts ...grpc.CallOption) (*UnregisterStorageNodeResponse, error) {
	out := new(UnregisterStorageNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/UnregisterStorageNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddTopic(ctx context.Context, in *AddTopicRequest, opts ...grpc.CallOption) (*AddTopicResponse, error) {
	out := new(AddTopicResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/AddTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UnregisterTopic(ctx context.Context, in *UnregisterTopicRequest, opts ...grpc.CallOption) (*UnregisterTopicResponse, error) {
	out := new(UnregisterTopicResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/UnregisterTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddLogStream(ctx context.Context, in *AddLogStreamRequest, opts ...grpc.CallOption) (*AddLogStreamResponse, error) {
	out := new(AddLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/AddLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UnregisterLogStream(ctx context.Context, in *UnregisterLogStreamRequest, opts ...grpc.CallOption) (*UnregisterLogStreamResponse, error) {
	out := new(UnregisterLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/UnregisterLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) RemoveLogStreamReplica(ctx context.Context, in *RemoveLogStreamReplicaRequest, opts ...grpc.CallOption) (*RemoveLogStreamReplicaResponse, error) {
	out := new(RemoveLogStreamReplicaResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/RemoveLogStreamReplica", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UpdateLogStream(ctx context.Context, in *UpdateLogStreamRequest, opts ...grpc.CallOption) (*UpdateLogStreamResponse, error) {
	out := new(UpdateLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/UpdateLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error) {
	out := new(SealResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/Seal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error) {
	out := new(SyncResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/Sync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error) {
	out := new(UnsealResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/Unseal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) GetMRMembers(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetMRMembersResponse, error) {
	out := new(GetMRMembersResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/GetMRMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddMRPeer(ctx context.Context, in *AddMRPeerRequest, opts ...grpc.CallOption) (*AddMRPeerResponse, error) {
	out := new(AddMRPeerResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/AddMRPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) RemoveMRPeer(ctx context.Context, in *RemoveMRPeerRequest, opts ...grpc.CallOption) (*RemoveMRPeerResponse, error) {
	out := new(RemoveMRPeerResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/RemoveMRPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) GetStorageNodes(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetStorageNodesResponse, error) {
	out := new(GetStorageNodesResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/GetStorageNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterManagerServer is the server API for ClusterManager service.
type ClusterManagerServer interface {
	AddStorageNode(context.Context, *AddStorageNodeRequest) (*AddStorageNodeResponse, error)
	UnregisterStorageNode(context.Context, *UnregisterStorageNodeRequest) (*UnregisterStorageNodeResponse, error)
	AddTopic(context.Context, *AddTopicRequest) (*AddTopicResponse, error)
	UnregisterTopic(context.Context, *UnregisterTopicRequest) (*UnregisterTopicResponse, error)
	AddLogStream(context.Context, *AddLogStreamRequest) (*AddLogStreamResponse, error)
	UnregisterLogStream(context.Context, *UnregisterLogStreamRequest) (*UnregisterLogStreamResponse, error)
	RemoveLogStreamReplica(context.Context, *RemoveLogStreamReplicaRequest) (*RemoveLogStreamReplicaResponse, error)
	UpdateLogStream(context.Context, *UpdateLogStreamRequest) (*UpdateLogStreamResponse, error)
	Seal(context.Context, *SealRequest) (*SealResponse, error)
	Sync(context.Context, *SyncRequest) (*SyncResponse, error)
	Unseal(context.Context, *UnsealRequest) (*UnsealResponse, error)
	GetMRMembers(context.Context, *types.Empty) (*GetMRMembersResponse, error)
	AddMRPeer(context.Context, *AddMRPeerRequest) (*AddMRPeerResponse, error)
	RemoveMRPeer(context.Context, *RemoveMRPeerRequest) (*RemoveMRPeerResponse, error)
	GetStorageNodes(context.Context, *types.Empty) (*GetStorageNodesResponse, error)
}

// UnimplementedClusterManagerServer can be embedded to have forward compatible implementations.
type UnimplementedClusterManagerServer struct {
}

func (*UnimplementedClusterManagerServer) AddStorageNode(ctx context.Context, req *AddStorageNodeRequest) (*AddStorageNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddStorageNode not implemented")
}
func (*UnimplementedClusterManagerServer) UnregisterStorageNode(ctx context.Context, req *UnregisterStorageNodeRequest) (*UnregisterStorageNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterStorageNode not implemented")
}
func (*UnimplementedClusterManagerServer) AddTopic(ctx context.Context, req *AddTopicRequest) (*AddTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddTopic not implemented")
}
func (*UnimplementedClusterManagerServer) UnregisterTopic(ctx context.Context, req *UnregisterTopicRequest) (*UnregisterTopicResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterTopic not implemented")
}
func (*UnimplementedClusterManagerServer) AddLogStream(ctx context.Context, req *AddLogStreamRequest) (*AddLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) UnregisterLogStream(ctx context.Context, req *UnregisterLogStreamRequest) (*UnregisterLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) RemoveLogStreamReplica(ctx context.Context, req *RemoveLogStreamReplicaRequest) (*RemoveLogStreamReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveLogStreamReplica not implemented")
}
func (*UnimplementedClusterManagerServer) UpdateLogStream(ctx context.Context, req *UpdateLogStreamRequest) (*UpdateLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) Seal(ctx context.Context, req *SealRequest) (*SealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seal not implemented")
}
func (*UnimplementedClusterManagerServer) Sync(ctx context.Context, req *SyncRequest) (*SyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sync not implemented")
}
func (*UnimplementedClusterManagerServer) Unseal(ctx context.Context, req *UnsealRequest) (*UnsealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unseal not implemented")
}
func (*UnimplementedClusterManagerServer) GetMRMembers(ctx context.Context, req *types.Empty) (*GetMRMembersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMRMembers not implemented")
}
func (*UnimplementedClusterManagerServer) AddMRPeer(ctx context.Context, req *AddMRPeerRequest) (*AddMRPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMRPeer not implemented")
}
func (*UnimplementedClusterManagerServer) RemoveMRPeer(ctx context.Context, req *RemoveMRPeerRequest) (*RemoveMRPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveMRPeer not implemented")
}
func (*UnimplementedClusterManagerServer) GetStorageNodes(ctx context.Context, req *types.Empty) (*GetStorageNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorageNodes not implemented")
}

func RegisterClusterManagerServer(s *grpc.Server, srv ClusterManagerServer) {
	s.RegisterService(&_ClusterManager_serviceDesc, srv)
}

func _ClusterManager_AddStorageNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddStorageNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddStorageNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/AddStorageNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddStorageNode(ctx, req.(*AddStorageNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UnregisterStorageNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterStorageNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UnregisterStorageNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/UnregisterStorageNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UnregisterStorageNode(ctx, req.(*UnregisterStorageNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/AddTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddTopic(ctx, req.(*AddTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UnregisterTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UnregisterTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/UnregisterTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UnregisterTopic(ctx, req.(*UnregisterTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/AddLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddLogStream(ctx, req.(*AddLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UnregisterLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UnregisterLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/UnregisterLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UnregisterLogStream(ctx, req.(*UnregisterLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_RemoveLogStreamReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveLogStreamReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).RemoveLogStreamReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/RemoveLogStreamReplica",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).RemoveLogStreamReplica(ctx, req.(*RemoveLogStreamReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UpdateLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UpdateLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/UpdateLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UpdateLogStream(ctx, req.(*UpdateLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Seal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Seal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/Seal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Seal(ctx, req.(*SealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Sync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Sync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/Sync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Sync(ctx, req.(*SyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Unseal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Unseal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/Unseal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Unseal(ctx, req.(*UnsealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_GetMRMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).GetMRMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/GetMRMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).GetMRMembers(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddMRPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMRPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddMRPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/AddMRPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddMRPeer(ctx, req.(*AddMRPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_RemoveMRPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveMRPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).RemoveMRPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/RemoveMRPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).RemoveMRPeer(ctx, req.(*RemoveMRPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_GetStorageNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).GetStorageNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/GetStorageNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).GetStorageNodes(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClusterManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "varlog.vmspb.ClusterManager",
	HandlerType: (*ClusterManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddStorageNode",
			Handler:    _ClusterManager_AddStorageNode_Handler,
		},
		{
			MethodName: "UnregisterStorageNode",
			Handler:    _ClusterManager_UnregisterStorageNode_Handler,
		},
		{
			MethodName: "AddTopic",
			Handler:    _ClusterManager_AddTopic_Handler,
		},
		{
			MethodName: "UnregisterTopic",
			Handler:    _ClusterManager_UnregisterTopic_Handler,
		},
		{
			MethodName: "AddLogStream",
			Handler:    _ClusterManager_AddLogStream_Handler,
		},
		{
			MethodName: "UnregisterLogStream",
			Handler:    _ClusterManager_UnregisterLogStream_Handler,
		},
		{
			MethodName: "RemoveLogStreamReplica",
			Handler:    _ClusterManager_RemoveLogStreamReplica_Handler,
		},
		{
			MethodName: "UpdateLogStream",
			Handler:    _ClusterManager_UpdateLogStream_Handler,
		},
		{
			MethodName: "Seal",
			Handler:    _ClusterManager_Seal_Handler,
		},
		{
			MethodName: "Sync",
			Handler:    _ClusterManager_Sync_Handler,
		},
		{
			MethodName: "Unseal",
			Handler:    _ClusterManager_Unseal_Handler,
		},
		{
			MethodName: "GetMRMembers",
			Handler:    _ClusterManager_GetMRMembers_Handler,
		},
		{
			MethodName: "AddMRPeer",
			Handler:    _ClusterManager_AddMRPeer_Handler,
		},
		{
			MethodName: "RemoveMRPeer",
			Handler:    _ClusterManager_RemoveMRPeer_Handler,
		},
		{
			MethodName: "GetStorageNodes",
			Handler:    _ClusterManager_GetStorageNodes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/vmspb/vms.proto",
}

func (m *AddStorageNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStorageNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddStorageNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintVms(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddStorageNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStorageNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddStorageNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageNode != nil {
		{
			size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterStorageNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterStorageNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterStorageNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterStorageNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterStorageNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterStorageNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AddTopicRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTopicRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTopicRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TopicID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddTopicResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddTopicResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddTopicResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Topic != nil {
		{
			size, err := m.Topic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterTopicRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterTopicRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterTopicRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TopicID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterTopicResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterTopicResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterTopicResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AddLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVms(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TopicID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AddLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *RemoveLogStreamReplicaRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveLogStreamReplicaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveLogStreamReplicaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x18
	}
	if m.TopicID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x10
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveLogStreamReplicaResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveLogStreamReplicaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveLogStreamReplicaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *UpdateLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PushedReplica != nil {
		{
			size, err := m.PushedReplica.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PoppedReplica != nil {
		{
			size, err := m.PoppedReplica.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SealRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SealResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SealedGLSN != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.SealedGLSN))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVms(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DstStorageNodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.DstStorageNodeID))
		i--
		dAtA[i] = 0x20
	}
	if m.SrcStorageNodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.SrcStorageNodeID))
		i--
		dAtA[i] = 0x18
	}
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnsealRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsealRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsealRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.TopicID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.TopicID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnsealResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMRMembersResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMRMembersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMRMembersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for k := range m.Members {
			v := m.Members[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintVms(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintVms(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintVms(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x10
	}
	if m.Leader != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetStorageNodesResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStorageNodesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStorageNodesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Storagenodes) > 0 {
		for k := range m.Storagenodes {
			v := m.Storagenodes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintVms(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintVms(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintVms(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddMRPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMRPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMRPeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RPCAddr) > 0 {
		i -= len(m.RPCAddr)
		copy(dAtA[i:], m.RPCAddr)
		i = encodeVarintVms(dAtA, i, uint64(len(m.RPCAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RaftURL) > 0 {
		i -= len(m.RaftURL)
		copy(dAtA[i:], m.RaftURL)
		i = encodeVarintVms(dAtA, i, uint64(len(m.RaftURL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMRPeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMRPeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMRPeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveMRPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveMRPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveMRPeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RaftURL) > 0 {
		i -= len(m.RaftURL)
		copy(dAtA[i:], m.RaftURL)
		i = encodeVarintVms(dAtA, i, uint64(len(m.RaftURL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveMRPeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveMRPeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveMRPeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintVms(dAtA []byte, offset int, v uint64) int {
	offset -= sovVms(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AddStorageNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *AddStorageNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNode != nil {
		l = m.StorageNode.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *UnregisterStorageNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovVms(uint64(m.StorageNodeID))
	}
	return n
}

func (m *UnregisterStorageNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AddTopicRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovVms(uint64(m.TopicID))
	}
	return n
}

func (m *AddTopicResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Topic != nil {
		l = m.Topic.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *UnregisterTopicRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovVms(uint64(m.TopicID))
	}
	return n
}

func (m *UnregisterTopicResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AddLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovVms(uint64(m.TopicID))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.ProtoSize()
			n += 1 + l + sovVms(uint64(l))
		}
	}
	return n
}

func (m *AddLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *UnregisterLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovVms(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	return n
}

func (m *UnregisterLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *RemoveLogStreamReplicaRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovVms(uint64(m.StorageNodeID))
	}
	if m.TopicID != 0 {
		n += 1 + sovVms(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	return n
}

func (m *RemoveLogStreamReplicaResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *UpdateLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovVms(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	if m.PoppedReplica != nil {
		l = m.PoppedReplica.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	if m.PushedReplica != nil {
		l = m.PushedReplica.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *UpdateLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *SealRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovVms(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	return n
}

func (m *SealResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovVms(uint64(l))
		}
	}
	if m.SealedGLSN != 0 {
		n += 1 + sovVms(uint64(m.SealedGLSN))
	}
	return n
}

func (m *SyncRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovVms(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	if m.SrcStorageNodeID != 0 {
		n += 1 + sovVms(uint64(m.SrcStorageNodeID))
	}
	if m.DstStorageNodeID != 0 {
		n += 1 + sovVms(uint64(m.DstStorageNodeID))
	}
	return n
}

func (m *SyncResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *UnsealRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TopicID != 0 {
		n += 1 + sovVms(uint64(m.TopicID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	return n
}

func (m *UnsealResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *GetMRMembersResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leader != 0 {
		n += 1 + sovVms(uint64(m.Leader))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovVms(uint64(m.ReplicationFactor))
	}
	if len(m.Members) > 0 {
		for k, v := range m.Members {
			_ = k
			_ = v
			mapEntrySize := 1 + sovVms(uint64(k)) + 1 + len(v) + sovVms(uint64(len(v)))
			n += mapEntrySize + 1 + sovVms(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *GetStorageNodesResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Storagenodes) > 0 {
		for k, v := range m.Storagenodes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovVms(uint64(k)) + 1 + len(v) + sovVms(uint64(len(v)))
			n += mapEntrySize + 1 + sovVms(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AddMRPeerRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RaftURL)
	if l > 0 {
		n += 1 + l + sovVms(uint64(l))
	}
	l = len(m.RPCAddr)
	if l > 0 {
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *AddMRPeerResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovVms(uint64(m.NodeID))
	}
	return n
}

func (m *RemoveMRPeerRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RaftURL)
	if l > 0 {
		n += 1 + l + sovVms(uint64(l))
	}
	return n
}

func (m *RemoveMRPeerResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovVms(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVms(x uint64) (n int) {
	return sovVms(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddStorageNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddStorageNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddStorageNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddStorageNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddStorageNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddStorageNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageNode == nil {
				m.StorageNode = &varlogpb.StorageNodeMetadataDescriptor{}
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterStorageNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterStorageNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterStorageNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterStorageNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterStorageNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterStorageNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTopicRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTopicRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTopicRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddTopicResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddTopicResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddTopicResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Topic == nil {
				m.Topic = &varlogpb.TopicDescriptor{}
			}
			if err := m.Topic.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterTopicRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterTopicRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterTopicRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterTopicResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterTopicResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterTopicResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &varlogpb.ReplicaDescriptor{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveLogStreamReplicaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveLogStreamReplicaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoppedReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoppedReplica == nil {
				m.PoppedReplica = &varlogpb.ReplicaDescriptor{}
			}
			if err := m.PoppedReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushedReplica == nil {
				m.PushedReplica = &varlogpb.ReplicaDescriptor{}
			}
			if err := m.PushedReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, varlogpb.LogStreamMetadataDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedGLSN", wireType)
			}
			m.SealedGLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SealedGLSN |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcStorageNodeID", wireType)
			}
			m.SrcStorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcStorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstStorageNodeID", wireType)
			}
			m.DstStorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstStorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &snpb.SyncStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsealRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsealRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsealRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopicID", wireType)
			}
			m.TopicID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopicID |= github_daumkakao_com_varlog_varlog_pkg_types.TopicID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMRMembersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMRMembersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMRMembersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= github_daumkakao_com_varlog_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Members == nil {
				m.Members = make(map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVms
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVms
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVms
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthVms
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthVms
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVms(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthVms
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Members[github_daumkakao_com_varlog_varlog_pkg_types.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStorageNodesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStorageNodesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStorageNodesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storagenodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Storagenodes == nil {
				m.Storagenodes = make(map[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID]string)
			}
			var mapkey int32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVms
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVms
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVms
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthVms
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthVms
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVms(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthVms
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Storagenodes[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMRPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMRPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMRPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RPCAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMRPeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMRPeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMRPeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_daumkakao_com_varlog_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveMRPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveMRPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveMRPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveMRPeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveMRPeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveMRPeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVms(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVms
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVms
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVms
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVms
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVms
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVms
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVms        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVms          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVms = fmt.Errorf("proto: unexpected end of group")
)
