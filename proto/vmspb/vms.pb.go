// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/vmspb/vms.proto

package vmspb

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	github_daumkakao_com_varlog_varlog_pkg_types "github.daumkakao.com/varlog/varlog/pkg/types"
	snpb "github.daumkakao.com/varlog/varlog/proto/snpb"
	varlogpb "github.daumkakao.com/varlog/varlog/proto/varlogpb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AddStorageNodeRequest struct {
	// address is IP of a node to be added to the cluster.
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddStorageNodeRequest) Reset()         { *m = AddStorageNodeRequest{} }
func (m *AddStorageNodeRequest) String() string { return proto.CompactTextString(m) }
func (*AddStorageNodeRequest) ProtoMessage()    {}
func (*AddStorageNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{0}
}
func (m *AddStorageNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddStorageNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddStorageNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddStorageNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddStorageNodeRequest.Merge(m, src)
}
func (m *AddStorageNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddStorageNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddStorageNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddStorageNodeRequest proto.InternalMessageInfo

func (m *AddStorageNodeRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type AddStorageNodeResponse struct {
	StorageNode          *varlogpb.StorageNodeMetadataDescriptor `protobuf:"bytes,1,opt,name=storage_node,json=storageNode,proto3" json:"storage_node,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                `json:"-"`
	XXX_unrecognized     []byte                                  `json:"-"`
	XXX_sizecache        int32                                   `json:"-"`
}

func (m *AddStorageNodeResponse) Reset()         { *m = AddStorageNodeResponse{} }
func (m *AddStorageNodeResponse) String() string { return proto.CompactTextString(m) }
func (*AddStorageNodeResponse) ProtoMessage()    {}
func (*AddStorageNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{1}
}
func (m *AddStorageNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddStorageNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddStorageNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddStorageNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddStorageNodeResponse.Merge(m, src)
}
func (m *AddStorageNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddStorageNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddStorageNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddStorageNodeResponse proto.InternalMessageInfo

func (m *AddStorageNodeResponse) GetStorageNode() *varlogpb.StorageNodeMetadataDescriptor {
	if m != nil {
		return m.StorageNode
	}
	return nil
}

type UnregisterStorageNodeRequest struct {
	StorageNodeID        github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                   `json:"-"`
	XXX_unrecognized     []byte                                                     `json:"-"`
	XXX_sizecache        int32                                                      `json:"-"`
}

func (m *UnregisterStorageNodeRequest) Reset()         { *m = UnregisterStorageNodeRequest{} }
func (m *UnregisterStorageNodeRequest) String() string { return proto.CompactTextString(m) }
func (*UnregisterStorageNodeRequest) ProtoMessage()    {}
func (*UnregisterStorageNodeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{2}
}
func (m *UnregisterStorageNodeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterStorageNodeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterStorageNodeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterStorageNodeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterStorageNodeRequest.Merge(m, src)
}
func (m *UnregisterStorageNodeRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterStorageNodeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterStorageNodeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterStorageNodeRequest proto.InternalMessageInfo

func (m *UnregisterStorageNodeRequest) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

type UnregisterStorageNodeResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnregisterStorageNodeResponse) Reset()         { *m = UnregisterStorageNodeResponse{} }
func (m *UnregisterStorageNodeResponse) String() string { return proto.CompactTextString(m) }
func (*UnregisterStorageNodeResponse) ProtoMessage()    {}
func (*UnregisterStorageNodeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{3}
}
func (m *UnregisterStorageNodeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterStorageNodeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterStorageNodeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterStorageNodeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterStorageNodeResponse.Merge(m, src)
}
func (m *UnregisterStorageNodeResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterStorageNodeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterStorageNodeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterStorageNodeResponse proto.InternalMessageInfo

type AddLogStreamRequest struct {
	// TODO: nullable = false
	Replicas             []*varlogpb.ReplicaDescriptor `protobuf:"bytes,1,rep,name=replicas,proto3" json:"replicas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *AddLogStreamRequest) Reset()         { *m = AddLogStreamRequest{} }
func (m *AddLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*AddLogStreamRequest) ProtoMessage()    {}
func (*AddLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{4}
}
func (m *AddLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddLogStreamRequest.Merge(m, src)
}
func (m *AddLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddLogStreamRequest proto.InternalMessageInfo

func (m *AddLogStreamRequest) GetReplicas() []*varlogpb.ReplicaDescriptor {
	if m != nil {
		return m.Replicas
	}
	return nil
}

type AddLogStreamResponse struct {
	LogStream            *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"log_stream,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *AddLogStreamResponse) Reset()         { *m = AddLogStreamResponse{} }
func (m *AddLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*AddLogStreamResponse) ProtoMessage()    {}
func (*AddLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{5}
}
func (m *AddLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddLogStreamResponse.Merge(m, src)
}
func (m *AddLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddLogStreamResponse proto.InternalMessageInfo

func (m *AddLogStreamResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type UnregisterLogStreamRequest struct {
	LogStreamID          github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,1,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                 `json:"-"`
	XXX_unrecognized     []byte                                                   `json:"-"`
	XXX_sizecache        int32                                                    `json:"-"`
}

func (m *UnregisterLogStreamRequest) Reset()         { *m = UnregisterLogStreamRequest{} }
func (m *UnregisterLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*UnregisterLogStreamRequest) ProtoMessage()    {}
func (*UnregisterLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{6}
}
func (m *UnregisterLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterLogStreamRequest.Merge(m, src)
}
func (m *UnregisterLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterLogStreamRequest proto.InternalMessageInfo

func (m *UnregisterLogStreamRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type UnregisterLogStreamResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnregisterLogStreamResponse) Reset()         { *m = UnregisterLogStreamResponse{} }
func (m *UnregisterLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*UnregisterLogStreamResponse) ProtoMessage()    {}
func (*UnregisterLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{7}
}
func (m *UnregisterLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnregisterLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnregisterLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnregisterLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnregisterLogStreamResponse.Merge(m, src)
}
func (m *UnregisterLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnregisterLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnregisterLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnregisterLogStreamResponse proto.InternalMessageInfo

type RemoveLogStreamReplicaRequest struct {
	StorageNodeID        github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,1,opt,name=storage_node_id,json=storageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storage_node_id,omitempty"`
	LogStreamID          github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID   `protobuf:"varint,2,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                   `json:"-"`
	XXX_unrecognized     []byte                                                     `json:"-"`
	XXX_sizecache        int32                                                      `json:"-"`
}

func (m *RemoveLogStreamReplicaRequest) Reset()         { *m = RemoveLogStreamReplicaRequest{} }
func (m *RemoveLogStreamReplicaRequest) String() string { return proto.CompactTextString(m) }
func (*RemoveLogStreamReplicaRequest) ProtoMessage()    {}
func (*RemoveLogStreamReplicaRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{8}
}
func (m *RemoveLogStreamReplicaRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveLogStreamReplicaRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveLogStreamReplicaRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveLogStreamReplicaRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveLogStreamReplicaRequest.Merge(m, src)
}
func (m *RemoveLogStreamReplicaRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveLogStreamReplicaRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveLogStreamReplicaRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveLogStreamReplicaRequest proto.InternalMessageInfo

func (m *RemoveLogStreamReplicaRequest) GetStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.StorageNodeID
	}
	return 0
}

func (m *RemoveLogStreamReplicaRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type RemoveLogStreamReplicaResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveLogStreamReplicaResponse) Reset()         { *m = RemoveLogStreamReplicaResponse{} }
func (m *RemoveLogStreamReplicaResponse) String() string { return proto.CompactTextString(m) }
func (*RemoveLogStreamReplicaResponse) ProtoMessage()    {}
func (*RemoveLogStreamReplicaResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{9}
}
func (m *RemoveLogStreamReplicaResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveLogStreamReplicaResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveLogStreamReplicaResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveLogStreamReplicaResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveLogStreamReplicaResponse.Merge(m, src)
}
func (m *RemoveLogStreamReplicaResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *RemoveLogStreamReplicaResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveLogStreamReplicaResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveLogStreamReplicaResponse proto.InternalMessageInfo

type UpdateLogStreamRequest struct {
	LogStreamID github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,1,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	//
	//// NOTE: popped_replica need not be varlog.ReplicaDescriptor, but it is
	//// natural. Though it is awkward, popped_storage_node_id is used here.
	//uint32 popped_storage_node_id = 2 [
	//(gogoproto.casttype) =
	//"github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID",
	//(gogoproto.customname) = "PoppedStorageNodeID"
	//];
	PoppedReplica        *varlogpb.ReplicaDescriptor `protobuf:"bytes,2,opt,name=popped_replica,json=poppedReplica,proto3" json:"popped_replica,omitempty"`
	PushedReplica        *varlogpb.ReplicaDescriptor `protobuf:"bytes,3,opt,name=pushed_replica,json=pushedReplica,proto3" json:"pushed_replica,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *UpdateLogStreamRequest) Reset()         { *m = UpdateLogStreamRequest{} }
func (m *UpdateLogStreamRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateLogStreamRequest) ProtoMessage()    {}
func (*UpdateLogStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{10}
}
func (m *UpdateLogStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLogStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLogStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLogStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLogStreamRequest.Merge(m, src)
}
func (m *UpdateLogStreamRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateLogStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLogStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLogStreamRequest proto.InternalMessageInfo

func (m *UpdateLogStreamRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *UpdateLogStreamRequest) GetPoppedReplica() *varlogpb.ReplicaDescriptor {
	if m != nil {
		return m.PoppedReplica
	}
	return nil
}

func (m *UpdateLogStreamRequest) GetPushedReplica() *varlogpb.ReplicaDescriptor {
	if m != nil {
		return m.PushedReplica
	}
	return nil
}

type UpdateLogStreamResponse struct {
	LogStream            *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"log_stream,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *UpdateLogStreamResponse) Reset()         { *m = UpdateLogStreamResponse{} }
func (m *UpdateLogStreamResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateLogStreamResponse) ProtoMessage()    {}
func (*UpdateLogStreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{11}
}
func (m *UpdateLogStreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLogStreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLogStreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLogStreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLogStreamResponse.Merge(m, src)
}
func (m *UpdateLogStreamResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UpdateLogStreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLogStreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLogStreamResponse proto.InternalMessageInfo

func (m *UpdateLogStreamResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type SealRequest struct {
	LogStreamID          github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,1,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                 `json:"-"`
	XXX_unrecognized     []byte                                                   `json:"-"`
	XXX_sizecache        int32                                                    `json:"-"`
}

func (m *SealRequest) Reset()         { *m = SealRequest{} }
func (m *SealRequest) String() string { return proto.CompactTextString(m) }
func (*SealRequest) ProtoMessage()    {}
func (*SealRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{12}
}
func (m *SealRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealRequest.Merge(m, src)
}
func (m *SealRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SealRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SealRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SealRequest proto.InternalMessageInfo

func (m *SealRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type SealResponse struct {
	LogStreams           []varlogpb.LogStreamMetadataDescriptor            `protobuf:"bytes,1,rep,name=log_streams,json=logStreams,proto3" json:"log_streams"`
	SealedGLSN           github_daumkakao_com_varlog_varlog_pkg_types.GLSN `protobuf:"varint,2,opt,name=sealed_glsn,json=sealedGlsn,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.GLSN" json:"sealed_glsn,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                          `json:"-"`
	XXX_unrecognized     []byte                                            `json:"-"`
	XXX_sizecache        int32                                             `json:"-"`
}

func (m *SealResponse) Reset()         { *m = SealResponse{} }
func (m *SealResponse) String() string { return proto.CompactTextString(m) }
func (*SealResponse) ProtoMessage()    {}
func (*SealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{13}
}
func (m *SealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SealResponse.Merge(m, src)
}
func (m *SealResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SealResponse proto.InternalMessageInfo

func (m *SealResponse) GetLogStreams() []varlogpb.LogStreamMetadataDescriptor {
	if m != nil {
		return m.LogStreams
	}
	return nil
}

func (m *SealResponse) GetSealedGLSN() github_daumkakao_com_varlog_varlog_pkg_types.GLSN {
	if m != nil {
		return m.SealedGLSN
	}
	return 0
}

type SyncRequest struct {
	LogStreamID          github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID   `protobuf:"varint,1,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	SrcStorageNodeID     github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,2,opt,name=src_storage_node_id,json=srcStorageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"src_storage_node_id,omitempty"`
	DstStorageNodeID     github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID `protobuf:"varint,3,opt,name=dst_storage_node_id,json=dstStorageNodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"dst_storage_node_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                   `json:"-"`
	XXX_unrecognized     []byte                                                     `json:"-"`
	XXX_sizecache        int32                                                      `json:"-"`
}

func (m *SyncRequest) Reset()         { *m = SyncRequest{} }
func (m *SyncRequest) String() string { return proto.CompactTextString(m) }
func (*SyncRequest) ProtoMessage()    {}
func (*SyncRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{14}
}
func (m *SyncRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncRequest.Merge(m, src)
}
func (m *SyncRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SyncRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SyncRequest proto.InternalMessageInfo

func (m *SyncRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

func (m *SyncRequest) GetSrcStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.SrcStorageNodeID
	}
	return 0
}

func (m *SyncRequest) GetDstStorageNodeID() github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID {
	if m != nil {
		return m.DstStorageNodeID
	}
	return 0
}

type SyncResponse struct {
	Status               *snpb.SyncStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SyncResponse) Reset()         { *m = SyncResponse{} }
func (m *SyncResponse) String() string { return proto.CompactTextString(m) }
func (*SyncResponse) ProtoMessage()    {}
func (*SyncResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{15}
}
func (m *SyncResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncResponse.Merge(m, src)
}
func (m *SyncResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *SyncResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SyncResponse proto.InternalMessageInfo

func (m *SyncResponse) GetStatus() *snpb.SyncStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type UnsealRequest struct {
	LogStreamID          github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID `protobuf:"varint,1,opt,name=log_stream_id,json=logStreamId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.LogStreamID" json:"log_stream_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                                 `json:"-"`
	XXX_unrecognized     []byte                                                   `json:"-"`
	XXX_sizecache        int32                                                    `json:"-"`
}

func (m *UnsealRequest) Reset()         { *m = UnsealRequest{} }
func (m *UnsealRequest) String() string { return proto.CompactTextString(m) }
func (*UnsealRequest) ProtoMessage()    {}
func (*UnsealRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{16}
}
func (m *UnsealRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsealRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsealRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsealRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsealRequest.Merge(m, src)
}
func (m *UnsealRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnsealRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsealRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UnsealRequest proto.InternalMessageInfo

func (m *UnsealRequest) GetLogStreamID() github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID {
	if m != nil {
		return m.LogStreamID
	}
	return 0
}

type UnsealResponse struct {
	LogStream            *varlogpb.LogStreamDescriptor `protobuf:"bytes,1,opt,name=log_stream,json=logStream,proto3" json:"log_stream,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *UnsealResponse) Reset()         { *m = UnsealResponse{} }
func (m *UnsealResponse) String() string { return proto.CompactTextString(m) }
func (*UnsealResponse) ProtoMessage()    {}
func (*UnsealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{17}
}
func (m *UnsealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnsealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnsealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnsealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnsealResponse.Merge(m, src)
}
func (m *UnsealResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *UnsealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UnsealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UnsealResponse proto.InternalMessageInfo

func (m *UnsealResponse) GetLogStream() *varlogpb.LogStreamDescriptor {
	if m != nil {
		return m.LogStream
	}
	return nil
}

type GetMRMembersResponse struct {
	Leader               github_daumkakao_com_varlog_varlog_pkg_types.NodeID            `protobuf:"varint,1,opt,name=leader,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"leader,omitempty"`
	ReplicationFactor    int32                                                          `protobuf:"varint,2,opt,name=replication_factor,json=replicationFactor,proto3" json:"replication_factor,omitempty"`
	Members              map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]string `protobuf:"bytes,3,rep,name=members,proto3,castkey=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"members,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                       `json:"-"`
	XXX_unrecognized     []byte                                                         `json:"-"`
	XXX_sizecache        int32                                                          `json:"-"`
}

func (m *GetMRMembersResponse) Reset()         { *m = GetMRMembersResponse{} }
func (m *GetMRMembersResponse) String() string { return proto.CompactTextString(m) }
func (*GetMRMembersResponse) ProtoMessage()    {}
func (*GetMRMembersResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{18}
}
func (m *GetMRMembersResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetMRMembersResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetMRMembersResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetMRMembersResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetMRMembersResponse.Merge(m, src)
}
func (m *GetMRMembersResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetMRMembersResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetMRMembersResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetMRMembersResponse proto.InternalMessageInfo

func (m *GetMRMembersResponse) GetLeader() github_daumkakao_com_varlog_varlog_pkg_types.NodeID {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *GetMRMembersResponse) GetReplicationFactor() int32 {
	if m != nil {
		return m.ReplicationFactor
	}
	return 0
}

func (m *GetMRMembersResponse) GetMembers() map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]string {
	if m != nil {
		return m.Members
	}
	return nil
}

type GetStorageNodesResponse struct {
	Storagenodes         map[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID]string `protobuf:"bytes,1,rep,name=storagenodes,proto3,castkey=github.daumkakao.com/varlog/varlog/pkg/types.StorageNodeID" json:"storagenodes,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                                                              `json:"-"`
	XXX_unrecognized     []byte                                                                `json:"-"`
	XXX_sizecache        int32                                                                 `json:"-"`
}

func (m *GetStorageNodesResponse) Reset()         { *m = GetStorageNodesResponse{} }
func (m *GetStorageNodesResponse) String() string { return proto.CompactTextString(m) }
func (*GetStorageNodesResponse) ProtoMessage()    {}
func (*GetStorageNodesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{19}
}
func (m *GetStorageNodesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStorageNodesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStorageNodesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStorageNodesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStorageNodesResponse.Merge(m, src)
}
func (m *GetStorageNodesResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *GetStorageNodesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStorageNodesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetStorageNodesResponse proto.InternalMessageInfo

func (m *GetStorageNodesResponse) GetStoragenodes() map[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID]string {
	if m != nil {
		return m.Storagenodes
	}
	return nil
}

type AddMRPeerRequest struct {
	RaftURL              string   `protobuf:"bytes,1,opt,name=raft_url,json=raftUrl,proto3" json:"raft_url,omitempty"`
	RPCAddr              string   `protobuf:"bytes,2,opt,name=rpc_addr,json=rpcAddr,proto3" json:"rpc_addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddMRPeerRequest) Reset()         { *m = AddMRPeerRequest{} }
func (m *AddMRPeerRequest) String() string { return proto.CompactTextString(m) }
func (*AddMRPeerRequest) ProtoMessage()    {}
func (*AddMRPeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{20}
}
func (m *AddMRPeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMRPeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMRPeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMRPeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMRPeerRequest.Merge(m, src)
}
func (m *AddMRPeerRequest) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddMRPeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMRPeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddMRPeerRequest proto.InternalMessageInfo

func (m *AddMRPeerRequest) GetRaftURL() string {
	if m != nil {
		return m.RaftURL
	}
	return ""
}

func (m *AddMRPeerRequest) GetRPCAddr() string {
	if m != nil {
		return m.RPCAddr
	}
	return ""
}

type AddMRPeerResponse struct {
	NodeID               github_daumkakao_com_varlog_varlog_pkg_types.NodeID `protobuf:"varint,1,opt,name=node_id,json=nodeId,proto3,casttype=github.daumkakao.com/varlog/varlog/pkg/types.NodeID" json:"node_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                            `json:"-"`
	XXX_unrecognized     []byte                                              `json:"-"`
	XXX_sizecache        int32                                               `json:"-"`
}

func (m *AddMRPeerResponse) Reset()         { *m = AddMRPeerResponse{} }
func (m *AddMRPeerResponse) String() string { return proto.CompactTextString(m) }
func (*AddMRPeerResponse) ProtoMessage()    {}
func (*AddMRPeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_682aff4a3f93d15c, []int{21}
}
func (m *AddMRPeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMRPeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMRPeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMRPeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMRPeerResponse.Merge(m, src)
}
func (m *AddMRPeerResponse) XXX_Size() int {
	return m.ProtoSize()
}
func (m *AddMRPeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMRPeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AddMRPeerResponse proto.InternalMessageInfo

func (m *AddMRPeerResponse) GetNodeID() github_daumkakao_com_varlog_varlog_pkg_types.NodeID {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func init() {
	proto.RegisterType((*AddStorageNodeRequest)(nil), "varlog.vmspb.AddStorageNodeRequest")
	proto.RegisterType((*AddStorageNodeResponse)(nil), "varlog.vmspb.AddStorageNodeResponse")
	proto.RegisterType((*UnregisterStorageNodeRequest)(nil), "varlog.vmspb.UnregisterStorageNodeRequest")
	proto.RegisterType((*UnregisterStorageNodeResponse)(nil), "varlog.vmspb.UnregisterStorageNodeResponse")
	proto.RegisterType((*AddLogStreamRequest)(nil), "varlog.vmspb.AddLogStreamRequest")
	proto.RegisterType((*AddLogStreamResponse)(nil), "varlog.vmspb.AddLogStreamResponse")
	proto.RegisterType((*UnregisterLogStreamRequest)(nil), "varlog.vmspb.UnregisterLogStreamRequest")
	proto.RegisterType((*UnregisterLogStreamResponse)(nil), "varlog.vmspb.UnregisterLogStreamResponse")
	proto.RegisterType((*RemoveLogStreamReplicaRequest)(nil), "varlog.vmspb.RemoveLogStreamReplicaRequest")
	proto.RegisterType((*RemoveLogStreamReplicaResponse)(nil), "varlog.vmspb.RemoveLogStreamReplicaResponse")
	proto.RegisterType((*UpdateLogStreamRequest)(nil), "varlog.vmspb.UpdateLogStreamRequest")
	proto.RegisterType((*UpdateLogStreamResponse)(nil), "varlog.vmspb.UpdateLogStreamResponse")
	proto.RegisterType((*SealRequest)(nil), "varlog.vmspb.SealRequest")
	proto.RegisterType((*SealResponse)(nil), "varlog.vmspb.SealResponse")
	proto.RegisterType((*SyncRequest)(nil), "varlog.vmspb.SyncRequest")
	proto.RegisterType((*SyncResponse)(nil), "varlog.vmspb.SyncResponse")
	proto.RegisterType((*UnsealRequest)(nil), "varlog.vmspb.UnsealRequest")
	proto.RegisterType((*UnsealResponse)(nil), "varlog.vmspb.UnsealResponse")
	proto.RegisterType((*GetMRMembersResponse)(nil), "varlog.vmspb.GetMRMembersResponse")
	proto.RegisterMapType((map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]string)(nil), "varlog.vmspb.GetMRMembersResponse.MembersEntry")
	proto.RegisterType((*GetStorageNodesResponse)(nil), "varlog.vmspb.GetStorageNodesResponse")
	proto.RegisterMapType((map[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID]string)(nil), "varlog.vmspb.GetStorageNodesResponse.StoragenodesEntry")
	proto.RegisterType((*AddMRPeerRequest)(nil), "varlog.vmspb.AddMRPeerRequest")
	proto.RegisterType((*AddMRPeerResponse)(nil), "varlog.vmspb.AddMRPeerResponse")
}

func init() { proto.RegisterFile("proto/vmspb/vms.proto", fileDescriptor_682aff4a3f93d15c) }

var fileDescriptor_682aff4a3f93d15c = []byte{
	// 1244 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x58, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x36, 0x2d, 0xc7, 0x8a, 0x47, 0x92, 0xe3, 0x6c, 0xe2, 0x8f, 0x97, 0x8e, 0xcd, 0xbc, 0x6c,
	0x52, 0xb8, 0x6d, 0x42, 0x21, 0xce, 0xc1, 0x81, 0x51, 0xd4, 0xb0, 0x6c, 0xd7, 0x30, 0x6a, 0x3b,
	0x29, 0x05, 0xa1, 0x40, 0x82, 0x56, 0xa5, 0xb4, 0x6b, 0x46, 0x30, 0x45, 0xb2, 0xbb, 0x94, 0x0b,
	0x5d, 0x8a, 0xd6, 0x87, 0x02, 0x3d, 0xf4, 0xdc, 0x43, 0x0f, 0xed, 0x2f, 0xe9, 0x39, 0xbd, 0xf5,
	0xd6, 0x9b, 0x02, 0xa8, 0x7f, 0xa2, 0xf0, 0xa9, 0xe0, 0x72, 0x49, 0x51, 0x22, 0xe5, 0xc8, 0xa9,
	0x0b, 0x5f, 0x6c, 0xed, 0xce, 0xd7, 0x33, 0xcf, 0xee, 0x0c, 0x87, 0x84, 0x59, 0x97, 0x3a, 0x9e,
	0x53, 0x3c, 0x69, 0x32, 0xb7, 0xe6, 0xff, 0xd5, 0xf8, 0x1a, 0xe5, 0x4f, 0x0c, 0x6a, 0x39, 0xa6,
	0xc6, 0xf7, 0xe5, 0x87, 0x66, 0xc3, 0x7b, 0xd9, 0xaa, 0x69, 0x75, 0xa7, 0x59, 0x34, 0x1d, 0xd3,
	0x29, 0x72, 0xa5, 0x5a, 0xeb, 0x88, 0xaf, 0x02, 0x0f, 0xfe, 0xaf, 0xc0, 0x58, 0x5e, 0x34, 0x1d,
	0xc7, 0xb4, 0x48, 0x4f, 0x8b, 0x34, 0x5d, 0xaf, 0x2d, 0x84, 0xf3, 0x81, 0x67, 0xb7, 0x56, 0x6c,
	0x12, 0xcf, 0xc0, 0x86, 0x67, 0x08, 0xc1, 0x2c, 0xb3, 0xdd, 0x5a, 0x91, 0x12, 0xd7, 0x6a, 0xd4,
	0x0d, 0xcf, 0xa1, 0xc1, 0xb6, 0xfa, 0x08, 0x66, 0x37, 0x31, 0x2e, 0x7b, 0x0e, 0x35, 0x4c, 0x72,
	0xe8, 0x60, 0xa2, 0x93, 0xaf, 0x5a, 0x84, 0x79, 0x68, 0x01, 0xb2, 0x06, 0xc6, 0x94, 0x30, 0xb6,
	0x20, 0xdd, 0x95, 0x56, 0xa6, 0xf4, 0x70, 0xa9, 0x1e, 0xc3, 0xdc, 0xa0, 0x09, 0x73, 0x1d, 0x9b,
	0x11, 0xf4, 0x29, 0xe4, 0x59, 0xb0, 0x5d, 0xb5, 0x1d, 0x4c, 0xb8, 0x61, 0x6e, 0x55, 0xd3, 0xc2,
	0x6c, 0x05, 0x34, 0x2d, 0x66, 0x7b, 0x20, 0x50, 0x6e, 0x13, 0x56, 0xa7, 0x0d, 0xd7, 0x73, 0xa8,
	0x9e, 0x63, 0x3d, 0xb1, 0xfa, 0x93, 0x04, 0x77, 0x2a, 0x36, 0x25, 0x66, 0x83, 0x79, 0x84, 0xa6,
	0xe0, 0xfc, 0x1a, 0x6e, 0xc4, 0x63, 0x56, 0x1b, 0x98, 0x87, 0x2d, 0x94, 0x9e, 0x76, 0x3b, 0x4a,
	0x21, 0x66, 0xb0, 0xb7, 0x7d, 0xd6, 0x51, 0xd6, 0x05, 0xd5, 0xd8, 0x68, 0x35, 0x8f, 0x8d, 0x63,
	0xc3, 0xe1, 0xa4, 0x07, 0xc0, 0xc2, 0x7f, 0xee, 0xb1, 0x59, 0xf4, 0xda, 0x2e, 0x61, 0x5a, 0x9f,
	0xb5, 0x5e, 0x88, 0xe1, 0xda, 0xc3, 0xaa, 0x02, 0x4b, 0x43, 0x80, 0x05, 0x6c, 0xa8, 0x2f, 0xe0,
	0xd6, 0x26, 0xc6, 0xfb, 0x8e, 0x59, 0xf6, 0x28, 0x31, 0x9a, 0x21, 0xe0, 0x6d, 0xb8, 0x2e, 0x4e,
	0xc1, 0x67, 0x36, 0xb3, 0x92, 0x5b, 0x55, 0x13, 0x04, 0xe9, 0x81, 0x42, 0x8f, 0x94, 0xd2, 0xc4,
	0xab, 0x8e, 0x22, 0xe9, 0x91, 0xa5, 0xfa, 0x02, 0x6e, 0xf7, 0x3b, 0x17, 0x47, 0xb0, 0x05, 0x60,
	0x39, 0x66, 0x95, 0xf1, 0x5d, 0x71, 0x00, 0xf7, 0x12, 0xfe, 0x23, 0xbb, 0x18, 0xed, 0x53, 0x56,
	0xb8, 0xa9, 0xfe, 0x28, 0x81, 0xdc, 0xcb, 0x2d, 0x91, 0x81, 0x03, 0x85, 0x5e, 0x8c, 0x1e, 0xe1,
	0x9f, 0x74, 0x3b, 0x4a, 0x2e, 0x52, 0xe6, 0x74, 0x3f, 0xb9, 0x10, 0xdd, 0x31, 0x5b, 0x3d, 0x17,
	0xa1, 0xd9, 0xc3, 0xea, 0x12, 0x2c, 0xa6, 0xc2, 0x11, 0x44, 0xff, 0x30, 0x0e, 0x4b, 0x3a, 0x69,
	0x3a, 0x27, 0x24, 0x26, 0xe3, 0x3c, 0x5d, 0xf5, 0x25, 0x49, 0x52, 0x35, 0xfe, 0x1f, 0x53, 0x75,
	0x17, 0x96, 0x87, 0x51, 0x21, 0xd8, 0xfa, 0x65, 0x1c, 0xe6, 0x2a, 0x2e, 0x36, 0x3c, 0x72, 0xe5,
	0x07, 0x8b, 0xf6, 0x60, 0xda, 0x75, 0x5c, 0x97, 0xe0, 0xaa, 0xb8, 0xd8, 0x9c, 0x9f, 0x91, 0x2a,
	0x42, 0x2f, 0x04, 0x96, 0x42, 0xc0, 0x5d, 0xb5, 0xd8, 0xcb, 0x98, 0xab, 0xcc, 0x05, 0x5c, 0x71,
	0x4b, 0x21, 0x50, 0xbf, 0x80, 0xf9, 0x04, 0x41, 0x97, 0x59, 0x5e, 0xdf, 0x40, 0xae, 0x4c, 0x0c,
	0xeb, 0xca, 0xca, 0xe9, 0x77, 0x09, 0xf2, 0x01, 0x00, 0x91, 0x55, 0x19, 0x72, 0x3d, 0x04, 0x61,
	0x57, 0x7a, 0x30, 0x3c, 0xad, 0x64, 0xd3, 0xe6, 0xfd, 0x69, 0x4c, 0x87, 0x28, 0x0c, 0x43, 0x18,
	0x72, 0x8c, 0x18, 0x16, 0xc1, 0x55, 0xd3, 0x62, 0x36, 0x3f, 0xd8, 0x89, 0xd2, 0x56, 0xb7, 0xa3,
	0x40, 0x99, 0x6f, 0xef, 0xee, 0x97, 0x0f, 0xcf, 0x3a, 0xca, 0xa3, 0x0b, 0xe5, 0xe4, 0x1b, 0xe9,
	0x10, 0xf8, 0xdd, 0xb5, 0x98, 0xad, 0x7e, 0x9f, 0x81, 0x5c, 0xb9, 0x6d, 0xd7, 0xaf, 0xec, 0x0a,
	0x7f, 0x27, 0xc1, 0x2d, 0x46, 0xeb, 0xd5, 0xc1, 0xfe, 0x12, 0x14, 0xba, 0xde, 0xed, 0x28, 0x33,
	0x65, 0x5a, 0xbf, 0xcc, 0x16, 0x33, 0xc3, 0xfa, 0xfd, 0x05, 0x18, 0x30, 0xf3, 0x12, 0x18, 0x32,
	0x3d, 0x0c, 0xdb, 0xcc, 0xbb, 0x54, 0x0c, 0xb8, 0xdf, 0x1f, 0x56, 0x37, 0x20, 0x1f, 0x9c, 0x83,
	0xb8, 0x53, 0x45, 0x98, 0x64, 0x9e, 0xe1, 0xb5, 0x98, 0xa8, 0x92, 0xf9, 0xf0, 0x3a, 0xf9, 0x73,
	0x88, 0xe6, 0xab, 0x96, 0xb9, 0x58, 0x17, 0x6a, 0xea, 0xb7, 0x12, 0x14, 0x2a, 0x36, 0xbb, 0xca,
	0xc2, 0xa8, 0xc0, 0x74, 0x88, 0xe0, 0x32, 0xeb, 0xfd, 0xcf, 0x71, 0xb8, 0xbd, 0x4b, 0xbc, 0x03,
	0xfd, 0x80, 0x34, 0x6b, 0x84, 0xb2, 0xc8, 0xfb, 0x53, 0x98, 0xb4, 0x88, 0x81, 0x09, 0xe5, 0x9e,
	0x27, 0x4a, 0x6b, 0x67, 0x1d, 0xe5, 0xf1, 0x85, 0x52, 0x11, 0xc7, 0x21, 0xdc, 0xa0, 0x87, 0x80,
	0xc2, 0x09, 0xaf, 0xe1, 0xd8, 0xd5, 0x23, 0xa3, 0xee, 0x39, 0x94, 0x5f, 0xc5, 0x6b, 0xfa, 0xcd,
	0x98, 0xe4, 0x63, 0x2e, 0x40, 0xa7, 0x12, 0x64, 0x9b, 0x01, 0xa6, 0x85, 0x0c, 0x2f, 0xfa, 0xa2,
	0x16, 0x9f, 0x4c, 0xb5, 0x34, 0xd4, 0x9a, 0x58, 0xef, 0xd8, 0x1e, 0x6d, 0x97, 0xd6, 0x4e, 0x5f,
	0xbf, 0x1d, 0xe4, 0x30, 0xb0, 0xbc, 0x0e, 0xf9, 0xb8, 0x47, 0x34, 0x03, 0x99, 0x63, 0xd2, 0x0e,
	0x18, 0xd1, 0xfd, 0x9f, 0xe8, 0x36, 0x5c, 0x3b, 0x31, 0xac, 0x16, 0xe1, 0x89, 0x4c, 0xe9, 0xc1,
	0x62, 0x7d, 0xfc, 0x89, 0xa4, 0xfe, 0x2d, 0xc1, 0xfc, 0x2e, 0x89, 0xdf, 0xc4, 0x1e, 0xb9, 0x3f,
	0x4b, 0xd1, 0x34, 0xea, 0xd7, 0x43, 0xd8, 0xd6, 0xd6, 0x12, 0x19, 0xa6, 0x59, 0x87, 0xd7, 0x9d,
	0x5b, 0x06, 0x99, 0x7e, 0x74, 0xfa, 0xfa, 0x5f, 0x95, 0x4c, 0x1f, 0x18, 0x79, 0x03, 0x6e, 0x26,
	0x42, 0xc4, 0x53, 0x2f, 0xbc, 0x29, 0xf5, 0x1a, 0xcc, 0x6c, 0x62, 0x7c, 0xa0, 0x3f, 0x23, 0x84,
	0x86, 0x05, 0xf3, 0x2e, 0x5c, 0xa7, 0xc6, 0x91, 0x57, 0x6d, 0x51, 0x2b, 0x18, 0xda, 0x4b, 0xb9,
	0x6e, 0x47, 0xc9, 0xea, 0xc6, 0x91, 0x57, 0xd1, 0xf7, 0xf5, 0xac, 0x2f, 0xac, 0x50, 0x8b, 0xeb,
	0xb9, 0xf5, 0xaa, 0x3f, 0xd0, 0x07, 0x8e, 0x85, 0xde, 0xb3, 0xad, 0x4d, 0x8c, 0xa9, 0x9e, 0xa5,
	0x6e, 0xdd, 0xff, 0xa1, 0x3a, 0x70, 0x33, 0x16, 0x43, 0xf0, 0xfa, 0x1c, 0xb2, 0xf1, 0x19, 0x6a,
	0xa2, 0xb4, 0xd9, 0xed, 0x28, 0x93, 0x51, 0x57, 0x79, 0xbb, 0xfb, 0x6b, 0xf3, 0x26, 0xb2, 0xfa,
	0xdb, 0x75, 0x98, 0xde, 0xb2, 0x5a, 0xfe, 0x98, 0x77, 0x60, 0xd8, 0x86, 0x49, 0x28, 0xfa, 0x1c,
	0xa6, 0xfb, 0xdf, 0x36, 0xd0, 0x3b, 0xfd, 0x27, 0x98, 0xfa, 0xfa, 0x22, 0xdf, 0x3b, 0x5f, 0x49,
	0xcc, 0x42, 0x63, 0x88, 0xc2, 0x6c, 0xea, 0x14, 0x8f, 0xde, 0xef, 0x77, 0x70, 0xde, 0x3b, 0x88,
	0xfc, 0xc1, 0x48, 0xba, 0x51, 0xcc, 0xcf, 0x20, 0x1f, 0x9f, 0xdd, 0xd1, 0xff, 0x13, 0x58, 0x07,
	0x27, 0x33, 0x59, 0x3d, 0x4f, 0x25, 0x72, 0x6c, 0xc1, 0xad, 0x94, 0x39, 0x19, 0xad, 0x0c, 0x83,
	0x97, 0x08, 0xf3, 0xde, 0x08, 0x9a, 0x51, 0xb4, 0x16, 0xcc, 0xa5, 0x8f, 0x9a, 0x68, 0x80, 0x8f,
	0x73, 0x67, 0x73, 0xf9, 0xc1, 0x68, 0xca, 0x51, 0xd8, 0x2f, 0xe1, 0xc6, 0xc0, 0x74, 0x86, 0x06,
	0x0e, 0x3b, 0x7d, 0xba, 0x95, 0xef, 0xbf, 0x41, 0x2b, 0x8a, 0xb0, 0x01, 0x13, 0xfe, 0x88, 0x82,
	0xfe, 0xd7, 0x6f, 0x10, 0x9b, 0xd9, 0x64, 0x39, 0x4d, 0xd4, 0xe7, 0xa0, 0x6d, 0xd7, 0x13, 0x0e,
	0x7a, 0x73, 0x4a, 0xc2, 0x41, 0xec, 0xd1, 0xa9, 0x8e, 0xa1, 0x1d, 0x98, 0x0c, 0x1e, 0x44, 0x68,
	0x71, 0xf0, 0x44, 0x62, 0x0f, 0x48, 0xf9, 0x4e, 0xba, 0x30, 0x72, 0xb3, 0x0f, 0xf9, 0x78, 0x07,
	0x47, 0x73, 0x5a, 0xf0, 0xe9, 0x40, 0x0b, 0x3f, 0x1d, 0x68, 0x3b, 0x4d, 0xd7, 0x6b, 0x0f, 0xde,
	0xae, 0xb4, 0xae, 0xaf, 0x8e, 0xa1, 0x43, 0x98, 0x8a, 0xba, 0x01, 0x5a, 0x4e, 0x5c, 0xc8, 0xbe,
	0x56, 0x24, 0x2b, 0x43, 0xe5, 0x91, 0x3f, 0x1d, 0x6e, 0x0c, 0x74, 0xdf, 0xa1, 0x00, 0xef, 0x8f,
	0xd4, 0xb4, 0xd5, 0xb1, 0xd2, 0x87, 0xaf, 0xba, 0xcb, 0xd2, 0x1f, 0xdd, 0x65, 0xe9, 0xd7, 0xbf,
	0x96, 0xa5, 0xe7, 0xda, 0x28, 0xbd, 0xa8, 0xf7, 0x81, 0xa6, 0x36, 0xc9, 0x17, 0x8f, 0xff, 0x09,
	0x00, 0x00, 0xff, 0xff, 0xa9, 0x62, 0x6b, 0x5e, 0xb6, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ClusterManagerClient is the client API for ClusterManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ClusterManagerClient interface {
	AddStorageNode(ctx context.Context, in *AddStorageNodeRequest, opts ...grpc.CallOption) (*AddStorageNodeResponse, error)
	UnregisterStorageNode(ctx context.Context, in *UnregisterStorageNodeRequest, opts ...grpc.CallOption) (*UnregisterStorageNodeResponse, error)
	AddLogStream(ctx context.Context, in *AddLogStreamRequest, opts ...grpc.CallOption) (*AddLogStreamResponse, error)
	UnregisterLogStream(ctx context.Context, in *UnregisterLogStreamRequest, opts ...grpc.CallOption) (*UnregisterLogStreamResponse, error)
	RemoveLogStreamReplica(ctx context.Context, in *RemoveLogStreamReplicaRequest, opts ...grpc.CallOption) (*RemoveLogStreamReplicaResponse, error)
	UpdateLogStream(ctx context.Context, in *UpdateLogStreamRequest, opts ...grpc.CallOption) (*UpdateLogStreamResponse, error)
	Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error)
	Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error)
	Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error)
	GetMRMembers(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetMRMembersResponse, error)
	AddMRPeer(ctx context.Context, in *AddMRPeerRequest, opts ...grpc.CallOption) (*AddMRPeerResponse, error)
	GetStorageNodes(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetStorageNodesResponse, error)
}

type clusterManagerClient struct {
	cc *grpc.ClientConn
}

func NewClusterManagerClient(cc *grpc.ClientConn) ClusterManagerClient {
	return &clusterManagerClient{cc}
}

func (c *clusterManagerClient) AddStorageNode(ctx context.Context, in *AddStorageNodeRequest, opts ...grpc.CallOption) (*AddStorageNodeResponse, error) {
	out := new(AddStorageNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/AddStorageNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UnregisterStorageNode(ctx context.Context, in *UnregisterStorageNodeRequest, opts ...grpc.CallOption) (*UnregisterStorageNodeResponse, error) {
	out := new(UnregisterStorageNodeResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/UnregisterStorageNode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddLogStream(ctx context.Context, in *AddLogStreamRequest, opts ...grpc.CallOption) (*AddLogStreamResponse, error) {
	out := new(AddLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/AddLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UnregisterLogStream(ctx context.Context, in *UnregisterLogStreamRequest, opts ...grpc.CallOption) (*UnregisterLogStreamResponse, error) {
	out := new(UnregisterLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/UnregisterLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) RemoveLogStreamReplica(ctx context.Context, in *RemoveLogStreamReplicaRequest, opts ...grpc.CallOption) (*RemoveLogStreamReplicaResponse, error) {
	out := new(RemoveLogStreamReplicaResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/RemoveLogStreamReplica", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) UpdateLogStream(ctx context.Context, in *UpdateLogStreamRequest, opts ...grpc.CallOption) (*UpdateLogStreamResponse, error) {
	out := new(UpdateLogStreamResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/UpdateLogStream", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Seal(ctx context.Context, in *SealRequest, opts ...grpc.CallOption) (*SealResponse, error) {
	out := new(SealResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/Seal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Sync(ctx context.Context, in *SyncRequest, opts ...grpc.CallOption) (*SyncResponse, error) {
	out := new(SyncResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/Sync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) Unseal(ctx context.Context, in *UnsealRequest, opts ...grpc.CallOption) (*UnsealResponse, error) {
	out := new(UnsealResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/Unseal", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) GetMRMembers(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetMRMembersResponse, error) {
	out := new(GetMRMembersResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/GetMRMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) AddMRPeer(ctx context.Context, in *AddMRPeerRequest, opts ...grpc.CallOption) (*AddMRPeerResponse, error) {
	out := new(AddMRPeerResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/AddMRPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *clusterManagerClient) GetStorageNodes(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*GetStorageNodesResponse, error) {
	out := new(GetStorageNodesResponse)
	err := c.cc.Invoke(ctx, "/varlog.vmspb.ClusterManager/GetStorageNodes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ClusterManagerServer is the server API for ClusterManager service.
type ClusterManagerServer interface {
	AddStorageNode(context.Context, *AddStorageNodeRequest) (*AddStorageNodeResponse, error)
	UnregisterStorageNode(context.Context, *UnregisterStorageNodeRequest) (*UnregisterStorageNodeResponse, error)
	AddLogStream(context.Context, *AddLogStreamRequest) (*AddLogStreamResponse, error)
	UnregisterLogStream(context.Context, *UnregisterLogStreamRequest) (*UnregisterLogStreamResponse, error)
	RemoveLogStreamReplica(context.Context, *RemoveLogStreamReplicaRequest) (*RemoveLogStreamReplicaResponse, error)
	UpdateLogStream(context.Context, *UpdateLogStreamRequest) (*UpdateLogStreamResponse, error)
	Seal(context.Context, *SealRequest) (*SealResponse, error)
	Sync(context.Context, *SyncRequest) (*SyncResponse, error)
	Unseal(context.Context, *UnsealRequest) (*UnsealResponse, error)
	GetMRMembers(context.Context, *types.Empty) (*GetMRMembersResponse, error)
	AddMRPeer(context.Context, *AddMRPeerRequest) (*AddMRPeerResponse, error)
	GetStorageNodes(context.Context, *types.Empty) (*GetStorageNodesResponse, error)
}

// UnimplementedClusterManagerServer can be embedded to have forward compatible implementations.
type UnimplementedClusterManagerServer struct {
}

func (*UnimplementedClusterManagerServer) AddStorageNode(ctx context.Context, req *AddStorageNodeRequest) (*AddStorageNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddStorageNode not implemented")
}
func (*UnimplementedClusterManagerServer) UnregisterStorageNode(ctx context.Context, req *UnregisterStorageNodeRequest) (*UnregisterStorageNodeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterStorageNode not implemented")
}
func (*UnimplementedClusterManagerServer) AddLogStream(ctx context.Context, req *AddLogStreamRequest) (*AddLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) UnregisterLogStream(ctx context.Context, req *UnregisterLogStreamRequest) (*UnregisterLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnregisterLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) RemoveLogStreamReplica(ctx context.Context, req *RemoveLogStreamReplicaRequest) (*RemoveLogStreamReplicaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveLogStreamReplica not implemented")
}
func (*UnimplementedClusterManagerServer) UpdateLogStream(ctx context.Context, req *UpdateLogStreamRequest) (*UpdateLogStreamResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLogStream not implemented")
}
func (*UnimplementedClusterManagerServer) Seal(ctx context.Context, req *SealRequest) (*SealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Seal not implemented")
}
func (*UnimplementedClusterManagerServer) Sync(ctx context.Context, req *SyncRequest) (*SyncResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sync not implemented")
}
func (*UnimplementedClusterManagerServer) Unseal(ctx context.Context, req *UnsealRequest) (*UnsealResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unseal not implemented")
}
func (*UnimplementedClusterManagerServer) GetMRMembers(ctx context.Context, req *types.Empty) (*GetMRMembersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMRMembers not implemented")
}
func (*UnimplementedClusterManagerServer) AddMRPeer(ctx context.Context, req *AddMRPeerRequest) (*AddMRPeerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddMRPeer not implemented")
}
func (*UnimplementedClusterManagerServer) GetStorageNodes(ctx context.Context, req *types.Empty) (*GetStorageNodesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorageNodes not implemented")
}

func RegisterClusterManagerServer(s *grpc.Server, srv ClusterManagerServer) {
	s.RegisterService(&_ClusterManager_serviceDesc, srv)
}

func _ClusterManager_AddStorageNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddStorageNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddStorageNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/AddStorageNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddStorageNode(ctx, req.(*AddStorageNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UnregisterStorageNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterStorageNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UnregisterStorageNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/UnregisterStorageNode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UnregisterStorageNode(ctx, req.(*UnregisterStorageNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/AddLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddLogStream(ctx, req.(*AddLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UnregisterLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnregisterLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UnregisterLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/UnregisterLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UnregisterLogStream(ctx, req.(*UnregisterLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_RemoveLogStreamReplica_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveLogStreamReplicaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).RemoveLogStreamReplica(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/RemoveLogStreamReplica",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).RemoveLogStreamReplica(ctx, req.(*RemoveLogStreamReplicaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_UpdateLogStream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLogStreamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).UpdateLogStream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/UpdateLogStream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).UpdateLogStream(ctx, req.(*UpdateLogStreamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Seal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Seal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/Seal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Seal(ctx, req.(*SealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Sync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Sync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/Sync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Sync(ctx, req.(*SyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_Unseal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnsealRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).Unseal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/Unseal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).Unseal(ctx, req.(*UnsealRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_GetMRMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).GetMRMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/GetMRMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).GetMRMembers(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_AddMRPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddMRPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).AddMRPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/AddMRPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).AddMRPeer(ctx, req.(*AddMRPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ClusterManager_GetStorageNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ClusterManagerServer).GetStorageNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/varlog.vmspb.ClusterManager/GetStorageNodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ClusterManagerServer).GetStorageNodes(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ClusterManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "varlog.vmspb.ClusterManager",
	HandlerType: (*ClusterManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddStorageNode",
			Handler:    _ClusterManager_AddStorageNode_Handler,
		},
		{
			MethodName: "UnregisterStorageNode",
			Handler:    _ClusterManager_UnregisterStorageNode_Handler,
		},
		{
			MethodName: "AddLogStream",
			Handler:    _ClusterManager_AddLogStream_Handler,
		},
		{
			MethodName: "UnregisterLogStream",
			Handler:    _ClusterManager_UnregisterLogStream_Handler,
		},
		{
			MethodName: "RemoveLogStreamReplica",
			Handler:    _ClusterManager_RemoveLogStreamReplica_Handler,
		},
		{
			MethodName: "UpdateLogStream",
			Handler:    _ClusterManager_UpdateLogStream_Handler,
		},
		{
			MethodName: "Seal",
			Handler:    _ClusterManager_Seal_Handler,
		},
		{
			MethodName: "Sync",
			Handler:    _ClusterManager_Sync_Handler,
		},
		{
			MethodName: "Unseal",
			Handler:    _ClusterManager_Unseal_Handler,
		},
		{
			MethodName: "GetMRMembers",
			Handler:    _ClusterManager_GetMRMembers_Handler,
		},
		{
			MethodName: "AddMRPeer",
			Handler:    _ClusterManager_AddMRPeer_Handler,
		},
		{
			MethodName: "GetStorageNodes",
			Handler:    _ClusterManager_GetStorageNodes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/vmspb/vms.proto",
}

func (m *AddStorageNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStorageNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddStorageNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintVms(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddStorageNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddStorageNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddStorageNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StorageNode != nil {
		{
			size, err := m.StorageNode.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterStorageNodeRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterStorageNodeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterStorageNodeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterStorageNodeResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterStorageNodeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterStorageNodeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AddLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Replicas) > 0 {
		for iNdEx := len(m.Replicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Replicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVms(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnregisterLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnregisterLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnregisterLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RemoveLogStreamReplicaRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveLogStreamReplicaRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveLogStreamReplicaRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x10
	}
	if m.StorageNodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.StorageNodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RemoveLogStreamReplicaResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveLogStreamReplicaResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveLogStreamReplicaResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLogStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLogStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLogStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PushedReplica != nil {
		{
			size, err := m.PushedReplica.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PoppedReplica != nil {
		{
			size, err := m.PoppedReplica.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLogStreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLogStreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLogStreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SealRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SealResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SealedGLSN != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.SealedGLSN))
		i--
		dAtA[i] = 0x10
	}
	if len(m.LogStreams) > 0 {
		for iNdEx := len(m.LogStreams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LogStreams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVms(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SyncRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DstStorageNodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.DstStorageNodeID))
		i--
		dAtA[i] = 0x18
	}
	if m.SrcStorageNodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.SrcStorageNodeID))
		i--
		dAtA[i] = 0x10
	}
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnsealRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsealRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsealRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogStreamID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.LogStreamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnsealResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnsealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnsealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LogStream != nil {
		{
			size, err := m.LogStream.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVms(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetMRMembersResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMRMembersResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetMRMembersResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Members) > 0 {
		for k := range m.Members {
			v := m.Members[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintVms(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintVms(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintVms(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.ReplicationFactor != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.ReplicationFactor))
		i--
		dAtA[i] = 0x10
	}
	if m.Leader != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetStorageNodesResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStorageNodesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStorageNodesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Storagenodes) > 0 {
		for k := range m.Storagenodes {
			v := m.Storagenodes[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintVms(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i = encodeVarintVms(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintVms(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AddMRPeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMRPeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMRPeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RPCAddr) > 0 {
		i -= len(m.RPCAddr)
		copy(dAtA[i:], m.RPCAddr)
		i = encodeVarintVms(dAtA, i, uint64(len(m.RPCAddr)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RaftURL) > 0 {
		i -= len(m.RaftURL)
		copy(dAtA[i:], m.RaftURL)
		i = encodeVarintVms(dAtA, i, uint64(len(m.RaftURL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMRPeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.ProtoSize()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMRPeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.ProtoSize()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMRPeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NodeID != 0 {
		i = encodeVarintVms(dAtA, i, uint64(m.NodeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintVms(dAtA []byte, offset int, v uint64) int {
	offset -= sovVms(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AddStorageNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovVms(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddStorageNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNode != nil {
		l = m.StorageNode.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnregisterStorageNodeRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovVms(uint64(m.StorageNodeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnregisterStorageNodeResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.ProtoSize()
			n += 1 + l + sovVms(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnregisterLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnregisterLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveLogStreamReplicaRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StorageNodeID != 0 {
		n += 1 + sovVms(uint64(m.StorageNodeID))
	}
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveLogStreamReplicaResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateLogStreamRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	if m.PoppedReplica != nil {
		l = m.PoppedReplica.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	if m.PushedReplica != nil {
		l = m.PushedReplica.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateLogStreamResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SealRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SealResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.LogStreams) > 0 {
		for _, e := range m.LogStreams {
			l = e.ProtoSize()
			n += 1 + l + sovVms(uint64(l))
		}
	}
	if m.SealedGLSN != 0 {
		n += 1 + sovVms(uint64(m.SealedGLSN))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	if m.SrcStorageNodeID != 0 {
		n += 1 + sovVms(uint64(m.SrcStorageNodeID))
	}
	if m.DstStorageNodeID != 0 {
		n += 1 + sovVms(uint64(m.DstStorageNodeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SyncResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnsealRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStreamID != 0 {
		n += 1 + sovVms(uint64(m.LogStreamID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnsealResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LogStream != nil {
		l = m.LogStream.ProtoSize()
		n += 1 + l + sovVms(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetMRMembersResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Leader != 0 {
		n += 1 + sovVms(uint64(m.Leader))
	}
	if m.ReplicationFactor != 0 {
		n += 1 + sovVms(uint64(m.ReplicationFactor))
	}
	if len(m.Members) > 0 {
		for k, v := range m.Members {
			_ = k
			_ = v
			mapEntrySize := 1 + sovVms(uint64(k)) + 1 + len(v) + sovVms(uint64(len(v)))
			n += mapEntrySize + 1 + sovVms(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStorageNodesResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Storagenodes) > 0 {
		for k, v := range m.Storagenodes {
			_ = k
			_ = v
			mapEntrySize := 1 + sovVms(uint64(k)) + 1 + len(v) + sovVms(uint64(len(v)))
			n += mapEntrySize + 1 + sovVms(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddMRPeerRequest) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RaftURL)
	if l > 0 {
		n += 1 + l + sovVms(uint64(l))
	}
	l = len(m.RPCAddr)
	if l > 0 {
		n += 1 + l + sovVms(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddMRPeerResponse) ProtoSize() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NodeID != 0 {
		n += 1 + sovVms(uint64(m.NodeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovVms(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVms(x uint64) (n int) {
	return sovVms(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AddStorageNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddStorageNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddStorageNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddStorageNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddStorageNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddStorageNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StorageNode == nil {
				m.StorageNode = &varlogpb.StorageNodeMetadataDescriptor{}
			}
			if err := m.StorageNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterStorageNodeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterStorageNodeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterStorageNodeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterStorageNodeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterStorageNodeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterStorageNodeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, &varlogpb.ReplicaDescriptor{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnregisterLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnregisterLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnregisterLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveLogStreamReplicaRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageNodeID", wireType)
			}
			m.StorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveLogStreamReplicaResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveLogStreamReplicaResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLogStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLogStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLogStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoppedReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PoppedReplica == nil {
				m.PoppedReplica = &varlogpb.ReplicaDescriptor{}
			}
			if err := m.PoppedReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PushedReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PushedReplica == nil {
				m.PushedReplica = &varlogpb.ReplicaDescriptor{}
			}
			if err := m.PushedReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLogStreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLogStreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLogStreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogStreams = append(m.LogStreams, varlogpb.LogStreamMetadataDescriptor{})
			if err := m.LogStreams[len(m.LogStreams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SealedGLSN", wireType)
			}
			m.SealedGLSN = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SealedGLSN |= github_daumkakao_com_varlog_varlog_pkg_types.GLSN(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcStorageNodeID", wireType)
			}
			m.SrcStorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcStorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DstStorageNodeID", wireType)
			}
			m.DstStorageNodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DstStorageNodeID |= github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &snpb.SyncStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsealRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsealRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsealRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStreamID", wireType)
			}
			m.LogStreamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogStreamID |= github_daumkakao_com_varlog_varlog_pkg_types.LogStreamID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnsealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnsealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnsealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogStream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LogStream == nil {
				m.LogStream = &varlogpb.LogStreamDescriptor{}
			}
			if err := m.LogStream.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMRMembersResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMRMembersResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMRMembersResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= github_daumkakao_com_varlog_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicationFactor", wireType)
			}
			m.ReplicationFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicationFactor |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Members == nil {
				m.Members = make(map[github_daumkakao_com_varlog_varlog_pkg_types.NodeID]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVms
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVms
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVms
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthVms
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthVms
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVms(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVms
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Members[github_daumkakao_com_varlog_varlog_pkg_types.NodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStorageNodesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStorageNodesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStorageNodesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Storagenodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Storagenodes == nil {
				m.Storagenodes = make(map[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID]string)
			}
			var mapkey uint32
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVms
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVms
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVms
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthVms
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthVms
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVms(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthVms
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Storagenodes[github_daumkakao_com_varlog_varlog_pkg_types.StorageNodeID(mapkey)] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMRPeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMRPeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMRPeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftURL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftURL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RPCAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVms
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVms
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RPCAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMRPeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVms
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMRPeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMRPeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVms
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= github_daumkakao_com_varlog_varlog_pkg_types.NodeID(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVms(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthVms
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVms(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVms
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVms
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVms
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVms
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVms
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVms
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVms        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVms          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVms = fmt.Errorf("proto: unexpected end of group")
)
