// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/kakao/varlog/pkg/varlog (interfaces: Log)
//
// Generated by this command:
//
//	mockgen -package varlog -destination log_mock.go . Log
//

// Package varlog is a generated GoMock package.
package varlog

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"

	types "github.com/kakao/varlog/pkg/types"
	varlogpb "github.com/kakao/varlog/proto/varlogpb"
)

// MockLog is a mock of Log interface.
type MockLog struct {
	ctrl     *gomock.Controller
	recorder *MockLogMockRecorder
}

// MockLogMockRecorder is the mock recorder for MockLog.
type MockLogMockRecorder struct {
	mock *MockLog
}

// NewMockLog creates a new mock instance.
func NewMockLog(ctrl *gomock.Controller) *MockLog {
	mock := &MockLog{ctrl: ctrl}
	mock.recorder = &MockLogMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLog) EXPECT() *MockLogMockRecorder {
	return m.recorder
}

// Append mocks base method.
func (m *MockLog) Append(arg0 context.Context, arg1 types.TopicID, arg2 [][]byte, arg3 ...AppendOption) AppendResult {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1, arg2}
	for _, a := range arg3 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Append", varargs...)
	ret0, _ := ret[0].(AppendResult)
	return ret0
}

// Append indicates an expected call of Append.
func (mr *MockLogMockRecorder) Append(arg0, arg1, arg2 any, arg3 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1, arg2}, arg3...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockLog)(nil).Append), varargs...)
}

// AppendTo mocks base method.
func (m *MockLog) AppendTo(arg0 context.Context, arg1 types.TopicID, arg2 types.LogStreamID, arg3 [][]byte, arg4 ...AppendOption) AppendResult {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1, arg2, arg3}
	for _, a := range arg4 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendTo", varargs...)
	ret0, _ := ret[0].(AppendResult)
	return ret0
}

// AppendTo indicates an expected call of AppendTo.
func (mr *MockLogMockRecorder) AppendTo(arg0, arg1, arg2, arg3 any, arg4 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1, arg2, arg3}, arg4...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendTo", reflect.TypeOf((*MockLog)(nil).AppendTo), varargs...)
}

// AppendableLogStreams mocks base method.
func (m *MockLog) AppendableLogStreams(arg0 types.TopicID) map[types.LogStreamID]struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AppendableLogStreams", arg0)
	ret0, _ := ret[0].(map[types.LogStreamID]struct{})
	return ret0
}

// AppendableLogStreams indicates an expected call of AppendableLogStreams.
func (mr *MockLogMockRecorder) AppendableLogStreams(arg0 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendableLogStreams", reflect.TypeOf((*MockLog)(nil).AppendableLogStreams), arg0)
}

// Close mocks base method.
func (m *MockLog) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockLogMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockLog)(nil).Close))
}

// NewLogStreamAppender mocks base method.
func (m *MockLog) NewLogStreamAppender(arg0 types.TopicID, arg1 types.LogStreamID, arg2 ...LogStreamAppenderOption) (LogStreamAppender, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewLogStreamAppender", varargs...)
	ret0, _ := ret[0].(LogStreamAppender)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewLogStreamAppender indicates an expected call of NewLogStreamAppender.
func (mr *MockLogMockRecorder) NewLogStreamAppender(arg0, arg1 any, arg2 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewLogStreamAppender", reflect.TypeOf((*MockLog)(nil).NewLogStreamAppender), varargs...)
}

// PeekLogStream mocks base method.
func (m *MockLog) PeekLogStream(arg0 context.Context, arg1 types.TopicID, arg2 types.LogStreamID) (varlogpb.LogSequenceNumber, varlogpb.LogSequenceNumber, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeekLogStream", arg0, arg1, arg2)
	ret0, _ := ret[0].(varlogpb.LogSequenceNumber)
	ret1, _ := ret[1].(varlogpb.LogSequenceNumber)
	ret2, _ := ret[2].(bool)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// PeekLogStream indicates an expected call of PeekLogStream.
func (mr *MockLogMockRecorder) PeekLogStream(arg0, arg1, arg2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeekLogStream", reflect.TypeOf((*MockLog)(nil).PeekLogStream), arg0, arg1, arg2)
}

// Subscribe mocks base method.
func (m *MockLog) Subscribe(arg0 context.Context, arg1 types.TopicID, arg2, arg3 types.GLSN, arg4 OnNext, arg5 ...SubscribeOption) (SubscribeCloser, error) {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(SubscribeCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockLogMockRecorder) Subscribe(arg0, arg1, arg2, arg3, arg4 any, arg5 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockLog)(nil).Subscribe), varargs...)
}

// SubscribeTo mocks base method.
func (m *MockLog) SubscribeTo(arg0 context.Context, arg1 types.TopicID, arg2 types.LogStreamID, arg3, arg4 types.LLSN, arg5 ...SubscribeOption) Subscriber {
	m.ctrl.T.Helper()
	varargs := []any{arg0, arg1, arg2, arg3, arg4}
	for _, a := range arg5 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeTo", varargs...)
	ret0, _ := ret[0].(Subscriber)
	return ret0
}

// SubscribeTo indicates an expected call of SubscribeTo.
func (mr *MockLogMockRecorder) SubscribeTo(arg0, arg1, arg2, arg3, arg4 any, arg5 ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{arg0, arg1, arg2, arg3, arg4}, arg5...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeTo", reflect.TypeOf((*MockLog)(nil).SubscribeTo), varargs...)
}

// Trim mocks base method.
func (m *MockLog) Trim(arg0 context.Context, arg1 types.TopicID, arg2 types.GLSN, arg3 TrimOption) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Trim", arg0, arg1, arg2, arg3)
	ret0, _ := ret[0].(error)
	return ret0
}

// Trim indicates an expected call of Trim.
func (mr *MockLogMockRecorder) Trim(arg0, arg1, arg2, arg3 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Trim", reflect.TypeOf((*MockLog)(nil).Trim), arg0, arg1, arg2, arg3)
}
