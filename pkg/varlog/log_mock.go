// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/kakao/varlog/pkg/varlog (interfaces: Log)
//
// Generated by this command:
//
//	mockgen -package varlog -destination log_mock.go . Log
//

// Package varlog is a generated GoMock package.
package varlog

import (
	context "context"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"

	types "github.com/kakao/varlog/pkg/types"
	varlogpb "github.com/kakao/varlog/proto/varlogpb"
)

// MockLog is a mock of Log interface.
type MockLog struct {
	ctrl     *gomock.Controller
	recorder *MockLogMockRecorder
	isgomock struct{}
}

// MockLogMockRecorder is the mock recorder for MockLog.
type MockLogMockRecorder struct {
	mock *MockLog
}

// NewMockLog creates a new mock instance.
func NewMockLog(ctrl *gomock.Controller) *MockLog {
	mock := &MockLog{ctrl: ctrl}
	mock.recorder = &MockLogMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLog) EXPECT() *MockLogMockRecorder {
	return m.recorder
}

// Append mocks base method.
func (m *MockLog) Append(ctx context.Context, topicID types.TopicID, data [][]byte, opts ...AppendOption) AppendResult {
	m.ctrl.T.Helper()
	varargs := []any{ctx, topicID, data}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Append", varargs...)
	ret0, _ := ret[0].(AppendResult)
	return ret0
}

// Append indicates an expected call of Append.
func (mr *MockLogMockRecorder) Append(ctx, topicID, data any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, topicID, data}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Append", reflect.TypeOf((*MockLog)(nil).Append), varargs...)
}

// AppendTo mocks base method.
func (m *MockLog) AppendTo(ctx context.Context, topicID types.TopicID, logStreamID types.LogStreamID, data [][]byte, opts ...AppendOption) AppendResult {
	m.ctrl.T.Helper()
	varargs := []any{ctx, topicID, logStreamID, data}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AppendTo", varargs...)
	ret0, _ := ret[0].(AppendResult)
	return ret0
}

// AppendTo indicates an expected call of AppendTo.
func (mr *MockLogMockRecorder) AppendTo(ctx, topicID, logStreamID, data any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, topicID, logStreamID, data}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendTo", reflect.TypeOf((*MockLog)(nil).AppendTo), varargs...)
}

// AppendableLogStreams mocks base method.
func (m *MockLog) AppendableLogStreams(tpid types.TopicID) map[types.LogStreamID]struct{} {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AppendableLogStreams", tpid)
	ret0, _ := ret[0].(map[types.LogStreamID]struct{})
	return ret0
}

// AppendableLogStreams indicates an expected call of AppendableLogStreams.
func (mr *MockLogMockRecorder) AppendableLogStreams(tpid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AppendableLogStreams", reflect.TypeOf((*MockLog)(nil).AppendableLogStreams), tpid)
}

// Close mocks base method.
func (m *MockLog) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockLogMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockLog)(nil).Close))
}

// NewLogStreamAppender mocks base method.
func (m *MockLog) NewLogStreamAppender(tpid types.TopicID, lsid types.LogStreamID, opts ...LogStreamAppenderOption) (LogStreamAppender, error) {
	m.ctrl.T.Helper()
	varargs := []any{tpid, lsid}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "NewLogStreamAppender", varargs...)
	ret0, _ := ret[0].(LogStreamAppender)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewLogStreamAppender indicates an expected call of NewLogStreamAppender.
func (mr *MockLogMockRecorder) NewLogStreamAppender(tpid, lsid any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{tpid, lsid}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewLogStreamAppender", reflect.TypeOf((*MockLog)(nil).NewLogStreamAppender), varargs...)
}

// PeekLogStream mocks base method.
func (m *MockLog) PeekLogStream(ctx context.Context, tpid types.TopicID, lsid types.LogStreamID) (varlogpb.LogSequenceNumber, varlogpb.LogSequenceNumber, bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PeekLogStream", ctx, tpid, lsid)
	ret0, _ := ret[0].(varlogpb.LogSequenceNumber)
	ret1, _ := ret[1].(varlogpb.LogSequenceNumber)
	ret2, _ := ret[2].(bool)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// PeekLogStream indicates an expected call of PeekLogStream.
func (mr *MockLogMockRecorder) PeekLogStream(ctx, tpid, lsid any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PeekLogStream", reflect.TypeOf((*MockLog)(nil).PeekLogStream), ctx, tpid, lsid)
}

// Subscribe mocks base method.
func (m *MockLog) Subscribe(ctx context.Context, topicID types.TopicID, begin, end types.GLSN, onNextFunc OnNext, opts ...SubscribeOption) (SubscribeCloser, error) {
	m.ctrl.T.Helper()
	varargs := []any{ctx, topicID, begin, end, onNextFunc}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Subscribe", varargs...)
	ret0, _ := ret[0].(SubscribeCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockLogMockRecorder) Subscribe(ctx, topicID, begin, end, onNextFunc any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, topicID, begin, end, onNextFunc}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockLog)(nil).Subscribe), varargs...)
}

// SubscribeTo mocks base method.
func (m *MockLog) SubscribeTo(ctx context.Context, topicID types.TopicID, logStreamID types.LogStreamID, begin, end types.LLSN, opts ...SubscribeOption) Subscriber {
	m.ctrl.T.Helper()
	varargs := []any{ctx, topicID, logStreamID, begin, end}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "SubscribeTo", varargs...)
	ret0, _ := ret[0].(Subscriber)
	return ret0
}

// SubscribeTo indicates an expected call of SubscribeTo.
func (mr *MockLogMockRecorder) SubscribeTo(ctx, topicID, logStreamID, begin, end any, opts ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx, topicID, logStreamID, begin, end}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubscribeTo", reflect.TypeOf((*MockLog)(nil).SubscribeTo), varargs...)
}

// Trim mocks base method.
func (m *MockLog) Trim(ctx context.Context, topicID types.TopicID, until types.GLSN, opts TrimOption) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Trim", ctx, topicID, until, opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Trim indicates an expected call of Trim.
func (mr *MockLogMockRecorder) Trim(ctx, topicID, until, opts any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Trim", reflect.TypeOf((*MockLog)(nil).Trim), ctx, topicID, until, opts)
}
