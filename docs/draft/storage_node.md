- Status: Rejected
- Reason: CORFU 모델 및 CR 방식보다 Scalog 모델 및 PB 방식으로 설계 변경
- Authors: jun.song
- Date: 2020-05-10

# Storage Node
이 문서에서는 아래와 같은 가정을 한다.

- Client 기반의 Chain Replication 방식을 사용한다.
- Replica의 수는 3개이며, Storage Node 2개가 Fail될때까지 Availability를 유지할
수 있다.

## Basic APIs
### Append
Client는 Log Entry를 Append하기 위해서 Sequencer에게 GLSN을 발급받는다. GLSN은
Log Entry가 쓰여질 위치이다. 해당 GLSN이 쓰여져야할 Log Stream의 Replica정보는
Client 로컬 Projection 정보를 통해 알아내고, Chain Replication 순서대로 Storage
Node들에 write 요청을 한다. 

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |
         |            |            |            |            |            |
         <--next:ok--->            |            |            |            |
         |            |            |            |            |            |
         <---write:ok-+------------>            |            |            |
         <---write:ok-+------------+------------>            |            |
         <---write:ok-+------------+------------+------------>            |
         |            |            |            |            |            |
         |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

Write가 성공하는 경우 4RTTs RPC가 발생한다.

### Read
Client가 특정 로그 읽기 위해서 먼저 해당 GLSN을 갖고 있는 Log Stream의
Replica들을 알아야한다. 이는 로컬에 저장된 Projection을 통해서 알수 있다. Chain
Replication의 Tail (아래 그림에서는 SN3)에게 읽기 요청을 한다.

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |
         |            |            |            |            |            |
         <---read:ok--+------------+------------+------------>            |
         |            |            |            |            |            |
         |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

Read가 성공하는 경우 1RTT RPC가 발생한다.

### Fill
### Trim
### Seal
### Subscribe

## Fault-tolerance

### Append failure
CL이 append를 시도하지만 SN에 장애가 발생하여 실패할 수 있다. CR (Chain
Replication)의 경우, chain의 head와 tail은 중요한 역할을 한다. Log Entry를
append하려면 head에 가장 먼저 write RPC를 시도한다. Chain을 구성하는 모든 SN에게
write RPC를 성공하고 tail 까지 write를 성공했다면, Log Entry는 완전히 쓰여진
것이다. 그러므로 read RPC는 tail SN에게만 시도한다.  
CR에서 head와 tail은 중요한 역할을 하므로, SN의 장애 상황은 head와 tail의 장애로
나누어 살펴본다. Chain에서 head와 tail이 아닌 SN의 failure는 두가지 상황과
유사하게 대처한다.

#### Failure of the head of a chain

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |
      epoch=1         |         epoch=1      epoch=1      epoch=1      epoch=1
         |            |            |            |            |            |    <-+
      CR:SN1->SN2->SN3|            |            |            |            |      |
         |            |            |            |            |            |      |
         <--next:ok--->            |            |            |            |      |
         |            |            |            |            |            |      |
         +--write:error-------->   |            |            |            |      |
        +++           |            |            |            |            |      |
        | duration to decide if SN1 fails       |            |            |      |
        | and CL triggers reconfiguration       |            |            |     (a)
        | |           |            |            |            |            |      |
        +++           |            |            |            |            |      |
         |            |            |            |            |            |      |
      +----------------------------------------------------------------------+   |
      |reconfiguration|            |            |            |            |  |   |
      |  +------------+------------>            |            |            |  |   |
      |  <------------+------------+------------>            |            |  |   |
      |  <------------+------------+------------+------------>            |  |   |
      |  <------------+------------+------------+------------+------------>  | <-+
      +----------------------------------------------------------------------+
         |            |            |            |            |            |
      epoch=2         |         failed       epoch=2      epoch=2      epoch=2
         |            |            |            |            |            |    <-+
      CR:SN2->SN3     |            |            |            |            |      |
         |            |            |            |            |            |      |
         <--write:ok--+------------+------------>            |            |      |
         <--write:ok--+------------+------------+------------>            |      |
         |            |            |            |            |            |      |
         |            |            |            |            |            |      |
         +--write:error------------+-------->   |            |            |      |
        +++           |            |            |            |            |      |
        | duration to decide if SN2 fails       |            |            |     (b)
        | and CL triggers reconfiguration       |            |            |      |
        | |           |            |            |            |            |      |
        +++           |            |            |            |            |      |
         |            |            |            |            |            |      |
      +----------------------------------------------------------------------+   |
      |reconfiguration|            |            |            |            |  |   |
      |  +------------+------------>            |            |            |  |   |
      |  <------------+------------+------------>            |            |  |   |
      |  <------------+------------+------------+------------>            |  |   |
      |  <------------+------------+------------+------------+------------>  | <-+
      +----------------------------------------------------------------------+
         |            |            |            |            |            |
      epoch=3         |         failed       failed       epoch=3      epoch=3
         |            |            |            |            |            |
      CR:SN3          |            |            |            |            |
         |            |            |            |            |            |    <-+
      +----------------------------------------------------------------------+   |
      | WARN: no redundancy!       |            |            |            |  |  (c)
      |  <--write:ok--+------------+------------+------------>            |  |   |
      +----------------------------------------------------------------------+   |
         |            |            |            |            |            |    <-+
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

위 그림은 SN1에서 SN2를 거쳐 SN3로 이어지는 Chain Replication을 표현한다.  
(a)는 Chain 여기서 Chain의 Head, 즉 SN1이 Fail한 모습니다. CL은 append를 위해
SN1에 write를 하지만, 이 RPC는 실패한다. CL은 reconfiguration을 시작하고, 로컬에
저장된 Projection을 갱신한다. 여기서 두가지 이슈가 있다.

- SN1에 장애가 있음을 확신하기 위한 조건 필요
- Reconfiguration이 짧아야 한다.

CL이 reconfiguration을 완료하여 특정 GLSN을 담당하는 Log Stream의 Chain
Replication이 SN2와 SN3로 이루어지게 된다 (b). SN2가 해당 Chain 의 새로운 head
가 된다. 해당 Log Stream은 replica가 2개인 상태로 정상 동작할 수 있다.  
이때 SN2에 장애가 발생하고 CL이 append를 실패할 수 있다. CL은 다시
reconfiguration을 시도하고, 해당 Log Stream에 대한 Storage Node가 SN3만
남게된다\(c\). SN3는 아래와 같은 동작이 가능하다: 

- 데이터 중복을 제공할 수 없다. (no replica) 이는 availability에 문제가 생길 수
있다.
- 읽기 요청은 안정적으로 받을 수 있다.

#### Failure of the tail of a chain
Chain의 tail은 append에서 가장 마지막에 쓰여지는 노드이다. 즉, tail에 쓰여진
로그 엔트리는 commit된 것이며, replication이 완료된 데이터이다. 그러므로 CL이
read할때 tail 노드만 읽기를 한다. append 과정에서 tail에 해당하는 Storage Node가
fail된 경우, reconfiguration을 하고 실패한 write를 이어서 진행한다.

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |
      epoch=1         |         epoch=1      epoch=1      epoch=1      epoch=1
         |            |            |            |            |            |
      CR:SN1->SN2->SN3|            |            |            |            |
         |            |            |            |            |            |
         |            |            |            |            |            |
     +-  <--next:ok--->            |            |            |            |
     |   <--write:ok--+------------>            |            |            |
    ++   <--write:ok--+------------+------------>            |            |
    |+-  +--write:error------------+------------+-------->   |            |
    |    |            |            |            |            |            |
    | +----------------------------------------------------------------------+
    | |reconfiguration|            |            |            |            |  |
    | |  +------------+------------>            |            |            |  |
    | |  <------------+------------+------------>            |            |  |
    | |  <------------+------------+------------+------------>            |  |
    | |  <------------+------------+------------+------------+------------>  |
    | +----------------------------------------------------------------------+
    |    |            |            |            |            |            |
    | epoch=2         |        epoch=2       epoch=2      failed       epoch=2
    |    |            |            |            |            |            |
    | CR:SN1->SN2     |            |            |            |            |
    |    |            |            |            |            |            |
    +-->resume append & ok         |            |            |            |
         |            |            |            |            |            |
         |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

#### Failure of a CL
CL이 append 중에 장애가 발생할 수 있다. SQ로부터 GLSN을 받아서 SN에 전혀
write하지 못한 경우와 일부 SN에 write가 성공한 경우를 나누어 살펴보겠다.

CL1이 SQ에게 새로운 로그 위치를 받았으나 SN들에게 write를 하지 못하고 장애가
발생할 수 있다. 다른 클라이언트인 CL2가 해당 로그 위치에 대해 SN3에게 읽기를
시도 했으나 쓰여진 로그 엔트리가 없기 때문에 err_unwritten 응답을 받게 된다.
CL2가 해당 위치에 append 하던 클라이언트(CL1)이 문제가 생겨 더 이상 append가
진행되지 않을 거라 판단하면 해당 위치에 대해 fill 을 시도한다.

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |  CL1   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |   |  CL2   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |            |
      epoch=1         |         epoch=1      epoch=1      epoch=1      epoch=1         |
         |            |            |            |            |            |            |
      CR:SN1->SN2->SN3|            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
         <--next:ok--->            |            |            |            |            |
         |            |            |            |            |            |            |
      failed          |            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |            |            <---------read:unwritten-->
         |            <------------+------------+------------+------------+---peek:ok-->
         |            |            |            |            |            |            |
         |            |            |            |            | the interval between   +++
         |            |            |            |           unwritten read and fill <-+ |
         |            |            |            |            |            |           +++
         |            |            |            |            |            |            |
         |            |            <------------+------------+------------+---fill:ok--+
         |            |            |            <------------+------------+---fill:ok--+
         |            |            |            |            <------------+---fill:ok--+
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |  CL1   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |   |  CL2   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

여기서 중요한 이슈가 있다:

- CL1이 아직 살아있고 write를 시도 하기 전에 fill하면 안된다.
- 아직 아무도 append 하지 않은 GLSN을 fill하지 않아야 한다.

첫번째 이슈를 위해서는 CL2가 SN3에게 read 요청에 대한 err_unwritten 응답을 받은
이후, 어느 정도의 시간이 지나서 SN1에게 fill 요청을 보내야 한다. 이 시간 간격이
얼마나 적극적으로 fill을 할 것인가를 결정하고 이는 application마다 달라질 수
있다. 두번째 이슈를 극복하기 위해서 SQ는 peek API를 제공할 것이다. 이 API를
사용하면, GLSN을 새로 받급받지 않고 현재까지 발급된 가장 큰 값을 얻을 수 있다.
연속적으로 Log Tail을 하는 애플리케이션을 위해서는 subscribe API를 제공할
것이다. subscribe API는 CL이 SN들에게 새로운 데이터를 구독받는 API이다.  
CL2가 read에 대한 응답으로 err_unwritten을 받았다면, SQ의 peek API를 통해 발급한
GLSN중 가장 큰 값(max issued GLSN)을 얻을 수 있다. CL2가 읽으려는 로그 위치가 
max issued GLSN 보다 크다면, read 요청은 더 이상 진행하지 않아야 한다. 하지만,
이미 발급한 GLSN을 읽으려 했다면, 정해진 interval 이후에 fill 요청을 SN1에게
보낸다. 만약 fill 요청이 성공했다면, 이어서 CR에 있는 다른 SN들에게 순서대로
fill을 한다.

CL2의 fill 요청이 CR의 첫번째 SN에서 실패할 수도 있다. 이 경우는 아래 그림을
통해 다시 알아본다. 

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |  CL1   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |   |  CL2   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |            |
      epoch=1         |         epoch=1      epoch=1      epoch=1      epoch=1         |
         |            |            |            |            |            |            |
      CR:SN1->SN2->SN3|            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
         <--next:ok--->            |            |            |            |            |
         <--write:ok--+------------>            |            |            |            |
         |            |            |            |            |            |            |
      failed          |            |            |            |            |            |
         |            |            |            |            <---------read:unwritten-->
         |            <------------+------------+------------+------------+---peek:ok-->
         |            |            |            |            |            |            |
         |            |            |            |            | the interval between   +++
         |            |            |            |           unwritten read and fill <-+ |
         |            |            |            |            |            |           +++
         |            |            |            |            |            |            |
         |            |            <------------+----fill:err_written(existing value)--+
         |            |            |            <------------+------------+--write:ok--+
         |            |            |            |            <------------+--write:ok--+
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |  CL1   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |   |  CL2   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

CL2는 SN1에 fill을 시도하지만, err_written과 함께 이미 쓰여있는 값을 전달받는다.
CL2는 이미 쓰여진 정상적인 Log Entry를 CR상의 다른 SN들에게 write 시도한다.
CL1이 Log Proxy Server (Application 에게 Varlog의 기능을 제공하는 서버이며,
Client Library로 구현된 API 서버)라면, 이를 이용해 log entry를 append하던
application은 network error를 전달받을 것이며, 이는 append 성공/실패를 의미하지
않는다. 만약 CL1이 append를 시도하던 application 자체이며, append execution
context가 강제로 중단된 경우라면, append 성공과 실패를 알수 없다. Varlog의
클라이언트는 이러한 점을 주의해야 한다.  
Varlog가 Transaction 로그로 활용될 경우, Client는 다시 이 로그를 읽음으로써
자신의 append가 성공/실패했는지를 알 수 있다. 


