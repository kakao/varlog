# Storage Node
이 문서에서는 아래와 같은 가정을 한다.

- Client 기반의 Chain Replication 방식을 사용한다.
- Replica의 수는 3개이며, Storage Node 2개가 Fail될때까지 Availability를 유지할
수 있다.

## Basic APIs
### Append
Client는 Log Entry를 Append하기 위해서 Sequencer에게 GLSN을 발급받는다. GLSN은
Log Entry가 쓰여질 위치이다. 해당 GLSN이 쓰여져야할 Log Stream의 Replica정보는
Client 로컬 Projection 정보를 통해 알아내고, Chain Replication 순서대로 Storage
Node들에 write 요청을 한다. 

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |
         |            |            |            |            |            |
         <--next:ok--->            |            |            |            |
         |            |            |            |            |            |
         <---write:ok-+------------>            |            |            |
         <---write:ok-+------------+------------>            |            |
         <---write:ok-+------------+------------+------------>            |
         |            |            |            |            |            |
         |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

Write가 성공하는 경우 4RTTs RPC가 발생한다.

### Read
Client가 특정 로그 읽기 위해서 먼저 해당 GLSN을 갖고 있는 Log Stream의
Replica들을 알아야한다. 이는 로컬에 저장된 Projection을 통해서 알수 있다. Chain
Replication의 Tail (아래 그림에서는 SN3)에게 읽기 요청을 한다.

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |
         |            |            |            |            |            |
         <---read:ok--+------------+------------+------------>            |
         |            |            |            |            |            |
         |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

Read가 성공하는 경우 1RTT RPC가 발생한다.

### Fill
### Trim
### Seal
### Subscribe

## Fault-tolerance

### Append failure
CL이 append를 시도하지만 SN에 장애가 발생하여 실패할 수 있다. CR (Chain
Replication)의 경우, chain의 head와 tail은 중요한 역할을 한다. Log Entry를
append하려면 head에 가장 먼저 write RPC를 시도한다. Chain을 구성하는 모든 SN에게
write RPC를 성공하고 tail 까지 write를 성공했다면, Log Entry는 완전히 쓰여진
것이다. 그러므로 read RPC는 tail SN에게만 시도한다.  
CR에서 head와 tail은 중요한 역할을 하므로, SN의 장애 상황은 head와 tail의 장애로
나누어 살펴본다. Chain에서 head와 tail이 아닌 SN의 failure는 두가지 상황과
유사하게 대처한다.

#### Failure of the head of a chain

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |
      epoch=1         |         epoch=1      epoch=1      epoch=1      epoch=1
         |            |            |            |            |            |    <-+
      CR:SN1->SN2->SN3|            |            |            |            |      |
         |            |            |            |            |            |      |
         <--next:ok--->            |            |            |            |      |
         |            |            |            |            |            |      |
         +--write:error-------->   |            |            |            |      |
        +++           |            |            |            |            |      |
        | duration to decide if SN1 fails       |            |            |      |
        | and CL triggers reconfiguration       |            |            |     (a)
        | |           |            |            |            |            |      |
        +++           |            |            |            |            |      |
         |            |            |            |            |            |      |
      +----------------------------------------------------------------------+   |
      |reconfiguration|            |            |            |            |  |   |
      |  +------------+------------>            |            |            |  |   |
      |  <------------+------------+------------>            |            |  |   |
      |  <------------+------------+------------+------------>            |  |   |
      |  <------------+------------+------------+------------+------------>  | <-+
      +----------------------------------------------------------------------+
         |            |            |            |            |            |
      epoch=2         |         failed       epoch=2      epoch=2      epoch=2
         |            |            |            |            |            |    <-+
      CR:SN2->SN3     |            |            |            |            |      |
         |            |            |            |            |            |      |
         <--write:ok--+------------+------------>            |            |      |
         <--write:ok--+------------+------------+------------>            |      |
         |            |            |            |            |            |      |
         |            |            |            |            |            |      |
         +--write:error------------+-------->   |            |            |      |
        +++           |            |            |            |            |      |
        | duration to decide if SN2 fails       |            |            |     (b)
        | and CL triggers reconfiguration       |            |            |      |
        | |           |            |            |            |            |      |
        +++           |            |            |            |            |      |
         |            |            |            |            |            |      |
      +----------------------------------------------------------------------+   |
      |reconfiguration|            |            |            |            |  |   |
      |  +------------+------------>            |            |            |  |   |
      |  <------------+------------+------------>            |            |  |   |
      |  <------------+------------+------------+------------>            |  |   |
      |  <------------+------------+------------+------------+------------>  | <-+
      +----------------------------------------------------------------------+
         |            |            |            |            |            |
      epoch=3         |         failed       failed       epoch=3      epoch=3
         |            |            |            |            |            |
      CR:SN3          |            |            |            |            |
         |            |            |            |            |            |    <-+
      +----------------------------------------------------------------------+   |
      | WARN: no redundancy!       |            |            |            |  |  (c)
      |  <--write:ok--+------------+------------+------------>            |  |   |
      +----------------------------------------------------------------------+   |
         |            |            |            |            |            |    <-+
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

위 그림은 SN1에서 SN2를 거쳐 SN3로 이어지는 Chain Replication을 표현한다.  
(a)는 Chain 여기서 Chain의 Head, 즉 SN1이 Fail한 모습니다. CL은 append를 위해
SN1에 write를 하지만, 이 RPC는 실패한다. CL은 reconfiguration을 시작하고, 로컬에
저장된 Projection을 갱신한다. 여기서 두가지 이슈가 있다.

- SN1에 장애가 있음을 확신하기 위한 조건 필요
- Reconfiguration이 짧아야 한다.

CL이 reconfiguration을 완료하여 특정 GLSN을 담당하는 Log Stream의 Chain
Replication이 SN2와 SN3로 이루어지게 된다 (b). SN2가 해당 Chain 의 새로운 head
가 된다. 해당 Log Stream은 replica가 2개인 상태로 정상 동작할 수 있다.  
이때 SN2에 장애가 발생하고 CL이 append를 실패할 수 있다. CL은 다시
reconfiguration을 시도하고, 해당 Log Stream에 대한 Storage Node가 SN3만
남게된다\(c\). SN3는 아래와 같은 동작이 가능하다: 

- 데이터 중복을 제공할 수 없다. (no replica) 이는 availability에 문제가 생길 수
있다.
- 읽기 요청은 안정적으로 받을 수 있다.

#### Failure of the tail of a chain
Chain의 tail은 append에서 가장 마지막에 쓰여지는 노드이다. 즉, tail에 쓰여진
로그 엔트리는 commit된 것이며, replication이 완료된 데이터이다. 그러므로 CL이
read할때 tail 노드만 읽기를 한다. append 과정에서 tail에 해당하는 Storage Node가
fail된 경우, reconfiguration을 하고 실패한 write를 이어서 진행한다.

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |
      epoch=1         |         epoch=1      epoch=1      epoch=1      epoch=1
         |            |            |            |            |            |
      CR:SN1->SN2->SN3|            |            |            |            |
         |            |            |            |            |            |
         |            |            |            |            |            |
     +-  <--next:ok--->            |            |            |            |
     |   <--write:ok--+------------>            |            |            |
    ++   <--write:ok--+------------+------------>            |            |
    |+-  +--write:error------------+------------+-------->   |            |
    |    |            |            |            |            |            |
    | +----------------------------------------------------------------------+
    | |reconfiguration|            |            |            |            |  |
    | |  +------------+------------>            |            |            |  |
    | |  <------------+------------+------------>            |            |  |
    | |  <------------+------------+------------+------------>            |  |
    | |  <------------+------------+------------+------------+------------>  |
    | +----------------------------------------------------------------------+
    |    |            |            |            |            |            |
    | epoch=2         |        epoch=2       epoch=2      failed       epoch=2
    |    |            |            |            |            |            |
    | CR:SN1->SN2     |            |            |            |            |
    |    |            |            |            |            |            |
    +-->resume append & ok         |            |            |            |
         |            |            |            |            |            |
         |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |   CL   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

#### Failure of a CL
CL이 append 중에 장애가 발생할 수 있다. SQ로부터 GLSN을 받아서 SN에 전혀
write하지 못한 경우와 일부 SN에 write가 성공한 경우를 나누어 살펴보겠다.

CL1이 SQ에게 새로운 로그 위치를 받았으나 SN들에게 write를 하지 못하고 장애가
발생할 수 있다. 다른 클라이언트인 CL2가 해당 로그 위치에 대해 SN3에게 읽기를
시도 했으나 쓰여진 로그 엔트리가 없기 때문에 err_unwritten 응답을 받게 된다.
CL2가 해당 위치에 append 하던 클라이언트(CL1)이 문제가 생겨 더 이상 append가
진행되지 않을 거라 판단하면 해당 위치에 대해 fill 을 시도한다.

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |  CL1   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |   |  CL2   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |            |
      epoch=1         |         epoch=1      epoch=1      epoch=1      epoch=1         |
         |            |            |            |            |            |            |
      CR:SN1->SN2->SN3|            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
         <--next:ok--->            |            |            |            |            |
         |            |            |            |            |            |            |
      failed          |            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |       the interval between unwritten read and fill|
         |            |          +-+------------+------------+------------+------------+-+
         |            |          | |            |            <---------read:unwritten--> |
         |            |          | <------------+------------+------------+---fill:ok--+ |
         |            |          +-+------------+------------+------------+------------+-+
         |            |            |            <------------+------------+---fill:ok--+
         |            |            |            |            <------------+---fill:ok--+
         |            |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |  CL1   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |   |  CL2   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+

여기서 중요한 이슈가 있다:

- CL1이 아직 살아있고 write를 시도 하기 전에 fill하면 안된다.
- 아직 아무도 append 하지 않은 GLSN을 fill하지 않아야 한다.

첫번째 이슈를 위해서는 CL2가 SN3에게 read 요청에 대한 err_unwritten 응답을 받은
이후, 어느 정도의 시간이 지나서 SN1에게 fill 요청을 보내야 한다. 이 시간 간격이
얼마나 적극적으로 fill을 할 것인가를 결정하고 이는 application마다 달라질 수
있다. 두번째 이슈를 극복하기 위해서 SQ는 peek API를 제공할 것이다. 이 API를
사용하면, GLSN을 새로 받급받지 않고 현재까지 발급된 가장 큰 값을 얻을 수 있다.
연속적으로 Log Tail을 하는 애플리케이션을 위해서는 subscribe API를 제공할
것이다. subscribe API는 CL이 SN들에게 새로운 데이터를 구독받는 API이다.

CL1이 append 실행 중 일부 SN에만 write 성공하고 장애가 발생했다. 이런 경우,
CL2가 해당 로그 위치에 대해 읽기를 시도하다가 write가 완료되지 못한
것을 발견할 수 있다. CL2는 해당 위치에 append가 제대로 이루어지지 않았다고
판단하고 SN1에 fill을 시도한다. SN1에는 CL1이 write를 일부 성공한 값이
들어있으므로 err_written 과 함께 쓰여졌던 값을 반환한다. 

TBD: 이 과정은 더 설계가 필요하닷!

    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |  CL1   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |   |  CL2   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
         |            |            |            |            |            |            |
      epoch=1         |         epoch=1      epoch=1      epoch=1      epoch=1         |
         |            |            |            |            |            |            |
      CR:SN1->SN2->SN3|            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
         <--next:ok--->            |            |            |            |            |
         <--write:ok--+------------>            |            |            |            |
         |            |            |            |            |            |            |
      failed          |            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |       the interval between unwritten read and fill|
         |            |          +-------------------------------------------------------+
         |            |          | |            |            <---------read:unwritten--> |
         |            |          | <------------+------------+-----------fill:written--+ |
         |            |          +-------------------------------------------------------+
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
       +----------------------------------------------------------------------------------+
       |                                                                                  |
       |TBD                                                                               |
       |                                                                                  |
       |Considerations:                                                                   |
       |- CL2 doesn't know who is one writing the log position                            |
       |- CL2 doesn't know if SN who is writing the log position dies or not              |
       |- filling junk at an SN along the chain will fail with err_written                |
       |- junk-filling process and normal write process can be conflicted                 |
       |                                                                                  |
       +----------------------------------------------------------------------------------+
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
         |            |            |            |            |            |            |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+
    |  CL1   |   |   SQ   |   |  SN1   |   |  SN2   |   |  SN3   |   |   MR   |   |  CL2   |
    +--------+   +--------+   +--------+   +--------+   +--------+   +--------+   +--------+


