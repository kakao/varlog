package varlogadm

import (
	"context"
	"fmt"
	"sync"

	"github.com/kakao/varlog/pkg/types"
)

// TopicIDGenerator generates TopicID.
type TopicIDGenerator struct {
	cmView ClusterMetadataView

	last types.TopicID
	mu   sync.Mutex
}

// NewTopicIDGenerator creates a TopicIDGenerator.
// Admin should create a single TopicIDGenerator to avoid conflict of TopicID.
func NewTopicIDGenerator(ctx context.Context, cmView ClusterMetadataView) (*TopicIDGenerator, error) {
	gen := &TopicIDGenerator{
		cmView: cmView,
		last:   0,
	}
	return gen, gen.Refresh(ctx)
}

// Generate returns a new TopicID.
// The TopicID generated by this method is incremented by one starting from
// MinTopicID, which is 1.
// Note that the result ID may already exist in the cluster, the caller can
// call Refresh to reflect the recent metadata, and then call this method
// again.
func (gen *TopicIDGenerator) Generate() types.TopicID {
	gen.mu.Lock()
	defer gen.mu.Unlock()
	gen.last++
	return gen.last
}

// Refresh refreshes the generator.
// It fetches the greatest TopicID issued so far.
// If this method fails, the caller can call this again.
func (gen *TopicIDGenerator) Refresh(ctx context.Context) error {
	md, err := gen.cmView.ClusterMetadata(ctx)
	if err != nil {
		return err
	}

	max := types.TopicID(0)
	for _, td := range md.Topics {
		if max < td.TopicID {
			max = td.TopicID
		}
	}

	gen.mu.Lock()
	defer gen.mu.Unlock()
	if gen.last > max {
		return fmt.Errorf("topic id generator: too old cluster metadata: generator's max=%d, metadata's max=%d",
			gen.last, max)
	}
	gen.last = max
	return nil
}

func (gen *TopicIDGenerator) getMaxTopicID(ctx context.Context) (maxID types.TopicID, err error) {
	clusmeta, err := gen.cmView.ClusterMetadata(ctx)
	if err != nil {
		return maxID, err
	}

	topicDescs := clusmeta.GetTopics()
	for _, topicDesc := range topicDescs {
		if maxID < topicDesc.TopicID {
			maxID = topicDesc.TopicID
		}
	}

	return maxID, nil
}

// LogStreamIDGenerator generates LogStreamID.
type LogStreamIDGenerator struct {
	cmView ClusterMetadataView

	last types.LogStreamID
	mu   sync.Mutex
}

// NewLogStreamIDGenerator creates a LogStreamIDGenerator.
// Admin should create a single LogStreamIDGenerator to avoid conflict of
// LogStreamID.
func NewLogStreamIDGenerator(ctx context.Context, cmView ClusterMetadataView) (*LogStreamIDGenerator, error) {
	gen := &LogStreamIDGenerator{
		cmView: cmView,
		last:   types.LogStreamID(0),
	}
	return gen, gen.Refresh(ctx)
}

// Generate returns a new LogStreamID.
// The LogStreamID generated by this method is incremented by one starting from
// MinLogStreamID, which is 1.
// Note that the result ID may already exist in the cluster, the caller can
// call Refresh to reflect the recent metadata, and then call this method
// again.
func (gen *LogStreamIDGenerator) Generate() types.LogStreamID {
	gen.mu.Lock()
	defer gen.mu.Unlock()
	gen.last++
	return gen.last
}

// Refresh refreshes the generator.
// It fetches the greatest LogStreamID issued so far.
// If this method fails, the caller can call this again.
func (gen *LogStreamIDGenerator) Refresh(ctx context.Context) error {
	md, err := gen.cmView.ClusterMetadata(ctx)
	if err != nil {
		return err
	}

	max := types.LogStreamID(0)
	for _, lsd := range md.LogStreams {
		if max < lsd.LogStreamID {
			max = lsd.LogStreamID
		}
	}

	gen.mu.Lock()
	defer gen.mu.Unlock()
	if gen.last > max {
		return fmt.Errorf("log stream id generator: too old cluster metadata: generator's max=%d, metadata's max=%d",
			gen.last, max)
	}
	gen.last = max
	return nil
}
