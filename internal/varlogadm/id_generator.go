package varlogadm

import (
	"context"
	"fmt"
	"sync"

	"github.com/kakao/varlog/pkg/types"
)

// LogStreamIDGenerator generates LogStreamID.
type LogStreamIDGenerator struct {
	cmView ClusterMetadataView

	last types.LogStreamID
	mu   sync.Mutex
}

// NewLogStreamIDGenerator creates a LogStreamIDGenerator.
// Admin should create a single LogStreamIDGenerator to avoid conflict of
// LogStreamID.
func NewLogStreamIDGenerator(ctx context.Context, cmView ClusterMetadataView) (*LogStreamIDGenerator, error) {
	gen := &LogStreamIDGenerator{
		cmView: cmView,
		last:   types.LogStreamID(0),
	}
	return gen, gen.Refresh(ctx)
}

// Generate returns a new LogStreamID.
// The LogStreamID generated by this method is incremented by one starting from
// MinLogStreamID, which is 1.
// Note that the result ID may already exist in the cluster, the caller can
// call Refresh to reflect the recent metadata, and then call this method
// again.
func (gen *LogStreamIDGenerator) Generate() types.LogStreamID {
	gen.mu.Lock()
	defer gen.mu.Unlock()
	gen.last++
	return gen.last
}

// Refresh refreshes the generator.
// It fetches the maximum LogStreamID issued so far.
// If this method fails, the caller can call this again.
func (gen *LogStreamIDGenerator) Refresh(ctx context.Context) error {
	md, err := gen.cmView.ClusterMetadata(ctx)
	if err != nil {
		return err
	}

	max := types.LogStreamID(0)
	for _, lsd := range md.LogStreams {
		if max < lsd.LogStreamID {
			max = lsd.LogStreamID
		}
	}

	gen.mu.Lock()
	defer gen.mu.Unlock()
	if gen.last > max {
		return fmt.Errorf("log stream id generator: too old cluster metadata: generator's max=%d, metadata's max=%d",
			gen.last, max)
	}
	gen.last = max
	return nil
}

// TopicIDGenerator generates valid TopicIDs.
type TopicIDGenerator interface {
	// Generate returns conflict-free TopicID. If the returned identifier is duplicated, it
	// means that the varlog cluster consistency is broken.
	Generate() types.TopicID

	// Refresh renews TopicIDGenerator to update the latest cluster metadata.
	Refresh(ctx context.Context) error
}

// TODO: seqTopicIDGen does not consider the restart of VMS.
type seqTopicIDGen struct {
	seq types.TopicID
	mu  sync.Mutex

	cmView ClusterMetadataView
	snMgr  StorageNodeManager
}

func NewSequentialTopicIDGenerator(ctx context.Context, cmView ClusterMetadataView, snMgr StorageNodeManager) (TopicIDGenerator, error) {
	gen := &seqTopicIDGen{
		cmView: cmView,
		snMgr:  snMgr,
	}
	if err := gen.Refresh(ctx); err != nil {
		return nil, err
	}
	return gen, nil
}

func (gen *seqTopicIDGen) Generate() types.TopicID {
	gen.mu.Lock()
	defer gen.mu.Unlock()
	gen.seq++
	return gen.seq
}

func (gen *seqTopicIDGen) Refresh(ctx context.Context) error {
	maxID, err := gen.getMaxTopicID(ctx)
	if err != nil {
		return err
	}

	gen.mu.Lock()
	defer gen.mu.Unlock()
	if gen.seq < maxID {
		gen.seq = maxID
	}
	return nil
}

func (gen *seqTopicIDGen) getMaxTopicID(ctx context.Context) (maxID types.TopicID, err error) {
	clusmeta, err := gen.cmView.ClusterMetadata(ctx)
	if err != nil {
		return maxID, err
	}

	topicDescs := clusmeta.GetTopics()
	for _, topicDesc := range topicDescs {
		if maxID < topicDesc.TopicID {
			maxID = topicDesc.TopicID
		}
	}

	return maxID, nil
}
